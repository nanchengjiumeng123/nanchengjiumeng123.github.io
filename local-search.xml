<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跳跃表-zskipList</title>
    <link href="/2024/02/20/framework/redis/2024-02-20_%E8%B7%B3%E8%A1%A8-zskipList/"/>
    <url>/2024/02/20/framework/redis/2024-02-20_%E8%B7%B3%E8%A1%A8-zskipList/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃表概述">1.跳跃表概述</h1><p>跳跃表（<ahref="http://en.wikipedia.org/wiki/Skip_list">skiplist</a>）是一种随机化的数据，由 William Pugh 在论文<ahref="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf">《Skiplists: a probabilistic alternative to balanced trees》</a>中提出，跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 ——查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说，跳跃表的实现要简单直观得多。</p><p>跳表（skip list）对表的是平衡树（AVL Tree）和 二分查找，是一种插入/删除/搜索 都是 <em>O</em>(<em>l<strong>o</strong>gn</em>)的数据结构。</p><p>以下是个典型的跳跃表例子（图片来自<ahref="http://en.wikipedia.org/wiki/File:Skip_list.svg">维基百科</a>）：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/skiplist.png" /></p><p>从图中可以看到， 跳跃表主要由以下部分构成：</p><ul><li>表头（head）：负责维护跳跃表的节点指针。</li><li>跳跃表节点：保存着元素值，以及多个层。</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li><li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li></ul><h1 id="如何给有序链表加速">2.如何给有序链表加速</h1><p>一开始就讲跳表肯定是晦涩难懂的，我们已经了解了跳表的基础定义，我们先了解一下有序链表。看看有序链表是如何“加速”的。</p><blockquote><p>有序链表是所有元素以递增或递减方式有序排列的数据结构，其中每个节点都指向下个节点的next指针，最后一个节点的next指针指向NULL。</p></blockquote><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317165802204.png" /></p><p>如上，我们有一个单向有序链表，如果要查询31的元素，需要从第一个元素开始依次向后查询、比较才可以找到，找到顺序为1-&gt;8-&gt;10-&gt;11-&gt;20-&gt;26-&gt;31，共6次比较，时间复杂度为<em>O(N)。有序链表的插入和删除操作都需要先找到合适的位置在修改next指针，修改操作基本不耗费时间，所以插入、删除、修改有序链表的耗时主要在查找元素上。</em></p><p><font size=4><strong>如何进行简单优化？可以让它的查询时间复杂度变低，也就是加速它的查询</strong>。</font></p><blockquote><p>一般来说这种加速的方式的话，就类似于星际穿越里面这有点玄学，但是你一定要记住一个概念就行了，一维的数据结构要加速的话，经常采用的方式就是升维也就是说变成二维。为什么要多一层维度，因为你多了一个维度之后，就会有多一级的信息在里面，这样多一级的信息就可以帮助你可以很快地得到一维里面你必须挨个走才能走到的那些元素</p></blockquote><p><font size=4><strong>添加第一级索引</strong></font></p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317172225269.png" /></p><p>具体我们来看上图，在原始链表的情况下，我们再增加一个维度，也就是在上面再增加一层索引，我们叫做第一级索引，那么第一级索引的话就不是指向它元素的next 元素了，而是指向它的 next next ，也就是说你可以理解为 next + 1就行了，所以第一级索引的话就是第一个元素，马上第三个元素、第五个元素、第七个元素。</p><ul><li><p>这里你就会发现如果你要找26的话，我们怎么办？我们这么查找，先查找第一级索引看有没有110 26 ，如果有那就说明 26存在这个链表里面是存在的，说明我们查询到了。</p></li><li><p>我们再看要查另一个元素，比如说31，我们怎么走？还是先找第一级，31是大于 1 的，所以后继往后到达 10索引的值，31 是大于 10 的，继续往后到了 10 ，31 也大 26的，再继续往后发现 60 大于 31 了。说明 31 是存在于 26 和 60这两个索引之间的元素里面的，那么这个时候从第一级元素向下走到原始的链表了，从对应的位置挨个找就会发现31 找到了，说明 31 也是存在的。</p></li></ul><p><font size=4><strong>添加第二级索引</strong></font></p><p>那么有的朋友可能就会想了，你加一级索引的话，每次相当于步伐加 2了，但是它的速度的话也就是比原来稍微快了一点，能不能更快呢？</p><p>同理可得，在第一级索引的基础上，我们把它当作是一个原始链表一样，往上再加一级索引，也就是说每次针对第一级索引走两步。那么它相等于原始链表相当于每次就走了四步。对不对，就乘于2，那这样的话，速度就更加高效了。</p><ul><li>比如我举个例子要查31，先找 1，31 比 1要大，再找 26 ，这时候你会发现31 也是比 26 大的，所以 26这里的话就必须向下再走一级索引了，走到第一级索引的 26 来，再类似于之前26 和 60 之间，然后再走到下一层， 这样一直走下来找到31。</li></ul><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317172847010.png" /></p><p><font size=4><strong>添加多级索引</strong></font></p><p>以此类推，增加多级索引</p><p>假设有五级索引的这么一个原始链表，那么我们要查一个元素，比如说要查 62元素或者中间元素，就类似于下图，一级一级一级一级走下来，最后的话就可以查到我们需要的62这个元素。当然的话你最后查到原始链表，你会发现比如说是我们要查63或者61，原始链表里面没有，我们就说元素不存在，在我们这个有序的链表里面，也就是说在跳表里面查不到这么一个元素。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317175020869.png" /></p><p><em>如果我们将有序链表的部分节点分层，每一层都是一个有序链表。在查找时优先从最高层开始向后查找，当到达某节点时，如果next节点值大于要查找的值或next指针指向NULL，则从当前节点下降一成继续向后查找，这样是否可以提升查询效率呢？</em></p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317175241953.png" /></p><p>使用分层有序链表，比如我们查找值为31的节点时，查找步骤如下：</p><ol type="1"><li>从最高层第2层开始查找，1节点比31值要小，继续向后比较。</li><li>10节点比31节点要小，继续向后比较，这时会发现第2层10节点的next指针是指向NULL，所以在10节点就开始需要下降一层到第1层并继续向后查找节点进行比较。</li><li>在下降到第1层中，10节点的值比31要小，继续向后比较，第1层10节点的next指针指向26，26比31要小，继续向后比较，第1层26节点的next指针指向60，60比31要大，需要下降一层继续向后比较。</li><li>最后下降到了第0层，第0层的26节点的next指针指向31，31为我们要找的节点，节点被找到。</li></ol><h1 id="redis跳跃表">3.redis跳跃表</h1><p>为了满足自身的功能需要， Redis 基于 William Pugh论文中描述的跳跃表进行了以下修改：</p><ol type="1"><li>允许重复的 <code>score</code> 值：多个不同的 <code>member</code> 的<code>score</code> 值可以相同。</li><li>进行对比操作时，不仅要检查 <code>score</code> 值，还要检查<code>member</code> ：当 <code>score</code> 值可以重复时，单靠<code>score</code> 值无法判断一个元素的身份，所以需要连<code>member</code> 域都一并检查才行。</li><li>每个节点都带有一个高度为 1层的后退指针，用于从表尾方向向表头方向迭代：当执行 <ahref="http://redis.readthedocs.org/en/latest/sorted_set/zrevrange.html#zrevrange">ZREVRANGE</a>或 <ahref="http://redis.readthedocs.org/en/latest/sorted_set/zrevrangebyscore.html#zrevrangebyscore">ZREVRANGEBYSCORE</a>这类以逆序处理有序集的命令时，就会用到这个属性。</li></ol><h2 id="zskiplist">3.1 zskiplist</h2><p>这个修改版的跳跃表由 <code>redis.h/zskiplist</code> 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 跳跃表链表结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br><br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br><br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br><br>&#125; zskiplis<br></code></pre></td></tr></table></figure><p>该结构体属性如下：</p><ul><li>header：指向跳跃表头节点。头节点时跳跃表的特殊节点，他的level是固定数组元素个数为32个，头节点不存储任何score和obj，level也不计入跳跃表的高度，头节点在初始化时，score值为0，ele值为NULL，32个元素的forward值都指向NULL，span为0.</li><li>tail：指向跳跃表尾节点。</li><li>length：跳跃表长度，表示第0层除头节点以外的所有节点总数。</li><li>level：跳跃表高度，除头节点外，其他节点层数最高的即为跳跃表高度。</li></ul><p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到。</p><h2 id="zskiplistnode">3.2 zskiplistNode</h2><p>跳跃表的节点由 <code>redis.h/zskiplistNode</code> 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br><br>    <span class="hljs-comment">// member 对象</span><br>    robj *obj;<br><br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br><br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br><br>        <span class="hljs-comment">// 这个层跨越的节点数量</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br><br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><ul><li>score：是一个double类型的浮点数，用户存储有序链表节点的分值，跳跃表中的所有节点都按分值从小到大来排序。</li><li>obj：为节点的成员对象，指向一个字符串对象，而字符串对象则保存着一个SDS值。</li><li>backward：后退指针，用于从从表尾向表头遍历跳跃表访问节点时使用。指向跳跃表当前节点的最底层节点的前一个节点，头节点和第一个节点的backward指向NULL。</li><li>层(level)：为动态柔性数组，数组可以包含多个元素，每个元素都包含一个指向其他节点的指针。每个节点层高不同对应的数组大小也不同，每次创建一个新跳跃表节点的时候，根据幂次定律(power law，值越大出现的概率越小）随机生成一个1～32的值，一般来说，层的数量越多，访问其他节点的速度就越快。</li></ul><p>这level数组中的每项元素包含以下两个元素：</p><ul><li>forward：指向本层下一个节点，每个层都有一个指向表尾方向的前进指针(level[i]-&gt;forward属性），用于从表头向表尾方向访问节点，尾节点的forward指向NULL。</li><li>span：层的跨度 (level[i]-&gt;span属性）用于记录两个节点之间的距离，即forward指向的节点于本节点之间的元素个数，span值越大，说明跳过的节点个数越多。</li></ul><p>以下是操作这两个数据结构的 API ，API 的用途与相应的算法复杂度：</p><table><thead><tr class="header"><th style="text-align: left;">函数</th><th style="text-align: left;">作用</th><th style="text-align: left;">复杂度</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>zslCreateNode</code></td><td style="text-align: left;">创建并返回一个新的跳跃表节点</td><td style="text-align: left;">最坏 O(1)</td></tr><tr class="even"><td style="text-align: left;"><code>zslFreeNode</code></td><td style="text-align: left;">释放给定的跳跃表节点</td><td style="text-align: left;">最坏 O(1)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslCreate</code></td><td style="text-align: left;">创建并初始化一个新的跳跃表</td><td style="text-align: left;">最坏 O(1)</td></tr><tr class="even"><td style="text-align: left;"><code>zslFree</code></td><td style="text-align: left;">释放给定的跳跃表</td><td style="text-align: left;">最坏 O(N)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslInsert</code></td><td style="text-align: left;">将一个包含给定 <code>score</code> 和<code>member</code> 的新节点添加到跳跃表中</td><td style="text-align: left;">最坏 O(N)平均 O(logN)</td></tr><tr class="even"><td style="text-align: left;"><code>zslDeleteNode</code></td><td style="text-align: left;">删除给定的跳跃表节点</td><td style="text-align: left;">最坏 O(N)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslDelete</code></td><td style="text-align: left;">删除匹配给定 <code>member</code> 和<code>score</code> 的元素</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="even"><td style="text-align: left;"><code>zslFirstInRange</code></td><td style="text-align: left;">找到跳跃表中第一个符合给定范围的元素</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslLastInRange</code></td><tdstyle="text-align: left;">找到跳跃表中最后一个符合给定范围的元素</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="even"><td style="text-align: left;"><code>zslDeleteRangeByScore</code></td><td style="text-align: left;">删除 <code>score</code>值在给定范围内的所有节点</td><td style="text-align: left;">最坏 O(N^2)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslDeleteRangeByRank</code></td><td style="text-align: left;">删除给定排序范围内的所有节点</td><td style="text-align: left;">最坏 O(N^2)</td></tr><tr class="even"><td style="text-align: left;"><code>zslGetRank</code></td><td style="text-align: left;">返回目标元素在有序集中的排位</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslGetElementByRank</code></td><td style="text-align: left;">根据给定排位，返回该排位上的元素节点</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr></tbody></table><blockquote><p><strong>Redis 跳跃表默认允许最大的层数是 32</strong>，被源码中ZSKIPLIST_MAXLEVEL 定义。</p></blockquote><h2 id="redis跳跃表实现">3.3 redis跳跃表实现</h2><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和<code>redis.h/zskiplist</code> 两个结构定义， 其中<code>zskiplistNode</code> 结构用于表示跳跃表节点， 而<code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息，比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211111126.png" /></p><p>上图展示了一个跳跃表示zskiplist 结构，该结构包含以下属性：</p><ul><li><code>header</code> ：指向跳跃表的表头节点。</li><li><code>tail</code> ：指向跳跃表的表尾节点。</li><li><code>level</code>：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li><code>length</code>：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p>位于 <code>zskiplist</code> 结构右方的是四个<code>zskiplistNode</code> 结构， 该结构包含以下属性：</p><ul><li>层（level）：节点中用 <code>L1</code> 、 <code>L2</code> 、<code>L3</code> 等字样标记节点的各个层， <code>L1</code> 代表第一层，<code>L2</code>代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退（backward）指针：节点中用 <code>BW</code>字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和<code>3.0</code>是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和<code>o3</code> 是节点所保存的成员对象。</li></ul><h4 id="层">层</h4><p>跳跃表节点的 level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<ahref="https://link.juejin.cn?target=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPower_law">powerlaw</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和<code>32</code> 之间的值作为 <code>level</code> 数组的大小，这个大小就是层的“高度”。</p><p>下图分别展示了三个高度为 <code>1</code> 层、 <code>3</code> 层和<code>5</code> 层的节点， 因为 C 语言的数组索引总是从 <code>0</code>开始的， 所以节点的第一层是 <code>level[0]</code> ， 而第二层是<code>level[1]</code> ， 以此类推。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211216113.png" /></p><h4 id="前进指针">前进指针</h4><p>每个层都有一个指向表尾方向的前进指针（<code>level[i].forward</code>属性）， 用于从表头向表尾方向访问节点。</p><p>上图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：</p><ol type="1"><li>迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</li><li>在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</li><li>在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</li><li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个<code>NULL</code> ， 程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</li></ol><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211242486.png" /></p><h4 id="跨度">跨度</h4><p>层的跨度（<code>level[i].span</code>属性）用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大， 它们相距得就越远。</li><li>指向 <code>NULL</code> 的所有前进指针的跨度都为 <code>0</code> ，因为它们没有连向任何节点。</li></ul><p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 ——遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子， 如下用虚线标记了在跳跃表中查找分值为 <code>3.0</code> 、成员对象为 <code>o3</code> 的节点时， 沿途经历的层：查找的过程只经过了一个层， 并且层的跨度为 <code>3</code> ，所以目标节点在跳跃表中的排位为 <code>3</code> 。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211322796.png" /></p><p>再举个例子， 如下用虚线标记了在跳跃表中查找分值为 <code>2.0</code> 、成员对象为 <code>o2</code> 的节点时， 沿途经历的层：在查找节点的过程中， 程序经过了两个跨度为 <code>1</code> 的节点，因此可以计算出， 目标节点在跳跃表中的排位为 2 。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211430979.png" /></p><h4 id="后退指针">后退指针</h4><p>节点的后退指针（<code>backward</code>属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211445751.png" /></p><p>上图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的 <code>tail</code> 指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 <code>NULL</code>的后退指针， 于是访问结束。</p><h4 id="分值和成员">分值和成员</h4><ul><li>节点的分值（<code>score</code> 属性）是一个 <code>double</code>类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</li><li>节点的成员对象（<code>obj</code> 属性）是一个指针，它指向一个字符串对象， 而字符串对象则保存着一个 SDS（简单动态字符串）值。</li></ul><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p>举个例子， 在下图所示的跳跃表中， 三个跳跃表节点都保存了相同的分值<code>10086.0</code> ， 但保存成员对象 <code>o1</code>的节点却排在保存成员对象 <code>o2</code> 和 <code>o3</code> 的节点之前，而保存成员对象 <code>o2</code> 的节点又排在保存成员对象 <code>o3</code>的节点之前， 由此可见， <code>o1</code> 、 <code>o2</code> 、<code>o3</code> 三个成员对象在字典中的排序为<code>o1 &lt;= o2 &lt;= o3</code> 。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211458874.png" /></p><h3 id="跳跃表">跳跃表</h3><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如下图 所示：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211508748.png" /></p><p>但通过使用一个 <code>zskiplist</code> 结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息，如下所示：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211528404.png" /></p><h1 id="问题">4. 问题</h1><p>为啥 redis 使用跳表(skiplist)而不是使用 red-black？</p><ol type="1"><li>skiplist的复杂度和红黑树一样，而且实现起来更简单。</li><li>在并发环境下skiplist有另外一个优势，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。</li></ol><p>附：开发者说的为什么选用skiplist <ahref="https://link.juejin.cn/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D1171423">TheSkip list</a></p><blockquote><p>There are a few reasons:</p><p>They are not very memory intensive. It's up to you basically.Changing parameters about the probability of a node to have a givennumber of levels will make then less memory intensive than btrees. Asorted set is often target of many ZRANGE or ZREVRANGE operations, thatis, traversing the skip list as a linked list. With this operation thecache locality of skip lists is at least as good as with other kind ofbalanced trees. They are simpler to implement, debug, and so forth. Forinstance thanks to the skip list simplicity I received a patch (alreadyin Redis master) with augmented skip lists implementing ZRANK inO(log(N)). It required little changes to the code. About the Append Onlydurability &amp; speed, I don't think it is a good idea to optimizeRedis at cost of more code and more complexity for a use case that IMHOshould be rare for the Redis target (fsync() at every command). Almostno one is using this feature even with ACID SQL databases, as theperformance hint is big anyway.</p><p>About threads: our experience shows that Redis is mostly I/O bound.I'm using threads to serve things from Virtual Memory. The long termsolution to exploit all the cores, assuming your link is so fast thatyou can saturate a single core, is running multiple instances of Redis(no locks, almost fully scalable linearly with number of cores), andusing the "Redis Cluster" solution that I plan to develop in thefuture.</p></blockquote><h1 id="总结">5. 总结</h1><ul><li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis中没有其他应用。</li><li>Redis 的跳跃表实现由 <code>zskiplist</code> 和<code>zskiplistNode</code> 两个结构组成， 其中 <code>zskiplist</code>用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而<code>zskiplistNode</code> 则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code>之间的随机数。</li><li>在同一个跳跃表中， 多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序， 当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h1 id="read-more">6.Read more</h1><p>:lollipop::http://redisbook.com/preview/skiplist/datastruct.html</p><p>:lollipop::https://juejin.cn/post/689302628126206591496</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zskipList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2023/01/30/java_se/2022-05-13_%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/01/30/java_se/2022-05-13_%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常">1.异常</h1><p><strong>Java中的异常处理</strong>是处理运行时错误以保持应用程序正常流程的有效手段之一。Java异常处理是一种处理运行时错误的机制，如ClassNotFoundException、IOException、SQLException、RemoteException等。</p><p><strong>异常</strong>是不需要的或意外的事件，它发生在程序执行期间，即在运行时，它会扰乱程序指令的正常流程。程序可以捕获和处理异常。当方法中发生异常时，它会创建一个对象。该对象称为异常对象。它包含有关异常的信息，例如异常的名称和描述以及发生异常时程序的状态。</p><blockquote><p><strong>错误</strong>表示不可恢复的情况，例如 Java 虚拟机 (JVM)内存耗尽、内存泄漏、堆栈溢出错误、库不兼容、无限递归等。错误通常是程序员无法控制的，我们不应该试图去处理错误。</p></blockquote><p>讨论最重要的部分，即<strong>Error 和 Exception之间的区别</strong>，如下所示：</p><ul><li><strong>错误：</strong>错误表示一个合理的应用程序不应尝试捕获的严重问题。</li><li><strong>异常：</strong>异常表示合理的应用程序可能会尝试捕获的情况。</li></ul><h2 id="出现异常的主要原因">1.1 出现异常的主要原因</h2><ul><li>无效的用户输入</li><li>设备故障</li><li>失去网络连接</li><li>物理限制（磁盘内存不足）</li><li>代码错误</li><li>打开一个不可用的文件</li></ul><h2 id="异常层次结构">1.2 异常层次结构</h2><p>所有异常和错误类型都是 Throwable类的子类，<strong>Throwable</strong>是层次结构的基类。一类由<strong>Exception</strong>领导。此类用于用户程序应捕获的异常情况。NullPointerException是此类异常的一个示例。</p><p>Java 运行时系统 ( <ahref="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">JVM</a>) 使用另一个类别<strong>Error</strong>来指示与运行时环境本身 (JRE)相关的错误。StackOverflowError 是此类错误的一个示例。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/throwable/Exception-in-java1.png"alt="Java 中的异常层次结构" /><figcaption aria-hidden="true">Java 中的异常层次结构</figcaption></figure><p>由于<strong>Error</strong>通常是程序员无法控制的，所以我们不应该试图去处理错误，我们只针对<strong>Exception</strong>这类处理即可。</p><h2 id="异常类型">1.3 异常类型</h2><p>Java 定义了几种与其各种类库相关的异常类型。Java还允许用户定义自己的异常。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/throwable/Group21-660x330.jpg"alt="异常类型" /><figcaption aria-hidden="true">异常类型</figcaption></figure><p><strong>异常可以按两种方式分类：</strong></p><ol type="1"><li><strong>内置异常</strong><ul><li>检查异常</li><li>未经检查的异常</li></ul></li><li><strong>用户定义的异常</strong></li></ol><p>让我们讨论上面定义的列出的异常，如下所示：</p><h2 id="内置异常"><strong>1.4 内置异常</strong></h2><p>内置异常是 Java 库中可用的异常。这些异常适用于解释某些错误情况。</p><ul><li><strong>检查异常：</strong>已检查异常称为编译时异常，因为这些异常是在编译时由编译器检查的。</li><li><strong>未检查异常：</strong>未检查异常与检查异常正好相反。编译器不会在编译时检查这些异常。简单来说，如果一个程序抛出一个uncheckedexception，即使我们没有处理或声明它，程序也不会给出编译错误。</li></ul><blockquote><p>未检查异常属于运行时异常，都继承RuntimeException。这些异常只有在运行的时候才能确定是否抛出异常。编译时不由编译器检查。</p></blockquote><h3 id="检查异常">1.4.1 检查异常</h3><p>这些是在编译时检查的异常。如果方法中的某些代码抛出已检查的异常，则该方法必须处理该异常，或者必须使用<ahref="https://www.geeksforgeeks.org/throw-throws-java/"><em>throws</em>关键字</a>指定该异常。在检查异常中，有两种类型：完全检查异常和部分检查异常。一个完全检查的异常是一个检查异常，它的所有子类也被检查，像IOException，InterruptedException。部分检查异常是一种检查异常，其中某些子类未检查，如Exception。</p><p>例如，考虑下面的 Java程序，它打开位于“C:.txt”位置的文件并打印它的前三行。该程序无法编译，因为函数main() 使用 FileReader() 并且 FileReader()抛出已检查的异常<em>FileNotFoundException</em>。它还使用 readLine() 和close() 方法，这些方法也抛出已检查的异常<em>IOException</em>。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">FileReader</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;C:\\test\\a.txt&quot;</span>);<br>      <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">fileInput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(file);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; counter &lt; <span class="hljs-number">3</span>; counter++)<br>          System.out.println(fileInput.readLine());<br>      fileInput.close();<br>  &#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">D:\workspace\project\IdeaProjects\demo\src\main\java\com\example\demo\aaa\DDD.java:<span class="hljs-number">58</span>:<span class="hljs-number">27</span><br>java: 未报告的异常错误java.io.FileNotFoundException; 必须对其进行捕获或声明以便抛出<br></code></pre></td></tr></table></figure><p>程序是无法运行的，因为我们必须手动处理这些检查异常，要修复上述程序，我们要么需要使用throws 指定异常列表，要么需要使用 try-catch块。即可使上述程序无编译错误。</p><h3 id="非检查异常运行时异常">1.4.2 非检查异常（运行时异常）</h3><p>这些是编译时不检查的异常。在 C++中，所有异常都是未经检查的，因此编译器不会强制处理或指定异常。由程序员来文明，并指定或捕获异常。在Java中，<em>Error</em>和<em>RuntimeException</em>类下的异常是非检查的异常，throwable下的所有其他异常都是检查异常。</p><p>以下 Java程序。它编译得很好，但在运行时会抛出<em>ArithmeticException</em>。编译器允许它编译，因为<em>ArithmeticException</em>是一个非检查的异常。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> y / x;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p>简而言之，<strong><em>非检查的异常是不需要在 throws子句中捕获或声明的运行时异常</em></strong>。这些异常通常是由编程错误引起的，例如试图越界访问数组中的索引或试图除以零。</p><p>非检查的异常包括 RuntimeException 类的所有子类，以及 Error类及其子类。</p><h2 id="用户自定义异常">1.5 用户自定义异常</h2><p>异常是程序执行期间发生的问题（运行时错误）。当发生异常时，程序会突然终止，并且不会执行生成异常行之后的代码。</p><p>有时，Java中内置的异常并不能描述某种情况。在这种情况下，用户还可以创建异常，称为“用户定义的异常”，并使用“throw”关键字抛出该异常。</p><h3 id="为什么要使用自定义异常">为什么要使用自定义异常？</h3><ul><li>捕获并提供对现有 Java 异常子集的特定处理。</li><li>业务逻辑异常：这些是与业务逻辑和工作流相关的异常。这对于应用程序用户或开发人员了解确切的问题很有用。</li></ul><p>为了创建自定义异常，我们需要扩展属于<strong>java.lang 包的 Exception类。</strong></p><p>例如，下面代码中的 MyException 扩展了 Exception 类。</p><p>自定义异常只需要继承RuntimeException即可。下列为一个简单的自定义异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String errorCode;<br>    <span class="hljs-keyword">private</span> String errorMsg;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String errorCode, String errorMsg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.errorCode = errorCode;<br>        <span class="hljs-built_in">this</span>.errorMsg = errorMsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>    ... ...<br>    <span class="hljs-comment">//逻辑失败处理</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;your errorCode&quot;</span>,<span class="hljs-string">&quot;your errorMsg&quot;</span>);<br>    <br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="打印异常的方法">1.6 打印异常的方法</h2><h3 id="printstacktrace">1.6.1 <strong>printStackTrace()</strong></h3><ul><li><code>printStackTrace()</code>–该方法打印异常信息，格式为异常名称：<strong>异常描述，堆栈</strong></li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span>&#123;<br>         System.out.println(a/b);<br>     &#125; <span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>         e.printStackTrace();<br>     &#125; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><h3 id="tostring">1.6.2 <strong>toString()</strong></h3><ul><li><code>toString()</code> –该方法以异常名称：<strong>异常描述的格式打印异常信息</strong>。</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span>&#123;<br>         System.out.println(a/b);<br>     &#125; <span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>          System.out.println(e.toString());<br>     &#125; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure><h3 id="getmessage">1.6.3 <strong>getMessage()</strong></h3><ul><li><code>getMessage()</code> -该方法只打印异常的<strong>描述</strong>。</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span>&#123;<br>         System.out.println(a/b);<br>     &#125; <span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>           System.out.println(e.getMessage());<br>     &#125; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/ by zero<br></code></pre></td></tr></table></figure><h3 id="不处理异常">1.6.4 不处理异常</h3><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     System.out.println(a/b);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>则为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><h1 id="jvm-是如何处理异常的">2.JVM 是如何处理异常的？</h1><p><strong>默认异常处理：</strong>无论何时在方法内部，如果发生异常，该方法都会创建一个称为异常对象的对象，并将其交给运行时系统(JVM)。</p><p>异常对象包含<strong>异常的名称和描述以及发生异常的程序的当前状态</strong>。创建异常对象并在运行时系统中处理它称为抛出异常。可能有一个已调用的方法列表，以到达发生异常的方法。这个有序的方法列表称为<strong>CallStack</strong>。现在将发生以下过程。</p><ul><li>运行时系统搜索调用堆栈以找到包含可以处理发生的异常的代码块的方法。代码块称为<strong>Exceptionhandler（异常处理程序</strong>）。</li><li>运行时系统从发生异常的方法开始搜索，并按照调用方法的相反顺序遍历调用堆栈。</li><li>如果找到合适的处理程序，则将发生的异常传递给它。合适的处理程序意味着抛出的异常对象的类型与它可以处理的异常对象的类型相匹配。</li><li>如果运行时系统搜索调用堆栈上的所有方法，但找不到合适的处理程序，则运行时系统将Exception Object移交给<strong>默认的异常处理程序</strong>，它是运行时系统的一部分。该处理程序以下列格式打印异常信息并<strong>异常</strong>终止程序。</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Exception <span class="hljs-keyword">in</span> <span class="hljs-keyword">thread</span> <span class="hljs-string">&quot;xxx&quot;</span> Name of Exception : Description<br><span class="hljs-params">...</span> <span class="hljs-params">...</span><span class="hljs-params">...</span> ..  <span class="hljs-comment">// Call Stack</span><br></code></pre></td></tr></table></figure><p>还记得上面，如果没有处理异常打印，它会默认打印：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zero<br>at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.aaa</span><span class="hljs-selector-class">.DDD</span><span class="hljs-selector-class">.main</span>(DDD<span class="hljs-selector-class">.java</span>:<span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><p><strong>调用堆栈的流程</strong></p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/throwable/call-stack.png"alt="调用堆栈" /><figcaption aria-hidden="true">调用堆栈</figcaption></figure><h1 id="try-catch异常处理">3.try-catch异常处理</h1><p>针对于程序中异常的处理方式，一般有2种：</p><ul><li>手动抛出异常：<code>throw new MyException("your errorCode", "your errorMsg")</code></li><li>通过try-cathc-finally处理</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">4</span>];<br>     System.out.println(<span class="hljs-string">&quot;Hi, I want to execute&quot;</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="hljs-number">4</span><br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">59</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，一个数组被定义为大小，即你只能访问索引 0 到 3的元素。但是你试图访问索引 4处的元素（错误地）这就是它抛出异常的原因。<strong>在这种情况下，JVM异常</strong>终止程序。语句System.out.println("Hi,I want to execute"); 永远不会执行。要执行它，我们必须使用 try-catch处理异常。因此，为了继续程序的正常流程，我们需要一个 try-catch子句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// block of code to monitor for errors</span><br>    <span class="hljs-comment">// the code you think can raise an exception</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 exOb) &#123;<br>    <span class="hljs-comment">// exception handler for ExceptionType1</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 exOb) &#123;<br>    <span class="hljs-comment">// exception handler for ExceptionType2</span><br>&#125;<br><span class="hljs-comment">// optional</span><br><span class="hljs-keyword">finally</span> &#123;  <span class="hljs-comment">// block of code to be executed after try block ends </span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下要点：</p><ul><li><p>在一个方法中，可以有多个可能引发异常的语句，因此将所有这些语句放在它们自己的<strong>try块中，并在它们自己的catch</strong>块中为每个语句提供一个单独的异常处理程序。</p></li><li><p>如果<strong>try</strong>块中发生异常，则该异常由与其关联的异常处理程序处理。要关联异常处理程序，我们必须在它之后放置一个<strong>catch</strong>块。可以有多个异常处理程序。每个<strong>catch</strong>块都是一个异常处理程序，用于处理由其参数指示的类型的异常。参数ExceptionType声明它可以处理的异常类型，并且必须是从<strong>Throwable</strong>类继承的类的名称。</p></li><li><p>对于每个 try 块，可以有零个或多个 catch块，但<strong>只有一个</strong>final 块。</p><blockquote><p>finally 块是可选的。无论 try块中是否发生异常，它总是被执行。如果发生异常，那么它将在<strong>try 和catch 块之后执行。</strong>而如果没有发生异常，那么就会在<strong>try</strong>块之后执行。java中的finally块用于放置重要代码，例如清理代码，例如关闭文件或关闭连接。</p></blockquote></li></ul><h1 id="常见的异常">4.常见的异常</h1><ol type="1"><li><strong>ArithmeticException：</strong>当算术运算出现异常情况时抛出。</li><li><strong>ArrayIndexOutOfBoundsException：</strong>抛出它表示已使用非法索引访问数组。索引为负数或大于或等于数组的大小。</li><li><strong>ClassNotFoundException：</strong>当我们尝试访问未找到其定义的类时引发此异常</li><li><strong>FileNotFoundException：</strong>当文件不可访问或无法打开时会引发此异常。</li><li><strong>IOException：</strong> 当输入输出操作失败或中断时抛出</li><li><strong>InterruptedException：</strong>当一个线程正在等待、休眠或做一些处理，被中断时抛出。</li><li><strong>NoSuchFieldException：</strong>当类不包含指定的字段（或变量）时抛出</li><li><strong>NoSuchMethodException：</strong>访问未找到的方法时抛出。</li><li><strong>NullPointerException：</strong>引用空对象的成员时引发此异常。Null 代表什么都没有</li><li><strong>NumberFormatException：</strong>当方法无法将字符串转换为数字格式时会引发此异常。</li><li><strong>RuntimeException：</strong> 这表示在运行时发生的异常。</li><li><strong>StringIndexOutOfBoundsException：</strong> 它由 String类方法抛出，指示索引为负数或大于字符串的大小</li><li><strong>IllegalArgumentException：</strong>当该方法接收到不完全符合给定关系或条件的参数时，此异常将抛出错误或错误语句。它属于未经检查的异常。</li><li><strong>IllegalStateException：</strong>当应用程序中的特定操作未访问该方法时，此异常将抛出错误或错误消息。它属于未经检查的异常。</li></ol><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>path与classpath</title>
    <link href="/2023/01/28/java_se/2022-05-12_path%E4%B8%8Eclasspath/"/>
    <url>/2023/01/28/java_se/2022-05-12_path%E4%B8%8Eclasspath/</url>
    
    <content type="html"><![CDATA[<h1 id="path与classpath">1.path与classpath</h1><h2 id="作用简介">1.1 作用简介</h2><p>安装完JDK(Java DevelopmentKit，Java开发套件)之后，可以在安装目录下找到两个子目录(bin目录和lib目录)。bin目录中包含着Java编译器等可执行文件。</p><p><strong>PATH 环境变量是由分号(;)分隔的一系列目录。Windows 在 PATH目录中按照从左到右的顺序查找程序</strong>。对于路径中的JDK，一次应该只有一个 bin 目录(第一个目录后面的目录将被忽略)，因此如果已经存在一个 bin 目录，则可以更新该特定条目。</p><p>下面是 PATH 环境变量的一个示例:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Java</span>\<span class="hljs-variable">jdk1</span><span class="hljs-number">.8</span><span class="hljs-number">.0</span><span class="hljs-type">_</span><span class="hljs-number">111</span>\<span class="hljs-variable">bin</span><span class="hljs-operator">;</span><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-variable">System32</span>\<span class="hljs-operator">;</span><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-operator">;</span><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-variable">System32</span>\<span class="hljs-variable">Wbem</span><br></code></pre></td></tr></table></figure><p>如果不设置 PATH变量，则需要在每次运行可执行文件时指定它的完整路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_111</span>\bin\javac MyClass.java<br></code></pre></td></tr></table></figure><p>如果想方便地从任何目录运行可执行文件(javac.exe，java.exe，javadoc.exe，等等)，可以设置 PATH 环境变量，而不必键入命令的完整路径。</p><p>将<code>%JAVA_HOME%/bin/</code>，添加到环境变量PATH中。再执行java命令时(无论在哪个目录下执行)，系统就会从左到右搜索(<strong><em>这里的顺序很重要，可以利用这个特性覆盖掉某个旧版本的jdk</em></strong>)，环境变量PATH中执行的目录，直到找到对应的可执行文件并执行(找到之后，后面的目录都会被忽略掉)。如果找不到，提示该命令不存在。因此配置了PATH变量后，可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac MyClass.java<br></code></pre></td></tr></table></figure><p>而不必键入命令的完整路径。</p><h1 id="classpath">2.classpath</h1><p>和PATH变量不同，CLASSPATH环境变量的作用是指定Java类所在的目录，告诉应用程序(包括JDK 工具)在哪里查找用户类的一种方法。简单的来说：<strong>Classpath是一个环境变量，应用程序 ClassLoader 或系统使用它来定位和加载存储在.class 文件中的已编译 Java 字节码。</strong></p><h1 id="总结">3.总结</h1><p>PATH 和 CLASSPATH 之间的主要区别在于 PATH 是一个环境变量，用于定位JDK 二进制文件，例如用于运行 java 程序和编译 java源文件的“java”或“javac”命令。</p><p>对于CLASSPATH ，系统或应用程序类加载器使用环境变量 CLASSPATH来定位和加载存储在 .class 文件中的编译 Java 字节码。<ahref="http://javarevisited.blogspot.sg/2011/06/noclassdeffounderror-exception-in.html">java.lang.NoClassDefFoundError</a>和<ahref="http://javarevisited.blogspot.sg/2011/08/classnotfoundexception-in-java-example.html">java.lang.ClassNotFoundException</a>等错误的最常见原因是Java 中的 CLASSPATH 不正确或配置错误。</p><p>其实在上面我们使用的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac MyClass.java<br></code></pre></td></tr></table></figure><p>实际上是在运行 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Classpath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java<br></code></pre></td></tr></table></figure><p>javac就是对上述命令的封装。</p><p>在JDK1.5以后，classpath并不是必须配置了，在JDK1.5之前，是没有办法在当前目录下加载类的（找不到JDK目录下lib文件夹中的.jar文件），所以我们需要通过配置classpath，但JDK1.5之后，JRE能自动搜索目录下类文件，并且加载dt.jar和tool.jar的类。<strong>所以JDK1.5以后，我们只需要配置Java_Home以及path即可！</strong></p><h1 id="read-more">4.Read more</h1><p>:lollipop::https://stackoverflow.com/questions/33062443/what-is-the-difference-between-path-and-classpath-in-java</p><p>:lollipop::https://docs.oracle.com/javase/tutorial/essential/environment/paths.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx介绍，安装</title>
    <link href="/2022/11/12/operations/nginx/2022-11-12_Nginx/"/>
    <url>/2022/11/12/operations/nginx/2022-11-12_Nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="基本介绍">1.基本介绍</h2><ul><li><p><code>Nginx</code> 是一个高性能的 <code>HTTP</code> 和反向代理<code>web</code> 服务器，同时也提供了 <code>IMAP/POP3/SMTP</code>服务。</p></li><li><p><code>Nginx</code> 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的<code>Rambler.ru</code> 站点开发的，第一个公开版本 <code>0.1.0</code>发布于 <code>2004</code> 年 <code>10</code> 月 <code>4</code>日。</p></li><li><p><code>Nginx</code> 特点是占有内存少，并发能力强。</p></li></ul><p>事实上 <code>nginx</code>的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了<code>Nginx</code> ，我们的项目架构可能是这样：</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/15-1.png"alt="15-1" /><figcaption aria-hidden="true">15-1</figcaption></figure><p>在这样的架构中 ， <code>Nginx</code>所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达<code>Nginx</code> 上，再由 <code>Nginx</code>根据提前配置好的转发规则，将客户端发来的请求转发到某一个<code>Tomcat</code> 上去。</p><blockquote><p>Nginx 是一款轻量级的 HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO性能，时常用于服务端的<strong>反向代理</strong>和<strong>负载均衡</strong>。</p></blockquote><p>那么这里涉及到两个概念：负载均衡服务器、反向代理服务器。</p><h2 id="负载均衡服务器">2.负载均衡服务器</h2><p>负载均衡（LoadBalance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个<strong>中间服务器</strong>，再让这个中间服务器在服务器集群中通过负载均衡算法选择一个服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。</p><p>负载均衡策略很多，也有很多层，对于一些大型网站基本上从<code>DNS</code>就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 <code>F5</code>和 <code>Nginx</code> （目前 <code>Nginx</code> 已经被 <code>F5</code>收购），早些年，也可以使用 <code>Apache</code>来做负载均衡，但是效率不如 <code>Nginx</code> ，所以现在主流方案是<code>Nginx</code> 。</p><h3 id="load-balancing-methods">2.1 Load Balancing Methods</h3><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/nginx-server.png"alt="nginx-server" /><figcaption aria-hidden="true">nginx-server</figcaption></figure><p>开源Nginx 支持四种负载平衡方法，NginxPlus还增加了两种方法。所以在Nginx上设置负载平衡时，有五种主要方法。前四个在开源Nginx 和NginxPlus中都可用，而最后一个是Nginx Plus功能。</p><blockquote><p><strong>Nginx Plus 相当于付费版本的Nginx</strong>。提供了更多的功能，针对企业需要的一些服务进行了优化。</p><p>有关功能的比较页面，请参考： <ahref="https://www.nginx.com/products/nginx/compare-models">CompareModels - NGINX</a></p></blockquote><h4 id="round-robin-optionally-weighted">2.1.1 Round Robin, optionallyweighted</h4><p>默认的load balancing方法。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> myapp &#123;<br>    <span class="hljs-attribute">server</span> webserver1.example.com;<br>    <span class="hljs-attribute">server</span> webserver2.example.com;<br>    <span class="hljs-attribute">server</span> webserver3.example.com;<br>&#125;<br></code></pre></td></tr></table></figure><p>在请求过来时，按顺序分发请求，第一次来的server1上，第二次打到server2上，第三次打到server3上，第四次又回到server1上，1-2-3，1-2-3,... 的这样循环。</p><p>Round Robin也可以加权重，为每一个服务器指定权重。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> myapp &#123;<br>    <span class="hljs-attribute">server</span> webserver1.example.com weight = <span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">server</span> webserver2.example.com weight = <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">server</span> webserver3.example.com weight = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样配置后，请求会这样打：1-1-2-3，1-1-2-3, ...</p><blockquote><p>weight越大，负载的权重就越大，默认为1。</p></blockquote><h4 id="least-connected-optionally-weighted">2.1.2 Least Connected,optionally weighted</h4><p>这种方法是每次来的请求都会打到当前连接数最少的upstream里的webserver上，比如有3台server，server1，server2都有10个连接，3只有1个连接，如果在接下来的9个请求1和2的10个连接都没有断开，那么这9个请求都会被打到3上。</p><p>例如有三个负载均衡的服务器，第一个进入的请求非常非常短。它的处理速度非常快——也许只需要10毫秒。下一个请求需要很长时间来处理。第三个也很短。第四个，也很短。第五个，很长。不知何故，这种情况一次又一次地发生，服务器2不断受到这些巨大请求的冲击。它们会持续很长时间，而发送到其他服务器的请求非常短。在这种情况下，循环往复是行不通的，因为随着越来越多的连接进入。接近能够处理的最大连接数，服务器处理每个请求的时间会越来越长。</p><h4 id="ip-hash">2.1.3 IP Hash</h4><p>IPHash会将IP地址的前3个8位元相同的请求打到同一台机器上，来简单的保持回话。这种方法有个弊端是有些内网统一出口ip都会被打到同一台机器，不能有效的实现load-balancing。</p><h4 id="generic-hash">2.1.4 Generic Hash</h4><p>GenericHash可以自定义请求的分发，可以根据IP地址和查询变量或者URL或者其他参数，当这些参数都和上次一样时就会将请求打到上次的那台机器</p><h4 id="least-timenginx-plus-optionally-weighted">2.1.5 Least Time(NginxPlus), optionally weighted</h4><p>Least Time只能在Nginx Plus中用，和LeastConnected类似，会将请求打到连接数最少并且响应速度最快（响应时间最短）的机器上。同时，它也可以像Round Robin一样使用权重。</p><h4 id="如何选择该用哪种load-balancing方法">2.1.6如何选择该用哪种load-balancing方法</h4><ul><li><p><strong>RoundRobin</strong>适用于所有的server配置和位置（同一个机房）都一样，所有的请求都是短暂的请求。</p></li><li><p><strong>LeastConnected</strong>适用于所有的server配置和位置都一样，请求处理时间长度会变的会话。</p></li><li><p><strong>IPHash</strong>适用于需要简单的会话保持（根据客户IP地址的前3个八位元决定被用的服务器）。</p></li><li><p><strong>GenericHash</strong>适用于需要简单的会话保持（基于参数组合的哈希决定被用的服务器）。</p></li><li><p><strong>LeastTime</strong>适用于servers在不同的位置且拥有不同的配置，请求会话长度是可变的，可用于健康检查。</p></li></ul><h1 id="代理服务器">3.代理服务器</h1><p>Nginx作为一个反向代理服务器为我们服务，代理分为<strong>正向代理</strong>和<strong>反向代理</strong>。</p><h3 id="正向代理">3.1 正向代理</h3><p>正向代理，意思是一个位于客户端和原始服务器(originserver)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/image-20221124101743281.png" /></p><h3 id="反向代理">3.2 反向代理</h3><p>反向<strong>代理服务器位于用户与目标服务器</strong>之间，但是对于用户而言，反向<strong>代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/image-20221124102228743.png"alt="image-20221124102228743" /><figcaption aria-hidden="true">image-20221124102228743</figcaption></figure><h4 id="为什么使用反向代理">为什么使用反向代理</h4><ul><li>可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器。</li><li>通过缓存静态资源，加速Web请求。</li><li>实现负载均衡。顺便说下，目前市面上，主流的负载均衡方案，硬件设备有F5，软件方案有四层负载均衡的LVS，七层负载均衡的Nginx、Haproxy等。</li></ul><h1 id="mac安装nginx">4.Mac安装Nginx</h1><p>在安装前，需要以下应用程序作为支持。如果没有安装以下应用程序则需要安装。</p><ul><li><a href="https://github.com/Homebrew">home brew</a></li></ul><p>mac可以通过<code>brew</code>来方便的安装nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew search nginx --查看nginx版本信息<br>brew install nginx --下载nginx<br></code></pre></td></tr></table></figure><p>然后我们通过命令查看nginx安装信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew info nginx ----查看nginx安装信息<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs stata">wangwang@localhost ~ % brew info nginx<br>nginx: stable 1.21.4 (bottled), HEAD<br>HTTP(S) server and reverse proxy, and IMAP/POP3 proxy server<br>https:<span class="hljs-comment">//nginx.org/</span><br>/usr/<span class="hljs-keyword">local</span>/Cellar/nginx/1.21.4 (26 files, 2.2MB) *<br>  Poured from bottle <span class="hljs-keyword">on</span> 2022-01-26 at 11:12:52<br>From: https:<span class="hljs-comment">//github.com/Homebrew/homebrew-core/blob/HEAD/Formula/nginx.rb</span><br>License: BSD-2-Clause<br>==&gt; Dependencies<br>Required: openssl@1.1 ✔, pcre ✔<br>==&gt; Options<br>--HEAD<br>Install HEAD <span class="hljs-keyword">version</span><br>==&gt; Caveats<br>Docroot is: /usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">var</span>/www<br><br>The default port has been <span class="hljs-keyword">set</span> <span class="hljs-keyword">in</span> /usr/<span class="hljs-keyword">local</span>/etc/nginx/nginx.<span class="hljs-keyword">conf</span> to 8080 <span class="hljs-keyword">so</span> that<br>nginx can <span class="hljs-keyword">run</span> without sudo.<br><br>nginx will load all files <span class="hljs-keyword">in</span> /usr/<span class="hljs-keyword">local</span>/etc/nginx/servers/.<br><br>To restart nginx after <span class="hljs-keyword">an</span> upgrade:<br>  brew services restart nginx<br>Or, <span class="hljs-keyword">if</span> you don&#x27;t want/need a background service you can just <span class="hljs-keyword">run</span>:<br>  /usr/<span class="hljs-keyword">local</span>/opt/nginx/bin/nginx -<span class="hljs-keyword">g</span> daemon off;<br>==&gt; Analytics<br>install: 45,814 (30 days), 114,920 (90 days), 455,820 (365 days)<br>install-<span class="hljs-keyword">on</span>-request: 45,784 (30 days), 114,766 (90 days), 455,039 (365 days)<br>build-<span class="hljs-keyword">error</span>: 1 (30 days)<br></code></pre></td></tr></table></figure><p>我们可以看到默认的配置文件<code>nginx.conf</code>位置信息。通过open命令来打开文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">open /usr/local/etc/nginx --nginx.conf文件目录<br></code></pre></td></tr></table></figure><p>成功打开nginx目录，也可以看到nginx.conf的配置文件（后面会用到这个配置文件）。但我们并没有找到nginx被安装到了哪里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">open  /usr/local/Cellar/nginx  --nginx安装目录<br></code></pre></td></tr></table></figure><p>浏览器输入<code>localhost:8080</code>，我们就能看到如下页面，即Nginx安装成功。</p><figure><img src="/Users/wangwang/Desktop/pic/image-20221125095746582.png"alt="image-20221125095746582" /><figcaption aria-hidden="true">image-20221125095746582</figcaption></figure><h1 id="nginx相关命令">5.Nginx相关命令</h1><ul><li>启动命令： nginx</li><li>快速停止命令 nginx -s stop</li><li>平稳退出命令：nginx -s quit</li><li>重新加载配置文件命令：nginx -s reload</li><li>检查配置文件正确性：nginx -t</li><li>查询nginx主进程号：ps -ef | grep nginx</li></ul><h1 id="nginx小试牛刀">6.Nginx小试牛刀</h1><p>通过前面的简介，我们已经对Nginx有了一个初步的认知。现在我们通过Nginx反向代理来访问我们的服务。</p><p>我们新建一个springboot工程，然后引入web依赖，在controller中写一个入口，来测试Nginx代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/getHello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将端口号改为8089：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span> = <span class="hljs-string">8089</span><br></code></pre></td></tr></table></figure><p>Nginx的配置都是在<code>nginx.conf</code>里，我们通过配置该文件来配置我们的代理。找到localtion位置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>          <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8089;<br>       &#125;<br></code></pre></td></tr></table></figure><p>只需要上面的代码，即可。然后启动Nginx。输入<code>http://localhost:8080/hello/getHello</code>，即可看到如下页面。浏览器不直接访问前台的8089(当然，访问nginx前提是你项目能正常访问)，而是访问nignx的8080，效果如下:</p><figure><img src="/Users/wangwang/Desktop/pic/image-20221125111159370.png"alt="image-20221125111159370" /><figcaption aria-hidden="true">image-20221125111159370</figcaption></figure><p>项目配置的是8089，但是通过访问Nginx的8080端口，Nginx通过配置的路由拦截，通过我们配置的参数代理到8089端口，也就是访问了8089端口并返回了数据，用户在整个过程中是无感知的。这也说明了Nginx是通过反向代理来帮助我们去访问资源。</p><blockquote><p>Nginx 只是一个代理，自身并不提供服务。</p></blockquote><h1 id="nginx启动问题记录">7.Nginx启动问题记录</h1><p>在运行Nginx的时候，遇到一个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx启动或者重启失败，报错nginx: [error] open() <span class="hljs-string">&quot;/usr/local/etc/nginx/nginx.pid&quot;</span> failed (2: No such file or directory)<br></code></pre></td></tr></table></figure><p>解决办法：</p><ol type="1"><li>通过<code>open /usr/local/etc/nginx</code>打开<code>nginx.conf</code>的位置</li><li>新建一个<code>logs</code>文件夹</li><li>配置<code>nginx.conf</code>，更改pid，如下：</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><span class="hljs-attribute">pid</span> /usr/local/etc/nginx/logs/nginx.pid;<br></code></pre></td></tr></table></figure><p>启动Nginx的时候，logs文件夹下会生成nginx.pid。</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/2022/11/01/java_se/jvm/2022-11-01_JMM/"/>
    <url>/2022/11/01/java_se/jvm/2022-11-01_JMM/</url>
    
    <content type="html"><![CDATA[<h1 id="java内存模型">1.Java内存模型</h1><p>Java虚拟机规范中定义了Java内存模型（Java MemoryModel，JMM），<strong>用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。</strong></p><blockquote><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p></blockquote><p>Java 内存模型规定了 JVM 应该如何使用计算机内存（RAM）。 广义来讲，Java 内存模型分为两个部分：</p><ul><li>JVM 内存结构</li><li>JMM 与线程规范</li></ul><p>其中，JVM 内存结构是底层实现，也是我们理解和认识 JMM 的基础。大家熟知的堆内存、栈内存等运行时数据区的划分就可以归为 JVM内存结构。</p><h1 id="jvm-内存结构">2.JVM 内存结构</h1><p>在前面我们知道了Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230513123037435.png" /></p><p>JVM 内部使用的 Java 内存模型， 在逻辑上将内存划分为 线程栈（threadstacks）和堆内存（heap）两个部分,也就是我们说的<strong>虚拟机栈和堆</strong>。如下图所示：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/4pajs.jpg" /></p><p>JVM 中，每个正在运行的线程，都有自己的线程栈。线程栈包含了当前正在执行的方法链/调用链上的所有方法的状态信息。所以线程栈又被称为“<code>方法栈</code>”或“<code>调用栈</code>”（callstack）。线程在执行代码时，调用栈中的信息会一直在变化。</p><h2 id="线程栈">2.1 线程栈</h2><p>线程栈里面保存了调用链上正在执行的所有方法中的局部变量。</p><ul><li>每个线程都只能访问自己的线程栈。</li><li>每个线程都不能访问(看不见)其他线程的局部变量。</li></ul><blockquote><p>即使两个线程正在执行完全相同的代码，但每个线程都会在自己的线程栈内创建对应代码中声明的局部变量。所以每个线程都有一份自己的局部变量副本。</p></blockquote><p>在线程栈中：</p><ul><li>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。</li><li><strong>线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。</strong></li><li>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型（例如<code>Byte</code>，<code>Integer</code>，<code>Long</code>等）。</li><li><strong>不管是创建一个对象并将其赋值给局部变量，还是赋值给另一个对象的成员变量，创建的对象都会被保存到堆内存中</strong>。</li></ul><p>下图演示了线程栈上的调用栈和局部变量，以及存储在堆内存中的对象：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/ksq1n.jpg" /></p><p>我们可以注意到以下特点：</p><ul><li><p>如果是局部变量，则保留在线程栈上。</p></li><li><p>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。</p></li><li><p>对象的成员变量与对象本身一起存储在堆上,不管成员变量的类型是原生数值，还是对象引用。</p></li><li><p>类的静态变量则和类定义一样都保存在堆中</p></li></ul><blockquote><p><strong>原始数据类型和对象引用地址在栈上；对象、对象成员与类定义、静态变量在堆上</strong>。</p></blockquote><h2 id="堆内存">2.2 堆内存</h2><p>堆内存又称为“<code>共享堆</code>”，堆中的所有对象，可以被所有线程访问,只要他们能拿到对象的引用地址。</p><p>在堆内存中：</p><ul><li>如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。</li><li>如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。</li></ul><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/6j9fe.jpg" /></p><blockquote><p>虽然各个线程自己使用的局部变量都在自己的栈上，但是大家可以共享堆上的对象，特别地各个不同线程访问同一个对象实例的基础类型的成员变量，会给每个线程一个变量的副本。</p></blockquote><h2 id="栈内存的结构">2.3 栈内存的结构</h2><p>我们在前面讲过：<strong>Java虚拟机栈（Java Virtual MachineStack）是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（<code>Stack Frame</code>）用于存储<code>局部变量表、操作数栈、动态连接、方法出口</code>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。如下图：</strong></p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/jvm-stack.jpg" /></p><p>下图能更好的让我们理解<strong>栈内存</strong>(Stack)的大体结构：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/6yhj7.jpg" /></p><blockquote><p>每启动一个线程，JVM 就会在栈空间栈分配对应的<strong>线程栈</strong>,比如 1MB 的空间（<code>-Xss1m</code>）。</p><p>线程栈也叫做 Java 方法栈。 如果使用了 JNI方法，则会分配一个单独的本地方法栈(Native Stack)。</p><p>线程执行过程中，一般会有多个方法组成调用栈(Stack Trace), 比如 A 调用B，B 调用C……每执行到一个方法，就会创建对应的<strong>栈帧</strong>(Frame)。栈的内存不是无限大的。如果创建的栈帧太多，超过了设置的栈的最大内存，则会抛出栈内存溢出异常，这也是为什么我们写代码不要嵌套调用过多的方法的原因</p></blockquote><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/ze6dq.jpg" /></p><h2 id="堆内存的结构">2.4 堆内存的结构</h2><p>Java 程序除了栈内存之外，最主要的内存区域就是堆内存了。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/u0xac.jpg" /></p><p>堆内存是所有线程共用的内存空间，理论上大家都可以访问里面的内容。</p><p>但 JVM 的具体实现一般会有各种优化。比如将逻辑上的 Java堆,划分为<code>堆(Heap)</code>和<code>非堆(Non-Heap)</code>两个部分.。这种划分的依据在于，我们编写的Java 代码，基本上只能使用 Heap这部分空间，发生内存分配和回收的主要区域也在这部分，所以有一种说法，这里的Heap 也叫 GC 管理的堆(GC Heap)。</p><p>GC 理论中有一个重要的思想，叫做分代。经过研究发现，程序中分配的对象，要么用过就扔，要么就能存活很久很久。</p><p>因此，JVM 将 Heap 内存分为年轻代（Young generation）和老年代（Oldgeneration, 也叫 Tenured）两部分。</p><p>年轻代还划分为 3 个内存池，新生代(Eden space)和存活区(Survivorspace), 在大部分 GC 算法中有 2 个存活区(S0,S1)，在我们可以观察到的任何时刻，S0 和 S1 总有一个是空的,但一般较小，也不浪费多少空间。</p><p>具体实现对新生代还有优化，那就是 TLAB(Thread Local AllocationBuffer),给每个线程先划定一小片空间，你创建的对象先在这里分配，满了再换。这能极大降低并发资源锁定的开销。</p><p>我们也注意到，还有方法区没有涉及。这就是上文的Non-Heap，Non-Heap本质上还是 Heap，只是一般不归 GC 管理，里面划分为 3 个内存池。</p><ul><li>Metaspace, 以前叫持久代(永久代, Permanent generation), Java8换了个名字叫 Metaspace. Java8 将方法区移动到了 Meta区里面，而方法又是class的一部分和 CCS 交叉了?</li><li>CCS, Compressed Class Space, 存放 class 信息的，和 Metaspace有交叉。</li><li>Code Cache, 存放 JIT 编译器编译后的本地机器代码。</li></ul><p>JVM 的内存结构大致如此。 掌握了这些基础知识，我们再来看看JMM。首先我们得了解一下以下知识：</p><h1 id="主内存与工作内存">3. 主内存与工作内存</h1><p>Java内存模型规定了所有的变量都存储在主内存（MainMemory）中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据[3]。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<code>线程</code>、<code>主内存</code>、<code>工作内存</code>三者的交互关系如下图：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230523231706463.png" /></p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2个步骤：</p><ul><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ul><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230523231753673.png" /></p><p>如上图所示，本地内存存 A 和 B 有主内存中共享变量 x的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x值也变为了 1。</p><p>从整体来看，这两个步骤实质上是线程 A 在向线程 B发送消息，而且这个通信过程必须要经过主内存。</p><blockquote><p>JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java程序员提供内存可见性保证</p></blockquote><h2 id="内存间交互操作">3.1 内存间交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。</p><ul><li><p><strong>lock（锁定）</strong>：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p></li><li><p><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p></li><li><p><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p></li><li><p><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p><strong>use（使用）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p></li><li><p><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p></li><li><p><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</p></li><li><p><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p></li></ul><blockquote><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。</p><p>注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是reada、read b、load b、load a。</p></blockquote><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h1 id="重排序">4.重排序</h1><p>为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>编译器优化重排</strong>。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 /写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230523232918240.png" /></p><p>上述的 1 属于<strong><em>编译器重排序</em></strong>，2 和 3属于<strong><em>处理器重排序</em></strong>。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。</p><p><strong>对于处理器重排序，JMM 的处理器重排序规则会要求 java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为 memoryfence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）</strong>。</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p>-- <strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM常见启动参数</title>
    <link href="/2022/10/29/java_se/jvm/2022-10-29_JVM%E5%B8%B8%E8%A7%81%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/"/>
    <url>/2022/10/29/java_se/jvm/2022-10-29_JVM%E5%B8%B8%E8%A7%81%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm参数分类"><strong>1.jvm参数分类</strong></h1><p>根据jvm参数开头可以区分参数类型，共三类：</p><h2 id="标准参数-"><strong>1.1 标准参数（-）</strong></h2><p>所有的JVM实现都必须实现这些参数的功能，而且向后兼容；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">例子：-verbose:class，-verbose:gc，-verbose:jni……           <br></code></pre></td></tr></table></figure><h2 id="非标准参数-x"><strong>1.2 非标准参数（-X）</strong></h2><p>默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">例子：-Xms20m，-Xmx20m，-Xmn20m，-Xss128k……    <br></code></pre></td></tr></table></figure><h2 id="非stable稳定参数-xx"><strong>1.3非Stable(稳定)参数（-XX）</strong></h2><p>此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">例子:-XX:+PrintGCDetails，-XX:-UseParallelGC，-XX:+PrintGCTimeStamps……    <br></code></pre></td></tr></table></figure><h2 id="参数形式"><strong>1.4 参数形式</strong></h2><ul><li><p>布尔类型：+ 或者 -</p></li><li><p>键值类型：name = value</p></li></ul><h1 id="jvm常见配置参数"><strong>2.jvm常见配置参数</strong></h1><h2 id="设置系统属性"><strong>2.1 设置系统属性</strong></h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Dkey</span>=<span class="hljs-string">value:系统属性，有时候也叫环境变量，例如直接给 JVM 传递指定的系统属性参数，需要使用这种形式</span><br><span class="hljs-attr">此时如果系统的环境变量里不管有没有指定这个参数，都会以这里的为准。</span><br><span class="hljs-attr"> </span><br><span class="hljs-attr">命令行参数，直接通过命令后面添加的参数，比如运行</span> <span class="hljs-string">Hello 类，同时传递 2 个参数 kimm、king：</span><br><span class="hljs-attr">java</span> <span class="hljs-string">Hello kimm king</span><br><span class="hljs-attr">，然后在Hello类的</span> <span class="hljs-string">main 方法的参数里可以拿到一个字符串的参数数组，有两个字符串，kimm 和 king。</span><br><br><span class="hljs-attr">-Dkey</span>=<span class="hljs-string">value：如果系统的环境变量里不管有没有指定这个参数，都会以这里的为准</span><br><span class="hljs-attr">-Duser.timezone</span>=<span class="hljs-string">GMT+08  // 设置用户的时区为东八区</span><br><span class="hljs-attr">-Dfile.encoding</span>=<span class="hljs-string">UTF-8      // 设置默认的文件编码为UTF-8</span><br></code></pre></td></tr></table></figure><h2 id="设置堆内存"><strong>2.2 设置堆内存</strong></h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Xmx等价于</span> <span class="hljs-string">-XX:MaxHeapSize, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为 4g。这个内存不包括栈内存，也不包括堆外使用的内存。</span><br><span class="hljs-attr">-Xms等价于</span> <span class="hljs-string">-XX:initialHeapSize, 指定堆内存空间的初始大小。 如 -Xms4g。 默认K为单位，而且指定的内存大小，并不是操作系统实际分配的初始值，而是 GC 先规划好，用到才分配。 专用服务器上需要保持 -Xms和-Xmx一致，否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时，堆内存扩容可能会导致性能抖动。</span><br><span class="hljs-attr">-Xmn,</span> <span class="hljs-string">等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，官方推荐配置为整个堆的3/8。（注意：从Java 8开始，HotSpot虚拟机中删除了“持久代”）</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限大，此参数无效。</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选项。</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟-Dsun.nio.MaxDirectMemorySize效果相同。</span><br><span class="hljs-attr">-Xss等价于-XX</span>:<span class="hljs-string">ThreadStackSize, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB</span><br><br><span class="hljs-attr">例如：</span><br><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">&quot;-Xms1g -Xmx1g&quot;</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="gc日志相关参数"><strong>2.3 GC日志相关参数</strong></h2><p>在生产环境或性能压测环境里，我们用来分析和判断问题的重要数据来源之一就是GC 日志，JVM 启动参数为我们提供了一些用于控制 GC 日志输出的选项。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-verbose</span>:<span class="hljs-string">gc ：和其他 GC 参数组合使用, 在 GC 日志中输出详细的GC信息。 包括每次 GC 前后各个内存池的大小，堆内存的大小，</span><br><span class="hljs-attr">提升到老年代的大小，以及消耗的时间。此参数支持在运行过程中动态开关。比如使用</span> <span class="hljs-string">jcmd, jinfo， 以及使用 JMX 技术的其他客户端。</span><br><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+PrintGCDetails 和 -XX:+PrintGCTimeStamps：打印 GC 细节与发生时间。</span><br><span class="hljs-attr">-Xloggc</span>:<span class="hljs-string">file：与-verbose:gc功能类似，只是将每次 GC 事件的相关情况记录到一个文件中，文件的位置最好在本地，以避免网络的潜在问题。若与 verbose:gc 命令同时出现在命令行中，则以 -Xloggc 为准。</span><br><br><span class="hljs-attr">示例</span>:<span class="hljs-string"></span><br><span class="hljs-attr">export</span> <span class="hljs-string">JAVA_OPTS=&quot;-Xms28g -Xmx28g -Xss1m \</span><br><span class="hljs-string">-verbosegc -XX:+UseG1GC -XX:MaxGCPauseMillis=200 \</span><br><span class="hljs-string">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/&quot;</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="指定垃圾回收器"><strong>2.4 指定垃圾回收器</strong></h2><p>垃圾回收器是 JVM 性能分析和调优的核心内容之一，也是近几个 JDK版本大力发展和改进的地方。通过不同的 GC算法和参数组合，配合其他调优手段，我们可以把系统精确校验到性能最佳状态。</p><p>以下参数指定具体的垃圾收集器：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-XX</span>:<span class="hljs-string">+UseG1GC：使用 G1 垃圾回收器</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+UseConcMarkSweepGC：使用 CMS 垃圾回收器</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+UseSerialGC：使用串行垃圾回收器</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+UseParallelGC：使用并行垃圾回收器</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="特殊情况执行脚本的参数"><strong>2.5特殊情况执行脚本的参数</strong></h2><p>除了上面介绍的一些 JVM参数，还有一些用于出现问题时提供诊断信息之类的参数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-XX</span>:<span class="hljs-string">+-HeapDumpOnOutOfMemoryError 选项, 当 OutOfMemoryError 产生，即内存溢出(堆内存或持久代)时，自动 Dump 堆内存。 </span><br><span class="hljs-attr">因为在运行时并没有什么开销,</span> <span class="hljs-string">所以在生产机器上是可以使用的。 示例用法: java -XX:+HeapDumpOnOutOfMemoryError -Xmx256m ConsumeHeap</span><br><span class="hljs-attr">java.lang.OutOfMemoryError</span>: <span class="hljs-string">Java heap space</span><br><span class="hljs-attr">Dumping</span> <span class="hljs-string">heap to java_pid2262.hprof ...</span><br><span class="hljs-attr">......</span><br><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">HeapDumpPath 选项, 与HeapDumpOnOutOfMemoryError搭配使用, 指定内存溢出时 Dump 文件的目录。 如果没有指定则默认为启动 Java 程序的工作目录。 示例用法: java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ConsumeHeap 自动 Dump 的 hprof 文件会存储到 /usr/local/ 目录下。</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">OnError 选项, 发生致命错误时(fatal error)执行的脚本。 例如, 写一个脚本来记录出错时间, 执行一些命令, 或者 curl 一下某个在线报警的url. 示例用法: java -XX:OnError=&quot;gdb - %p&quot; MyApp 可以发现有一个 %p 的格式化字符串，表示进程 PID。</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">OnOutOfMemoryError 选项, 抛出 OutOfMemoryError 错误时执行的脚本。</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">ErrorFile=filename 选项, 致命错误的日志文件名，绝对路径或者相对路径。</span><br></code></pre></td></tr></table></figure><p>​</p><p><strong>2.6 其他参数</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-XX</span>:<span class="hljs-string">-DisableExplicitGC — 让System.gc()不产生任何作用</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+PrintGCDetails — 打印GC的细节</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+PrintGCDateStamps — 打印GC操作的时间戳</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小</span><br>       <br><span class="hljs-attr">-XX</span>:<span class="hljs-string">NewRatio — 可以设置老生代和新生代的比例，新生代（Eden + 2S）和老年代（不含永久区）的比值，-XX:NewRatio=4表示新生代：老年代=1;4,即年轻代占堆的1/5</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">PermSize - 设置持久代初始值，默认是物理内存的六十四分之一</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">MaxPermSize - 设置持久代最大值，默认是物理内存的四分之一，一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少动态类的产生。</span><br>       <br><span class="hljs-attr">-XX</span>:<span class="hljs-string">SurvivorRatio:设置新生代中eden和S0/S1空间的比例.默认-XX:SurvivorRatio=8,Eden:S0:S1=8:1:1,Edec:2S=8:2,即一个s占1/10。假如-XX:SurvivorRatio=4,则Eden:S0:S1=4:1:1,即一个s占1/6</span><br>       <br><span class="hljs-attr">-XX</span>:<span class="hljs-string">PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值</span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">TargetSurvivorRatio：设置幸存区的目标使用率</span><br>       <br><span class="hljs-attr">-XX</span>:<span class="hljs-string">MaxTenuringThreshold - 新生代中对象存活次数，默认15。(若对象在eden区，经历一次MinorGC后还活着，则被移动到Survior区，年龄加1。以后，对象每次经历MinorGC，年龄都加1。达到阀值，则移入老年代) </span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+UseFastAccessorMethods - 原始类型快速优化 </span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">+AggressiveOpts - 编译速度加快 </span><br><span class="hljs-attr">-XX</span>:<span class="hljs-string">PretenureSizeThreshold - 对象超过多大值时直接在老年代中分配</span><br></code></pre></td></tr></table></figure><p>最全的官方JVM参数清单：https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</p><h1 id="调优典型设置"><strong>3.调优典型设置</strong></h1><h2 id="相关配置"><strong>3.1 相关配置</strong></h2><p>系统有大量的地方使用堆外内存，远比我们常说的 xmx 和 xms包括的范围要广。所以我们需要在设置内存的时候留有余地。</p><p>实际上，我个人比较推荐配置系统或容器里可用内存的 70-80%最好。比如说系统有 8G 物理内存，系统自己可能会用掉一点，大概还有 7.5G可以用，那么建议配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xmx3550m <br>-Xms3550m <br>-Xmn2g <br>-Xss128k<br></code></pre></td></tr></table></figure><ul><li><p><strong>-Xmx3550m</strong>：设置JVM最大可用内存为3550M。</p></li><li><p><strong>-Xms3550m</strong>：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p></li><li><p><strong>-Xmn2g</strong>：设置年轻代大小为2G。<strong>整个JVM内存大小=年轻代大小+ 年老代大小</strong>。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。（注意：从Java8开始，HotSpot虚拟机中删除了“持久代”）</p></li><li><p><strong>-Xss128k</strong>：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为<strong>1M</strong>，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xmx3550m <br>-Xms3550m <br>-Xss128k <br>-XX:NewRatio=4 <br>-XX:SurvivorRatio=4 <br>-XX:MaxPermSize=16m <br>-XX:MaxTenuringThreshold=0<br></code></pre></td></tr></table></figure><p><strong>-XX:NewRatio=4</strong>:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p><p><strong>-XX:SurvivorRatio=4</strong>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p><p><strong>-XX:MaxPermSize=16m</strong>:设置持久代大小为16m。</p><p><strong>-XX:MaxTenuringThreshold=0</strong>：设置垃圾最大年龄。<strong>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代</strong>。对于年老代比较多的应用，可以提高效率。<strong>如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间</strong>，增加在年轻代即被回收的概论。</p><p>但在绝大部分业务场景下，常用的 JVM 配置参数也就 10 来个。</p><p>给一个示例，读者可根据需要适当增减。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置堆内存</span><br>-Xmx4g -Xms4g <br><br><span class="hljs-comment"># 指定 GC 算法</span><br>-XX:+UseG1GC -XX:MaxGCPauseMillis=50 <br><br><span class="hljs-comment"># 指定 GC 并行线程数</span><br>-XX:ParallelGCThreads=4 <br><br><span class="hljs-comment"># 打印 GC 日志</span><br>-XX:+PrintGCDetails -XX:+PrintGCDateStamps <br><br><span class="hljs-comment"># 指定 GC 日志文件</span><br>-Xloggc:gc.log <br><br><span class="hljs-comment"># 指定 Meta 区的最大值</span><br>-XX:MaxMetaspaceSize=2g <br><br><span class="hljs-comment"># 设置单个线程栈的大小</span><br>-Xss1m <br><br><span class="hljs-comment"># 指定堆内存溢出时自动进行 Dump</span><br>-XX:+HeapDumpOnOutOfMemoryError <br>-XX:HeapDumpPath=/usr/local/<br></code></pre></td></tr></table></figure><p>此外，还有一些常用的属性配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定默认的连接超时时间</span><br>-Dsun.net.client.defaultConnectTimeout=2000<br>-Dsun.net.client.defaultReadTimeout=2000<br><br><span class="hljs-comment"># 指定时区</span><br>-Duser.timezone=GMT+08 <br><br><span class="hljs-comment"># 设置默认的文件编码为 UTF-8</span><br>-Dfile.encoding=UTF-8 <br><br><span class="hljs-comment"># 指定随机数熵源（Entropy Source）</span><br>-Djava.security.egd=file:/dev/./urandom <br></code></pre></td></tr></table></figure><p>​</p><h1 id="回收器选择"><strong>4.回收器选择</strong></h1><p>JVM给了三种选择：<strong>串行收集器、并行收集器、并发收集器</strong>，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p><ul><li><strong>吞吐量优先</strong>的并行收集器</li></ul><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p><h2 id="典型配置"><strong>4.1 典型配置</strong></h2><h3 id="配置一">4.1.1 配置一</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20<br></code></pre></td></tr></table></figure><ul><li><strong>-XX:+UseParallelGC</strong>：选择垃圾收集器为并行收集器。<strong>此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</strong></li><li><strong>-XX:ParallelGCThreads=20</strong>：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li></ul><h3 id="配置二">4.1.2 配置二</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC<br></code></pre></td></tr></table></figure><ul><li><strong>XX:+UseParallelOldGC</strong>：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集</li></ul><h3 id="配置三">4.1.3 配置三</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100<br></code></pre></td></tr></table></figure><ul><li><strong>-XX:MaxGCPauseMillis=100:</strong>设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</li></ul><h3 id="配置四">4.1.4 配置四</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy<br></code></pre></td></tr></table></figure><ul><li><strong>-XX:+UseAdaptiveSizePolicy</strong>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li></ul><h3 id="配置五">4.1.5 配置五</h3><ul><li><strong>响应时间优先</strong>的并发收集器</li></ul><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p><p><strong>典型配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br></code></pre></td></tr></table></figure><ul><li><strong>-XX:+UseConcMarkSweepGC</strong>：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</li><li><strong>-XX:+UseParNewGC</strong>:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li></ul><h3 id="配置六">4.1.6 配置六</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection<br></code></pre></td></tr></table></figure><ul><li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li><li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul><h2 id="辅助信息"><strong>4.2辅助信息</strong></h2><p>JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：</p><ul><li><p><strong>-XX:+PrintGC</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>       [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]<br></code></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>-XX:+PrintGCDetails</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>        [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]<br></code></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>-XX:+PrintGCTimeStamps</strong>-XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]       <br></code></pre></td></tr></table></figure></p></li></ul><p>​</p><ul><li><p><strong>-XX:+PrintGCApplicationConcurrentTime:</strong>打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用</p><pre><code class="hljs"> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输出形式：Application time: 0.5291524 seconds   <br></code></pre></td></tr></table></figure></code></pre></li></ul><p>​</p><ul><li><p><strong>-XX:+PrintGCApplicationStoppedTime</strong>：打印垃圾回收期间程序暂停的时间。可与上面混合使用</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输出形式：Total time <span class="hljs-keyword">for</span> <span class="hljs-built_in">which</span> application threads were stopped: 0.0468229 seconds <br></code></pre></td></tr></table></figure></p></li></ul><p>​</p><ul><li><p><strong>-XX:PrintHeapAtGC</strong>:打印GC前后的详细堆栈信息</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">输出形式：<br>34.702: [GC &#123;Heap before gc invocations=7:<br> def new generation   total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)<br>eden space 49152K,  99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)<br>from space 6144K,  55% used [0x221d0000, 0x22527e10, 0x227d0000)<br>  to   space 6144K,   0% used [0x21bd0000, 0x21bd0000, 0x221d0000)<br> tenured generation   total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)<br>the space 69632K,   3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)<br> compacting perm gen  total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)<br>   the space 8192K,  35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)<br>    ro space 8192K,  66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)<br>    rw space 12288K,  46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)<br>34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K(124928K)Heap after gc invocations=8:<br> def new generation   total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)<br>eden space 49152K,   0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)<br>  from space 6144K,  55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)<br>  to   space 6144K,   0% used [0x221d0000, 0x221d0000, 0x227d0000)<br> tenured generation   total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)<br>the space 69632K,   4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)<br> compacting perm gen  total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)<br>   the space 8192K,  35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)<br>    ro space 8192K,  66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)<br>    rw space 12288K,  46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)<br>&#125;<br>, 0.0757599 secs]<br></code></pre></td></tr></table></figure></p></li><li><p><strong>-Xloggc:filename</strong>:与上面几个配合使用，把相关日志信息记录到文件以便分析。</p></li></ul><h1 id="调优总结"><strong>5.调优总结</strong></h1><h2 id="年轻代大小选择">5.1 <strong>年轻代大小选择</strong></h2><ul><li><ul><li><strong>响应时间优先的应用</strong>：<strong>尽可能设大，直到接近系统的最低响应时间限制</strong>（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</li><li><strong>吞吐量优先的应用</strong>：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</li></ul></li></ul><h2 id="年老代大小选择">5.2 <strong>年老代大小选择</strong></h2><ul><li><ul><li><strong>响应时间优先的应用</strong>：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑<strong>并发会话率</strong>和<strong>会话持续时间</strong>等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</li></ul></li><li><ul><li><ul><li>并发垃圾收集信息</li><li>持久代并发收集次数</li><li>传统GC信息</li><li>花在年轻代和年老代回收上的时间比例</li></ul></li></ul></li></ul><p>减少年轻代和年老代花费的时间，一般会提高应用的效率</p><ul><li><ul><li><strong>吞吐量优先的应用</strong>：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</li></ul></li></ul><h2 id="较小堆引起的碎片问题">5.3<strong>较小堆引起的碎片问题</strong></h2><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p><ul><li><ul><li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：使用并发收集器时，开启对年老代的压缩。</li><li><strong>-XX:CMSFullGCsBeforeCompaction=0</strong>：上面配置开启的情况下，这里设置多少次FullGC后，对年老代进行压缩</li></ul></li></ul><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC算法</title>
    <link href="/2022/10/27/java_se/jvm/2022-10-27_GC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/10/27/java_se/jvm/2022-10-27_GC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾检测算法">1.垃圾检测算法</h1><p>若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收。</p><h2 id="引用计数法"><strong>1.1 引用计数法</strong></h2><p>在对象头维护着一个 counter 计数器，当对象增加一个引用时计数器加1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的Java虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题：</p><p><strong>两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。 正因为循环引用的存在，因此 Java虚拟机不使用引用计数算法。</strong></p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529221532074.png" /></p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529221539164.png" /></p><h2 id="可达性分析算法"><strong>1.2 可达性分析算法</strong></h2><p>以<strong>GCROOT</strong>对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529221633952.png" /></p><p>GC 遍历（traverses）内存中整体的对象关系图（object graph），从 GC根元素开始扫描，到直接引用，以及其他对象（通过对象的属性域）。所有 GC访问到的对象都被<strong>标记（marked）</strong> 为存活对象。</p><p>存活对象在上图中用蓝色表示。标记阶段完成后，所有存活对象都被标记了。而其他对象（上图中灰色的数据结构）就是从GC 根元素不可达的，也就是说程序不能再使用这些不可达的对象（unreachableobject）。这样的对象被认为是垃圾，GC 会在接下来的阶段中清除他们。</p><p>在标记阶段有几个需要注意的地方<strong>：在标记阶段，需要暂停所有应用线程，以遍历所有对象的引用关系。因为不暂停就没法跟踪一直在变化的引用关系图</strong>。这种情景叫做<strong>Stop The Worldpause</strong>（<strong>全线停顿</strong>），而可以安全地暂停线程的点叫做安全点（safepoint），然后，JVM就可以专心执行清理工作。安全点可能有多种因素触发，当前，GC是触发安全点最常见的原因。</p><p>此阶段暂停的时间，与堆内存大小，对象的总数没有直接关系，而是由<strong>存活对象</strong>（aliveobjects）的数量来决定。所以增加堆内存的大小并不会直接影响标记阶段占用的时间。</p><p><strong>可作为 GC Roots 的对象：</strong></p><ol type="1"><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ol><blockquote><p>GC Roots并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</p><p><strong>不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</strong></p></blockquote><h1 id="引用类型"><strong>2.引用类型</strong></h1><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java具有四种强度不同的引用类型。主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响。分为以下四种：</p><h2 id="强引用strong-reference">2.1 强引用（Strong Reference）</h2><p>类似 "<code>Object obj = new Object()</code>"这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们<strong>错误地保持了强引用</strong>，比如：赋值给了static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br></code></pre></td></tr></table></figure><h2 id="软引用soft-reference">2.2 软引用（Soft Reference）</h2><p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，<strong>只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象</strong>。JVM会确保在抛出 OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">使用 SoftReference 类来创建软引用：<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 使对象只被软引用关联</span><br></code></pre></td></tr></table></figure><h2 id="弱引用weak-reference">2.3 弱引用（Weak Reference）</h2><p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>只被弱引用关联的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">使用 WeakReference 类来实现弱引用：<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; wf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h2 id="虚引用phantom-reference">2.4 虚引用（Phantom Reference）</h2><p>虚引用也称幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem清理机制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get method of a phantom reference always returns null.<br>为了防止可回收对象的残留，虚引用对象不应该被获取：phantom reference 的 get 方法返回值永远是 null。<br></code></pre></td></tr></table></figure><p>很多开发者忽略了下一段内容（<strong>这才是重点</strong>）：</p><blockquote><p>Unlike soft and weak references，phantom references are notautomatically cleared by the garbage collector as they are enqueued. Anobject that is reachable via phantom references will remain so until allsuch references are cleared or themselves become unreachable.</p><p>与软引用和弱引用不同，虚引用不会被 GC自动清除，因为他们被存放到队列中。通过虚引用可达的对象会继续留在内存中，直到调用此引用的clear 方法，或者引用自身变为不可达。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>PhantomReference&lt;Object&gt; pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt;(obj);<br>obj = <span class="hljs-literal">null</span>;<br><br>使用虚引用时要小心谨慎，并及时清理虚可达对象。如果不清理，很可能会发生 OutOfMemoryError。<br></code></pre></td></tr></table></figure><h1 id="垃圾回收算法"><strong>3.垃圾回收算法</strong></h1><h2 id="标记-清除mark-and-sweep"><strong>3.1标记-清除（Mark-And-Sweep）</strong></h2><p>JVM 使用<strong>标记—清除算法</strong>（Mark and Sweepalgorithm），来跟踪所有的可达对象（即存活对象），确保所有不可达对象（non-reachableobjects）占用的内存都能被重用。如它的名字一样，算法分为“标记”和“清除”两个阶段：</p><ul><li><strong>Marking</strong>（标记）：遍历所有的可达对象，并在本地内存（native）中分门别类记下。</li><li><strong>Sweeping</strong>（清除）：这一步保证了，不可达对象所占用的内存，在之后进行内存分配时可以重用。</li></ul><p>JVM 中包含了多种 GC 算法，如 Parallel Scavenge（并行清除），ParallelMark+Copy（并行标记 + 复制）以及CMS，他们在实现上略有不同，但理论上都采用了以上两个步骤。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529224503590.png" /></p><p>标记清除算法最重要的优势，就是不再因为循环引用而导致内存泄露：</p><p><strong>标记—清除</strong>（Mark andSweep）是最经典的垃圾收集算法。将理论用于生产实践时，会有很多需要优化调整的地方，以适应具体环境。后面我们会通过一个简单的例子，看看如何才能保证JVM 能安全持续地分配对象。</p><p>而这种处理方式不好的地方在于：<strong>垃圾收集过程中，需要暂停应用程序的所有线程。假如不暂停，则对象间的引用关系会一直不停地发生变化，那样就没法进行统计了。</strong>这种情况叫做<strong>STW 停顿</strong>（<strong>Stop The Worldpause</strong>，全线暂停），让应用程序暂时停止，让 JVM进行内存清理工作。如果把 JVM里的环境看做一个世界，就好像我们经常在电影里看到的全世界时间静止了一样。有很多原因会触发STW 停顿，其中垃圾收集是最主要的原因。</p><p>它的主要缺点有两个：</p><ul><li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="复制copying">3.2 复制（Copying）</h2><p>复制算法也叫标记-复制算法。<strong>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题</strong>。它把内存空间划为两个相等的区域，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529224720951.png" /></p><p>现在的商业虚拟机都采用这种收集算法来回收<strong>新生代</strong>，但是并不是将新生代划分为大小相等的两块，而是<strong>分为一块较大的Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块Survivor。在回收时，将 Eden 和 Survivor中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden和使用过的那一块 Survivor。</strong></p><blockquote><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10%的对象存活，那么一块 Survivor空间就不够用了，此时需要依赖于老年代进行分配担保（HandlePromotion），也就是借用老年代的空间存储放不下的对象。</p></blockquote><h2 id="标记--整理mark-compact"><strong>3.3 标记-整理（Mark-Compact）</strong></h2><p>针对于标记—清除，我们会发现：每次执行清除（Sweeping），JVM都必须保证不可达对象占用的内存能被回收重用。这时候，就像是摆满棋子的围棋盘上，一部分位置上棋子被拿掉而产生了一些零散的空位置。但这（最终）有可能会产生内存碎片（类似于磁盘碎片），进而引发两个问题。</p><ul><li>写入操作越来越耗时，因为寻找一块足够大的空闲内存会变得困难（棋盘上没有一整片的空地方）；</li><li>在创建新对象时，JVM在连续的块中分配内存。如果碎片问题很严重，直至没有空闲片段能存放下新创建的对象，就会发生内存分配错误（allocationerror）。</li></ul><p>JVM必须确保碎片问题不失控。因此在垃圾收集过程中，不仅仅是标记和清除，还需要执行“内存碎片整理”过程。我们上面所说标记-复制算法已经解决了这个问题，但是它有局限性：</p><blockquote><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果</p><p>不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存</p><p>活的极端情况，所以在老年代一般不能直接选用这种算法。****</p></blockquote><p>针对于标记-复制算法，在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>针对老年代对象的存亡特征，后来又提出了<strong>标记-整理算法</strong>。其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内，这个过程让所有可达对象（reachableobjects）依次排列，以消除（或减少）碎片。就像是我们把棋盘上剩余的棋子都聚集到一起，留出来足够大的空余区域。这就是我们的<strong>标记-整理算法</strong>。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529224455599.png" /></p><blockquote><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p><p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“StopTheWorld”,所以修改对象引用是一个安全的行为。但要更新所有的引用，可能会影响应用程序的性能。</p></blockquote><h2 id="分代收集">3.4 分代收集</h2><p>分代收集是一种理论，前面提到过，执行垃圾收集需要停止整个应用。很明显，对象越多则收集所有垃圾消耗的时间就越长。但可不可以只处理一个较小的内存区域呢？为了探究这种可能性，研究人员发现，程序中的大多数可回收的内存可归为两类：</p><ul><li><p>大部分对象很快就不再使用，生命周期较短；</p></li><li><p>还有一部分不会立即无用，但也不会持续太长时间。</p></li></ul><p>根据对象存活周期的不同，把对象进行分类，将内存划分为几块。一般是把Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。</p><ul><li>新生代：复制算法</li><li>老年代：标记-清除算法、标记-整理算法</li></ul><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/ab551b20-322d-11ea-924d-0fd6db928ace.png" /></p><blockquote><p>天下没有免费的午餐，所以这种方法也不是没有任何问题。例如，在不同分代中的对象可能会互相引用，在收集某一个分代时就会成为“事实上的”GCroot。</p></blockquote><h1 id="内存池划分">4.内存池划分</h1><p>堆内存中的内存池划分也是类似的，不太容易理解的地方在于各个内存池中的垃圾收集是如何运行的。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/b3855bc0-322d-11ea-a161-cb02df1dc5e6.png" /></p><h2 id="新生代eden-space">4.1 <strong>新生代（Eden Space）</strong></h2><p>EdenSpace，也叫伊甸区，是内存中的一个区域，用来分配新创建的对象。通常会有多个线程同时创建多个对象，所以Eden 区被划分为多个 <strong>线程本地分配缓冲区</strong>（Thread LocalAllocation Buffer，简称 TLAB）。通过这种缓冲区划分，大部分对象直接由 JVM在对应线程的 TLAB 中分配，避免与其他线程的同步操作。</p><p>如果 TLAB 中没有足够的内存空间，就会在共享 Eden 区（shared Edenspace）之中分配。如果共享 Eden 区也没有足够的空间，就会触发一次 年轻代GC 来释放内存空间。如果 GC 之后 Eden区依然没有足够的空闲内存区域，则对象就会被分配到老年代空间（OldGeneration）。</p><p>当 Eden 区进行垃圾收集时，GC 将所有从 root可达的对象过一遍，并标记为存活对象。</p><p>我们曾指出，对象间可能会有跨代的引用，所以需要一种方法来标记从其他分代中指向Eden 的所有引用。这样做又会遭遇各个分代之间一遍又一遍的引用。JVM在实现时采用了一些绝招：卡片标记（card-marking）。从本质上讲，JVM只需要记住 Eden区中“脏”对象的粗略位置，可能有老年代的对象引用指向这部分区间。更多细节请参考：<ahref="https://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html">Nitsan的博客</a>。</p><p>标记阶段完成后，Eden 区中所有存活的对象都会被复制到存活区（Survivorspaces）里面。整个 Eden区就可以被认为是空的，然后就能用来分配新对象。这种方法称为“<strong>标记—复制</strong>”（MarkandCopy）：存活的对象被标记，然后复制到一个存活区（注意，是复制，而不是移动）。</p><h2 id="存活区survivor-spaces">4.2 存活区（Survivor Spaces）</h2><p>Eden 区的旁边是两个<strong>存活区</strong>（Survivor Spaces），称为from 空间和 to空间。需要着重强调的的是，任意时刻总有一个存活区是空的（empty）。</p><p>空的那个存活区用于在下一次年轻代 GC时存放收集的对象。年轻代中所有的存活对象（包括 Eden区和非空的那个“from”存活区）都会被复制到 ”to“ 存活区。GC过程完成后，“to”区有对象，而“from”区里没有对象。两者的角色进行正好切换，from变成 to，to 变成 from。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230529225637835.png" /></p><p>存活的对象会在两个存活区之间复制多次，直到某些对象的存活时间达到一定的阀值。分代理论假设，存活超过一定时间的对象很可能会继续存活更长时间。</p><p>这类“年老”的对象因此被<strong>提升</strong>（promoted）到老年代。提升的时候，存活区的对象不再是复制到另一个存活区，而是迁移到老年代，并在老年代一直驻留，直到变为不可达对象。</p><p>为了确定一个对象是否“足够老”，可以被提升（Promotion）到老年代，GC模块跟踪记录每个存活区对象存活的次数。每次分代 GC完成后，存活对象的年龄就会增长。当年龄超过<strong>提升阈值</strong>（tenuringthreshold），就会被提升到老年代区域。</p><p>具体的提升阈值由 JVM 动态调整，但也可以用参数<code>-XX:+MaxTenuringThreshold</code> 来指定上限。如果设置<code>-XX:+MaxTenuringThreshold=0</code> ，则 GC时存活对象不在存活区之间复制，直接提升到老年代。现代 JVM中这个阈值默认设置为 <strong>15</strong> 个 GC 周期。这也是 HotSpot JVM中允许的最大值。</p><p>如果存活区空间不够存放年轻代中的存活对象，提升（Promotion）也可能更早地进行。</p><h2 id="老年代old-gen">4.3 <strong>老年代（Old Gen）</strong></h2><p>老年代的 GC实现要复杂得多。老年代内存空间通常会更大，里面的对象是垃圾的概率也更小。</p><p>老年代 GC发生的频率比年轻代小很多。同时，因为预期老年代中的对象大部分是存活的，所以不再使用标记和复制（MarkandCopy）算法。而是采用移动对象的方式来实现最小化内存碎片。老年代空间的清理算法通常是建立在不同的基础上的。原则上，会执行以下这些步骤：</p><ul><li>通过标志位（marked bit），标记所有通过 GC roots 可达的对象；</li><li>删除所有不可达对象；</li><li>整理老年代空间中的内容，方法是将所有的存活对象复制，从老年代空间开始的地方依次存放。</li></ul><p>通过上面的描述可知，老年代 GC必须明确地进行整理，以避免内存碎片过多。</p><h2 id="永久代perm-gen">4.4 <strong>永久代（Perm Gen）</strong></h2><p>在 Java 8 之前有一个特殊的空间，称为“永久代”（PermanentGeneration）。这是存储元数据（metadata）的地方，比如 class信息等。此外，这个区域中也保存有其他的数据和信息，包括内部化的字符串（internalizedstrings）等等。</p><p>实际上这给 Java开发者造成了很多麻烦，因为很难去计算这块区域到底需要占用多少内存空间。预测失败导致的结果就是产生<code>java.lang.OutOfMemoryError: Permgen space</code>这种形式的错误。除非 OutOfMemoryError确实是内存泄漏导致的，否则就只能增加 permgen的大小，例如下面的示例，就是设置 perm gen 最大空间为 256 MB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MaxPermSize=256m<br></code></pre></td></tr></table></figure><h2 id="元数据区metaspace">4.5<strong>元数据区（Metaspace）</strong></h2><p>既然估算元数据所需空间那么复杂，Java 8 直接删除了永久代（PermanentGeneration），改用 Metaspace。从此以后，Java中很多杂七杂八的东西都放置到普通的堆内存里。</p><p>当然，像类定义（class definitions）之类的信息会被加载到 Metaspace中。元数据区位于本地内存（native memory），不再影响到普通的 Java对象。默认情况下，Metaspace 的大小只受限于 Java进程可用的本地内存。这样程序就不再因为多加载了几个类/JAR 包就导致<code>java.lang.OutOfMemoryError: Permgen space.</code>。注意，这种不受限制的空间也不是没有代价的—— 如果 Metaspace失控，则可能会导致严重影响程序性能的内存交换（swapping），或者导致本地内存分配失败。</p><p>如果需要避免这种最坏情况，那么可以通过下面这样的方式来限制 Metaspace的大小，如 256 MB：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MaxMetaspaceSize=256m<br></code></pre></td></tr></table></figure><h1 id="问题">5.问题</h1><h2 id="为什么新生代使用标记-复制算法">5.1为什么新生代使用标记-复制算法？</h2><p>结合前面所讲的，我们可知：新生代将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，也就是我们新生代的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效。</p><h2 id="为什么老年代使用标记-整理算法">5.2为什么老年代使用标记-整理算法？</h2><p>我们知道，在老年代中，对象大多都是存货的对象，针对于这种老年代对象的存亡特征，就不能直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，而且老年代也不需要复制算法，老年代的对象大多数都是存货的对象，像复制算法将大量存活的对象复制到另一个区域，效率与内存使用都比使用标记-整理算法差。</p><blockquote><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策.</p></blockquote><h2 id="标记-复制算法为什么不是标记-移动算法">5.3标记-复制算法为什么不是标记-移动算法?</h2><p>JVM 中的引用是一个抽象的概念，如果 GC移动某个对象，就会修改（栈和堆中）所有指向该对象的引用。移动/拷贝/提升/压缩一般来说是一个STW的过程，所以修改对象引用是一个安全的行为。但要更新所有的引用，可能会影响应用程序的性能。</p><p>如果移动存活对象，尤其是在新生代这种每次回收都有对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，因为如果不程暂停用户应用程序，则对象的引用关系一直在变，则对象间的引用关系会一直不停地发生变化，那样就没法进行统计了。</p><p>反之使用复制算法，最后再更新对象的引用关系。</p><h1 id="趣谈">6.趣谈</h1><p>这里有个比喻很形象：</p><p>假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden区有许多和你差不多的小兄弟、小姐妹，可以把 Eden区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为Survivor 区。开始的时候你在 Survivor区里面划分出来的的“From”区，读到高年级了，就进了 Survivor区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你 18岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华(慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收器</title>
    <link href="/2022/10/20/java_se/jvm/2022-10-20_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/2022/10/20/java_se/jvm/2022-10-20_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。各款经典收集器之间的关系如下图所示：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230530225915334.png" /></p><blockquote><p>虽然垃圾收集器的技术在不断进步，但直到现在还没有最好的收集器出现，更加不存在“万能”的收集器，所以我们选择的只是对具体应用最合适的收集器。如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，HotSpot虚拟机完全没必要实现那么多种不同的收集器了。</p></blockquote><h1 id="新生代收集器">1.新生代收集器</h1><h2 id="serial-垃圾收集器单线程">1.1 Serial 垃圾收集器（单线程）</h2><p>Serial垃圾收集器是<strong>1.3以前的</strong>采用<code>复制算法</code>的单线程新生代收集器。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230530230238225.png" /></p><h3 id="特性">1.1.1 <strong>特性</strong></h3><ul><li><p>它仅仅使用单线程进行垃圾回收；</p></li><li><p>它独占式的垃圾回收：它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。StopThe World.</p></li></ul><blockquote><p>“Stop TheWorld”这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。</p></blockquote><h3 id="应用场景">1.1.2 应用场景</h3><p>把Serial收集器是最早出现的收集器，但是不代表它是一个的“鸡肋”的垃圾收集器，事实上Serial/ˈsɪəriəl/收集器是仍然是虚拟机运行在Client模式下的默认新生代收集器。<strong>简单而高效（与其他收集器的单线程比）</strong>。</p><p>对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。对于服务器端来说，因为一般是多个CPU 内核，并不推荐使用，除非确实需要限制 JVM所使用的资源。大多数服务器端应用部署在多核平台上，选择 串行 GC就意味着人为地限制了系统资源的使用，会导致资源闲置，多余的 CPU资源也不能用增加业务处理的吞吐量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseSerialGC<br></code></pre></td></tr></table></figure><h2 id="parnew收集器serial多线程">1.2<strong>ParNew收集器(Serial+多线程)</strong></h2><p>ParNew收集器其实就是Serial+多线程版本。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230530230826176.png" /></p><h3 id="特性-1">1.2.1 <strong>特性</strong></h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，它也是采用<code>复制算法</code>的多线程新生代收集器，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、</p><p>-XX：HandlePromotionFailure等）、收集算法、Stop TheWorld、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p><h3 id="应用场景-1">1.2.2 <strong>应用场景</strong></h3><p>ParNew收集器是许多运行在<strong>Server模式下的虚拟机中首选的新生代收集器。</strong>很重要的原因是：<strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</strong>在JDK1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><blockquote><p>ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默认新生代收集器，也可以使用-XX：+/-UseParNewGC选项来强制指定或者禁用它。</p></blockquote><h3 id="parnew-vs-serial">1.2.3 ParNew VS Serial</h3><p>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多（譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍）的环境中，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>通过命令行参数 -XX:ParallelGCThreads=NNN 来指定 GC 线程数，其默认值为CPU 核心数。可以通过下面的任意一组命令行参数来指定并行 GC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseParallelGC <br>-XX:+UseParallelOldGC     <br></code></pre></td></tr></table></figure><h1 id="总结">2.总结</h1><p>可以说直到CMS的出现才巩固了ParNew的地位，但成也萧何败也萧何，随着垃圾收集器技术的不</p><p>断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不</p><p>再需要其他新生代收集器的配合工作。所以自JDK9开始，ParNew加CMS收集器的组合就不再是官方</p><p>推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代，甚至还取消了ParNew加</p><p>SerialOld以及Serial加CMS这两组收集器组合的支持（其实原本也很少人这样使用），并直接取消了-</p><p>XX：+UseParNewGC参数，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能</p><p>够和它们配合了。读者也可以理解为从此以后，ParNew合并入CMS，成为它专门处理新生代的组成部</p><p>分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM运行时数据区域</title>
    <link href="/2022/10/15/java_se/jvm/2022-10-10_JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <url>/2022/10/15/java_se/jvm/2022-10-10_JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区域">运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存。将会包括以下几个运行时数据区域：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230513123037435.png" /></p><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：在JDK 1．8中加入了元数据区的概念，将原来保存在方法区中的<code>运行时常量池</code>和<code>类常量池</code>都包括其中。元数据区取代了永久代。</p><p>元空间的本质和永久代类似，都是对 JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。如下图的JDK1.8所示：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/jvm-memory-structure.jpg" /></p><p>JDK 1.6、JDK 1.7、JDK 1.8 的内存划分都会有所不同，如下图：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/22141440207101.png" /></p><h1 id="程序计数器pc-寄存器">1.程序计数器（PC 寄存器）</h1><p>程序计数器（Program CounterRegister）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里[1]，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是<strong>正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）</strong>。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="程序计数器的定义">1.1 程序计数器的定义</h2><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p><h2 id="程序计数器的作用">1.2 程序计数器的作用</h2><ul><li>字节码解释器通过改变这个程序计数器的值来选取下一条需要执行的字节码指令，从而实现代码的流程控制。</li><li>在多线程情况下，程序计数器记录的是当前线程正在执行的虚拟机字节码指令的地址，从而当线程切换回来时能恢复到正确的执行位置。</li></ul><h1 id="java-虚拟机栈java-栈">2.Java 虚拟机栈（Java 栈）</h1><p>Java虚拟机栈（Java Virtual MachineStack）也是<strong>线程私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（<code>Stack Frame</code>）用于存储<code>局部变量表、操作数栈、动态连接、方法出口</code>等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/jvm-stack.jpg" /></p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="压栈出栈过程">1.1 压栈出栈过程</h3><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p><p>Java虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p><p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p><h3 id="局部变量表">1.2 局部变量表</h3><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，</p><p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，</p><blockquote><p>在Java程序编译为Class文件时,就在方法的Code属性中的<code>max_locals</code>数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)</p></blockquote><p>当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，</p><blockquote><p>虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p></blockquote><p>对于 slot 的理解：</p><ul><li>JVM 虚拟机会为局部变量表中的每个 slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在 index 为 0 的 slot 处，其余的参数表顺序继续排列。</li><li>栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</li></ul><p>在栈帧中，与性能调优关系最密切的部分，就是局部变量表，方法执行时，虚拟机使用局部变量表完成方法的传递局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="操作数栈">1.3 操作数栈</h3><p><strong>操作数栈(OperandStack)</strong>也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的<code>max_stacks</code>数据项中。</p><p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过<code>max_stacks</code>中设置的最大值。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程</p><ul><li><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的（这个时候数组是有长度的，只是操作数栈为空）</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li></ul><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h3 id="动态链接">1.4 动态链接</h3><ul><li>静态链接：当一个字节码文件被装载进 JVM内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。</li><li>动态链接：<strong>如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接</strong></li></ul><blockquote><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</p><p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p></blockquote><h3 id="方法返回地址">1.5 方法返回地址</h3><p>当一个方法开始执行后，只有<strong>两种方式可以退出这个方法</strong>:</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令:传递给上层的方法调用者，是否有返回值和返回值类型将根据遇到何种方法来返回指令决定，这种退出的方法称为正常完成出口。</li><li>方法执行过程中遇到异常：无论是java虚拟机内部产生的异常还是代码中thtrow出的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出的方式称为异常完成出口，一个方法若使用该方式退出，是不会给上层调用者任何返回值的。无论使用那种方式退出方法，都要返回到方法被调用的位置，程序才能继续执行。方法返回时可能会在栈帧中保存一些信息，用来恢复上层方法的执行状态。一般方法正常退出的时候，调用者的pc计数器的值可以作为返回地址，帧栈中很有可能会保存这个计数器的值作为返回地址。方法退出的过程就是栈帧在虚拟机栈上的出栈过程，因此退出时的操作可能有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者的操作数栈每条整pc计数器的值指向调用该方法的后一条指令。</li></ul><h1 id="本地方法栈c-栈">3.本地方法栈（C 栈）</h1><p>本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p><h3 id="栈帧变化过程">3.1 栈帧变化过程</h3><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出StackOverFlowError 和 OutOfMemoryError 异常。</p><blockquote><p>如果 Java 虚拟机本身不支持 Native方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p></blockquote><h1 id="java堆">4.Java堆</h1><p>Java堆（JavaHeap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“<strong>几乎</strong>”所有的对象实例都在这里分配内存。</p><blockquote><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”,Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p></blockquote><h1 id="read-more">5.Read more</h1><p><strong>逃逸分析：</strong>:lollipop::https://juejin.cn/post/6844903639308304397</p><p>:lollipop::https://zhuanlan.zhihu.com/p/69136675</p><p><strong>虚函数：</strong>:lollipop::https://zhuanlan.zhihu.com/p/483910917</p><p>:lollipop::https://www.jianshu.com/p/bc7ae8d29f26</p><p>:lollipop::https://juejin.cn/post/6844903983400632327</p><p>:lollipop::https://doocs.gitee.io/jvm/01-jvm-memory-structure.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HotSpot虚拟机对象</title>
    <link href="/2022/10/15/java_se/jvm/2022-10-15_HotSpot%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/10/15/java_se/jvm/2022-10-15_HotSpot%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="hotspot-虚拟机对象">HotSpot 虚拟机对象</h1><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p><h1 id="对象的内存布局">1.对象的内存布局</h1><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：</p><ul><li><p>对象头（Header）</p></li><li><p>实例数据（Instance Data）</p></li><li><p>对齐填充（Padding）</p></li></ul><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/20200327202511486.png" /></p><h1 id="jvm64位对象头内部组成">2.JVM（64位）对象头内部组成</h1><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/20220714100718.png" /></p><p>下图可以更清晰的看到对象头的内部组成：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230514230417171.png" /></p><p>2.偏向锁、轻量级锁和重量级锁在对象头中的标识：</p><ul><li><p>2bit的锁标志位表示锁的状态</p></li><li><p>1bit的偏向锁标志位表示是否偏向</p></li></ul><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230514230620592.png" /></p><p>1.无锁状态</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230514230622428.png" /></p><p>2.偏向锁状态</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230514230623956.png" /></p><h1 id="对象的创建过程">3.对象的创建过程</h1><h2 id="类加载检查">3.1 类加载检查</h2><p>虚拟机在解析<code>.class</code>文件时，若遇到一条 new指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p><h2 id="为新生对象分配内存">3.2 为新生对象分配内存</h2><p>对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：</p><ul><li><strong>指针碰撞</strong> 如果 Java<strong>堆中内存绝对规整</strong>（说明采用的是“<strong>复制算法</strong>”或“<strong>标记整理法</strong>”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</li><li><strong>空闲列表</strong> 如果 Java<strong>堆中内存并不规整</strong>，已使用的内存和空闲内存交错（说明采用的是<strong>标记-清除法</strong>，有碎片），此时没法简单进行指针碰撞，VM必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“<strong>空闲列表</strong>”。</li></ul><h2 id="初始化">3.3 初始化</h2><p>分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</p><h1 id="对象的访问方式">4.对象的访问方式</h1><p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p><h2 id="句柄访问方式">4.1 句柄访问方式</h2><p>堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/handle-access.jpg" /></p><h2 id="直接指针访问方式">4.2 直接指针访问方式</h2><p>引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/direct-pointer.jpg" /></p><p>需要说明的是，HotSpot采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要<strong>额外的策略</strong>来存储对象在方法区中类信息的地址。</p><h1 id="classlayoudemo">5.ClassLayouDemo</h1><h2 id="maven引入依赖">5.1 maven引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--classLayout:帮助打印对象的布局--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="classlayoudemo.class">5.2 ClassLayouDemo.class</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLayoutDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//构建了一个对象实例</span><br>        <span class="hljs-type">ClassLayoutDemo</span> <span class="hljs-variable">classLayoutDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLayoutDemo</span>();<br>        System.out.println(ClassLayout.parseInstance(classLayoutDemo).toPrintable());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="out">5.3 out</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.xxx.xxx.example.ClassLayoutDemo object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      //Mark Word<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      //Klass Pointer<br>      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)<br>     12     4        (loss due to the next object alignment)<br>Instance size: 16 bytes<br>Space losses: 0 bytes internal + 4 bytes external = 4 bytes total<br></code></pre></td></tr></table></figure><p>一共是16个字节，其中对象头是12个字节，还有4个对齐字节（因为64位虚拟机规定：对象的大小必须是8的倍数），由于这个对象里没有任何属性和方法，所以对象的实例数据为0个字节,如果添加一个boolean字段.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.xxx.xxx.example.ClassLayoutDemo object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      //Mark Word<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      //Klass Pointer<br>      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)<br>     12     1 boolean ClassLayoutDemo.happy<br>     13     3        (loss due to the next object alignment)<br>Instance size: 16 bytes<br>Space losses: 0 bytes internal + 4 bytes external = 4 bytes total<br></code></pre></td></tr></table></figure><p>从上面的输出来看，我们很容易发现，整个对象的大小没有改变，依然是16个字节，其中对象头12个字节，boolean字段happy占1个字节，剩下的3个Byte是对齐字节。由此我们可以发现一个对象的布局可以粗略的分为3个部分：对象头（ObjectHeader），对象的实例数据（Instance Data）和对齐字节（Padding）,也叫对齐填充。</p><h2 id="指针压缩">5.4 指针压缩</h2><p>JVM最初是32位的，随着64位系统的兴起，JVM也迎来了从32位到64位的转换，32位的JVM对比64位的内存容量比较有限。但是使用64位虚拟机的同时，带来一个问题，64位下的JVM中的对象指针占用内存会比32位的多1.5倍（<strong>这是因为对象指针在64位架构下，长度会翻倍（更宽的寻址），对于那些将要从32位平台移植到64位的应用来说，平白无辜多了1/2的内存占用</strong>），这是我们不希望看到的。于是在JDK1.6时，引入了指针压缩。</p><p>jvm参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseCompressedClassPointers     参数：**启用类指针(类元数据的指针)压缩。<br>-XX:+UseCompressedOops             参数：**启用普通对象指针压缩。Oops缩写于：ordinary object pointers<br></code></pre></td></tr></table></figure><p>在Jdk1.8中默认开启，可用命令进行检测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+PrintCommandLineFlags -version        <br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">wangwang@localhost ~ % java -XX:+PrintCommandLineFlags -version<br>-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC <br>java version <span class="hljs-string">&quot;1.8.0_261&quot;</span><br>Java(TM) SE Runtime Environment (build 1.8.0_261-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)<br>wangwang@localhost ~ % <br><br>参数中的+号代表开启参数，-号代表关闭参数。<br></code></pre></td></tr></table></figure><h3 id="测试">5.4.1 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLayoutDemo</span> &#123;<br><span class="hljs-comment">//    -XX:-UseCompressedClassPointers -XX:-UseCompressedOops -XX:+PrintCommandLineFlags</span><br>    <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//构建了一个对象实例</span><br>        <span class="hljs-type">ClassLayoutDemo</span> <span class="hljs-variable">classLayoutDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLayoutDemo</span>();<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>        System.out.println(ClassLayout.parseInstance(classLayoutDemo).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>开启指针压缩（默认）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.xxx.xxx.example.ClassLayoutDemo object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)<br>     12     2   char ClassLayoutDemo.ch                        c<br>     14     2        (loss due to the next object alignment)<br>Instance size: 16 bytes<br>Space losses: 0 bytes internal + 2 bytes external = 2 bytes total<br></code></pre></td></tr></table></figure><p>​</p><p><strong>未开启指针压缩</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.xxx.xxx.example.ClassLayoutDemo object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4        (object header)                           80 c0 35 10 (10000000 11000000 00110101 00010000) (271958144)<br>     12     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>     16     2   char ClassLayoutDemo.ch                        c<br>     18     6        (loss due to the next object alignment)<br>Instance size: 24 bytes<br>Space losses: 0 bytes internal + 6 bytes external = 6 bytes total<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定<strong>（如何确定将在2.3.2节中介绍）</strong>，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（BumpThePointer）。但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（FreeList）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</p><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（ThreadLocalAllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2022/10/14/java_se/jvm/2022-10-14_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/10/14/java_se/jvm/2022-10-14_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载">类加载</h1><h1 id="概述">1.概述</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p><p>按照 Java 语言规范和 Java 虚拟机规范的定义, 我们用“<code>类加载</code>(Class Loading)” 来表示: 将 class/interface名称映射为 Class 对象的一整个过程。这个过程还可以划分为更具体的阶段。</p><h1 id="类的生命周期">2.类的生命周期</h1><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/6zd6i.png" /></p><p>一个类在 JVM 里的生命周期有 7 个阶段，分别是</p><ul><li><p>加载（Loading）</p></li><li><p>验证（Verification）</p></li><li><p>准备（Preparation）</p></li><li><p>解析（Resolution）</p></li><li><p>初始化（Initialization）</p></li><li><p>使用（Using）</p></li><li><p>卸载（Unloading)。</p></li></ul><p>其中前五个部分（加载，验证，准备，解析，初始化）统称为<strong>类加载</strong>。</p><h1 id="类加载过程">3.类加载过程</h1><h2 id="加载">3.1 加载</h2><p>根据一个类的全限定名(如cn.edu.hdu.test.HelloWorld.class)来读取此类的二进制字节流到JVM内部。如果找不到二进制表示形式，则会抛出<code>NoClassDefFound</code> 错误。</p><p>加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成3 件事：</p><ul><li>通过类的全限定名获取该类的二进制字节流。</li><li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</li><li>在内存中创建一个代表该类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><h3 id="加载.class文件的方式">3.1.1 加载.class文件的方式</h3><ol type="1"><li>从 zip 包中读取，如 jar、war 等；</li><li>从网络中获取，如 Applet；</li><li>通过动态代理技术生成代理类的二进制字节流；</li><li>由 JSP 文件生成对应的 Class 类；</li><li>从数据库中读取，如有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li></ol><h2 id="验证">3.2 验证</h2><p>验证阶段确保 Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要包括四个检验过程。</p><h3 id="验证的过程">3.2.1 验证的过程</h3><ul><li><p>文件格式验证：验证字节流是否符合 Class文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：</p><ul><li>是否以魔数 0XCAFEBABE 开头。</li><li>主次版本号是否在当前虚拟机处理范围内。</li><li>常量池是否有不被支持的常量类型。</li><li>指向常量的索引值是否指向了不存在的常量。</li><li>CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>......</li></ul></li><li><p>元数据验证：对字节码描述信息进行语义分析，确保其符合 Java语法规范。</p><ul><li><p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</p></li><li><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</p></li><li><p>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</p></li><li><p>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方</p><p>法重载，例如方法参数都一致，但返回值类型却不同等）.</p></li><li><p>......</p></li></ul></li><li><p>字节码验证：本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</p></li><li><p>符号引用验证 本阶段发生在解析阶段，确保解析正常执行。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</li></ul></li></ul><blockquote><p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机</p><p>将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：</p><p>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等</p></blockquote><blockquote><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为</p><p>验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果</p><p>程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都</p><p>已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的</p><p>类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h2 id="准备">3.3 准备</h2><p>准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。</p><p>关于准备阶段，还有两个容易产生混淆的概念笔者需要着重强调，首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，</p><p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue属性，那么在准备阶段 value 就会被初始化为 ConstantValue属性所指定的值，假设上面类变量 value 的定义变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为123。</p><h2 id="解析">3.4 解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。前四种与我们最熟悉：类或接口的解析、字段解析、类方法解析、接口方法解析。</p><ul><li><p>符号引用（SymbolicReferences）</p><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《范》的Class文件格式中。</p></li><li><p>直接引用（DirectReferences）</p><p>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p></li></ul><blockquote><p>简单的来说就是我们编写的代码中，当一个变量引用某个对象的时候，这个引用在<code>.class</code>文件中是以符号引用来存储的（相当于做了一个索引记录）。</p><p>在解析阶段就需要将其解析并链接为直接引用（相当于指向实际对象）。如果有了直接引用，那引用的目标必定在堆中存在。</p><p>加载一个 class 时, 需要加载所有的 super 类和 super 接口。</p></blockquote><h2 id="初始化">3.5 初始化</h2><p>类初始化阶段是类加载过程的最后一步，是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。</p><p>静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。</p></blockquote><p>如下方代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 给变量赋值可以正常编译通过</span><br>        System.out.println(i);  <span class="hljs-comment">// 这句编译器会提示“非法向前引用”</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;clinit&gt;()</code>方法不需要显式调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code> 方法执行之前，父类的<code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p></li><li><p>由于父类的 <code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：字段B的值将会是2而不是1</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        A = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> A;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Sub.B); <span class="hljs-comment">// 输出 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code> 方法。</p><p>接口中不能使用静态代码块，但接口也需要通过<code>&lt;clinit&gt;()</code>方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的<code>&lt;clinit&gt;()</code> 方法不需要先执行父类的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code>方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code> 方法。</p><h1 id="类加载的时机">4.类加载的时机</h1><p>在上文，我们说过：</p><blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最</p><p>终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p></blockquote><p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/loadclass.png" alt="Load Class" style="zoom:80%;" /></p><p><code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>和<code>卸载</code>这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，</p><blockquote><p>这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p></blockquote><h2 id="主动引用">4.1 主动引用</h2><p>Java虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有5种情况必须立即对类进行“初始化”：《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ul><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类。</p></li><li><p>遇到new、getstatic、putstatic（调用静态方法）或invokestatic（访问静态指令）这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</p></li><li><p>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</p></li><li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。也就是子类的初始化会触发父类的初始化；</p></li><li><p>当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解</p></li></ul><p>析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句</p><p>柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p><ul><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有</li></ul><p>这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p><p>这6种场景中的行为称为对一个类进行<strong>主动引用</strong>，除此之外，其它所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。</p><h2 id="被动引用">4.2 被动引用</h2><ul><li>Demo1：通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>Demo2：定义对象数组，不会触发该类的初始化。</li><li>Demo3：常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让Hello 类初始化。</li><li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName(“jvm.Hello”)默认会加载Hello 类。</li><li>通过 ClassLoader 默认的 loadClass方法，也不会触发初始化动作（加载了，但是不初始化）。</li></ul><blockquote><p>诸如 Class.forName(), classLoader.loadClass() 等 Java API, 反射API,以及 JNI_FindClass 都可以启动类加载。 JVM 本身也会进行类加载。 比如在JVM 启动时加载核心类，java.lang.Object, java.lang.Thread 等等。</p></blockquote><h3 id="demo1"><ahref="https://doocs.gitee.io/jvm/08-load-class-time.html#demo2">#</a>Demo1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperClass init!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass init!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(SubClass.value);<br>        <span class="hljs-comment">// SuperClass init!</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClassinit！”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h3 id="demo2"><ahref="https://doocs.gitee.io/jvm/08-load-class-time.html#demo2">#</a>Demo2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 被动使用类字段演示二：</span><br><span class="hljs-comment">* 通过数组定义来引用类，不会触发此类的初始化</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SuperClass[] superClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperClass</span>[<span class="hljs-number">10</span>];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="demo3"><ahref="https://doocs.gitee.io/jvm/08-load-class-time.html#demo2">#</a>Demo3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被动引用 Demo3:</span><br><span class="hljs-comment"> * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ylb</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ConstClass init!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HELLO_BINGO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ConstClass.HELLO_BINGO);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码运行之后，也没有输出“ConstClassinit！”，这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“helloworld”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。</p><p>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成</p><p>Class文件后就已不存在任何联系了。</p><h2 id="接口的加载过程">4.3 接口的加载过程</h2><p>接口加载过程与类加载过程稍有不同。</p><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p><h1 id="类加载器">5.类加载器</h1><p>类加载过程可以描述为“通过一个类的全限定名 a.b.c.XXClass来获取描述此类的 Class对象”，这个过程由“类加载器（ClassLoader）”来完成。这样的好处在于，子类加载器可以复用父加载器加载的类。</p><p>一般<strong>启动类加载器</strong>是由 JVM 内部实现的，在 Java 的 API里无法拿到，但是我们可以侧面看到和影响它。后 2 种类加载器在 OracleHotspot JVM里，都是在中<code>sun.misc.Launcher</code>定义的，<strong>扩展类加载器和应用类加载器</strong>一般都继承自<code>URLClassLoader</code>类，这个类也默认实现了从各种不同来源加载class 字节码转换成 Class 的方法。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/esz0u-1684769425399-5.png" /></p><p>系统自带的类加载器分为三种：</p><ul><li>启动类加载器（BootstrapClassLoader）</li><li>扩展类加载器（ExtClassLoader）</li><li>应用类加载器（AppClassLoader）</li></ul><p>[<imgsrc="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/assets/csrk7.png" />]</p><ul><li><strong>启动类加载器: Bootstrap ClassLoader</strong></li></ul><p>负责加载 Jre/lib/目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。它用来加载 Java 的核心类，是用原生 C++代码来实现的，并不继承自java.lang.ClassLoader（负责加载JDK中jre/lib/rt.jar里所有的class）。它可以看做是JVM自带的，我们再代码层面无法直接获取到启动类加载器的引用，所以不允许直接操作它，启动类加载器是无法被Java程序直接引用的。</p><blockquote><p>java.lang.String 是由启动类加载器加载的，所以String.class.getClassLoader() 就会返回 null。</p></blockquote><ul><li><strong>扩展类加载器： Extension ClassLoader</strong></li></ul><p>负责加载Jre/lib/ext/目录(RE 的扩展目录)中的，或通过 -java.ext.dirs系统变量指定路径中的类库。</p><ul><li><strong>应用程序加载器: Application ClassLoader</strong></li></ul><p>负责加载用户路径（classpath）上的类库以及-Djava.class.path所指定目录下的类和jar包。在应用程序代码里可以通过ClassLoader 的静态方法 getSystemClassLoader()来获取应用类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><ul><li><strong>自定义加载器: 继承ClassLoader实现</strong></li></ul><p>如果用户自定义了类加载器，则自定义类加载器都以应用类加载器作为父加载器。应用类加载器的父类加载器为扩展类加载器。这些类加载器是有层次关系的，启动加载器又叫根加载器，是扩展加载器的父加载器，但是直接从ExClassLoader 里拿不到它的引用，同样会返回 null。</p><p>要创建用户自己的类加载器，只需要继承java.lang.ClassLoader类，然后覆盖它的findClass(Stringname)方法即可，即指明如何获取类的字节码流。</p><p>1、如果不想打破双亲委派模型，那么只需要重写findClass方法即可,也不需要重写resolveClass方法</p><p>2、如果想打破双亲委派模型，那么就重写整个loadClass方法。自定义类加载器的核心是对于字节码文件的获取。</p><blockquote><p>自定义类加载器的作用：jvm自带的三个加载器只能加载指定路径下的类字节码。如果某个情况下，我们需要加载应用程序之外的类文件呢？比如本地D盘下的，或者去加载网络上的某个类文件，这种情况就可以使用自定义加载器了。</p><p>还有，两个没有关系的自定义类加载器之间加载的类是不共享的（只共享父类加载器，兄弟之间不共享），这样就可以实现不同的类型沙箱的隔离性，我们可以用多个类加载器，各自加载同一个类的不同版本，大家可以相互之间不影响彼此，从而在这个基础上可以实现类的动态加载卸载，热插拔的插件机制等，具体信息大家可以参考OSGi等模块化技术。</p></blockquote><h1 id="类加载机制">6.类加载机制</h1><p>JVM的类加载机制主要有如下3种。</p><ul><li><strong>全盘负责</strong></li></ul><p>所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><ul><li><strong>双亲委派</strong></li></ul><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><blockquote><p>如果几个类加载器都没有加载到指定名称的类，那么会抛出ClassNotFountException 异常。</p></blockquote><ul><li><strong>缓存机制</strong></li></ul><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。</p><blockquote><p>这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p></blockquote><h2 id="双亲委派">6.1 双亲委派</h2><h3 id="为什么叫双亲委派">6.1.1 <strong>为什么叫双亲委派？</strong></h3><p><em>双亲委派”这个词估计也就是翻译错误的问题，或者是这样一种可能性。相对于AppClassLoader，即应用程序类加载器。它加载我们项目（工程）下的CLASSPATH 路径下的类，它会委托 ExtClassLoader标准扩展（Extension）类加载器（也有称作扩展类加载器），这时ExtClassLoader 会再次委派 BootstrapClassLoader启动类加载器。BootstrapClassLoader 是 Java虚拟机的第一个类加载器，它不能再向上委托了。</em></p><p><em>因此，根据这个过程，我们发现一共委托了两次，所以“双亲委派”中有一个双。而“亲”字，在中国代表的是亲人的意思，而委托两次，都是交给父类来处理，因此都算得上叫亲人。所以“双亲委派”中的双亲应该就是这样来的,</em></p><p>在前面我们说过：采用双亲委派的加载请求，最终都是委托给顶层的启动类加载器进行加载。</p><blockquote><p>在 java.lang.ClassLoader 中的 <code>loadClass</code>方法中实现该过程。</p></blockquote><h3 id="为什么使用双亲委派模型">6.1.2<strong>为什么使用双亲委派模型?</strong></h3><ul><li>避免同一个类被多次加载</li><li>每个加载器只能加载自己范围内的类，避免核心类被篡改。</li></ul><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/jvm/image-20230522231555610.png" /></p><p>比如我们常用String、Object类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的类都是同一个。</p><p>如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的String、Object 类，Java 类型体系中最基础的行为也就无法保证。</p><h3 id="如何打破双亲委派">6.1.3 <strong>如何打破双亲委派？</strong></h3><p>自定义类加载器，重写loadClass方法</p><ul><li>loadClass：双亲委派机制就是通过该方法实现的。默认过程-先判断该类是否被当前层的类加载过，如果没有就将该类委托给父类加载器。如果最顶端父类无法加载则向下传递。</li></ul><p>重写方法后可以自己定义是用什么加载器，也可以自定义委派机制。</p><ul><li>findclass</li></ul><p>这只是一个空方法，返回内容为class，方法其中没有任何内容，只抛出了个异常，说明这个方法需要开发者自己去实现。</p><blockquote><p>如果自定义的方法不想违背双亲委派模型，则只需要重写findclass方法即可，如果想违背双亲委派模型，则还需要重写loadclass方法。</p></blockquote><h1 id="一些实用的技巧">7.一些实用的技巧</h1><h2 id="如何排查找不到jar包的问题">7.1 如何排查找不到Jar包的问题？</h2><p>有时候我们会面临明明已经把某个jar加入到了环境里，可以运行的时候还是找不到。那么我们有没有一种方法，可以直接看到各个类加载器加载了哪些jar，以及把哪些路径加到了classpath里？答案是肯定的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jvm;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JvmClassLoaderPrintPath</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 启动类加载器</span><br>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        System.out.println(<span class="hljs-string">&quot;启动类加载器&quot;</span>);<br>        <span class="hljs-keyword">for</span>(URL url : urls) &#123;<br>            System.out.println(<span class="hljs-string">&quot; ==&gt; &quot;</span> +url.toExternalForm());<br>        &#125;<br><br>        <span class="hljs-comment">// 扩展类加载器</span><br>        printClassLoader(<span class="hljs-string">&quot;扩展类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader().getParent());<br><br>        <span class="hljs-comment">// 应用类加载器</span><br>        printClassLoader(<span class="hljs-string">&quot;应用类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader());<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printClassLoader</span><span class="hljs-params">(String name, ClassLoader CL)</span>&#123;<br>        <span class="hljs-keyword">if</span>(CL != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; ClassLoader -&gt; &quot;</span> + CL.toString());<br>            printURLForClassLoader(CL);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(name + <span class="hljs-string">&quot; ClassLoader -&gt; null&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printURLForClassLoader</span><span class="hljs-params">(ClassLoader CL)</span>&#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ucp</span> <span class="hljs-operator">=</span> insightField(CL,<span class="hljs-string">&quot;ucp&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> insightField(ucp,<span class="hljs-string">&quot;path&quot;</span>);<br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> (ArrayList) path;<br>        <span class="hljs-keyword">for</span> (Object p : ps)&#123;<br>            System.out.println(<span class="hljs-string">&quot; ==&gt; &quot;</span> + p.toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">insightField</span><span class="hljs-params">(Object obj, String fName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> URLClassLoader)&#123;<br>                f = URLClassLoader.class.getDeclaredField(fName);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                f = obj.getClass().getDeclaredField(fName);<br>            &#125;<br>            f.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> f.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">启动类加载器<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/resources.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/sunrsasign.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jsse.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/charsets.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jfr.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/classes<br><br>扩展类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="hljs-variable">$ExtClassLoader</span>@15db9742<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/access-bridge-64.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/cldrdata.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/dnsns.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jaccess.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jfxrt.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/localedata.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/nashorn.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunec.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunjce_provider.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunmscapi.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunpkcs11.jar<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/zipfs.jar<br><br>应用类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="hljs-variable">$AppClassLoader</span>@73d16e93<br>   ==&gt; file:/D:/git/studyjava/build/classes/java/main/<br>   ==&gt; file:/D:/git/studyjava/build/resources/main<br></code></pre></td></tr></table></figure><p>从打印结果，我们可以看到三种类加载器各自默认加载了哪些 jar包和包含了哪些 classpath 的路径。</p><h2 id="如何排查类的方法不一致的问题">7.2如何排查类的方法不一致的问题？</h2><p>假如我们确定一个 jar 或者 class 已经在 classpath里了，但是却总是提示<code>java.lang.NoSuchMethodError</code>，这是怎么回事呢？</p><p>很可能是加载了错误的或者重复加载了不同版本的 jar包。这时候，用前面的方法就可以先排查一下，加载了具体什么jar，然后是不是不同路径下有重复的 class 文件，但是版本不一样。</p><h2id="怎么看到加载了哪些类以及加载顺序">7.3怎么看到加载了哪些类，以及加载顺序？</h2><p>还是针对上一个问题，假如有两个地方有Hello.class，一个是新版本，一个是旧的，怎么才能直观地看到他们的加载顺序呢？也没有问题，我们可以直接打印加载的类清单和加载顺序。</p><p>只需要在类的启动命令行参数加上<code>-XX:+TraceClassLoading</code>或者 <code>-verbose</code> 即可，注意需要加载 Java命令之后，要执行的类名之前，不然不起作用。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ java -XX:+TraceClassLoading jvm.HelloClassLoader <br>[<span class="hljs-meta">Opened D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.Object from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.io.Serializable from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.Comparable from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.CharSequence from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.String from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.reflect.AnnotatedElement from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.reflect.GenericDeclaration from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.reflect.Type from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.Class from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.Cloneable from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.ClassLoader from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.System from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br><span class="hljs-comment">// .......  此处省略了100多条类加载信息</span><br>[<span class="hljs-meta">Loaded jvm.Hello from __JVM_DefineClass__</span>]<br>[<span class="hljs-meta">Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>Hello Class Initialized!<br>[<span class="hljs-meta">Loaded java.lang.Shutdown from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br>[<span class="hljs-meta">Loaded java.lang.Shutdown$Lock from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]<br></code></pre></td></tr></table></figure><p>上面的信息，可以很清楚的看到类的加载先后顺序，以及是从哪个 jar里加载的，这样排查类加载的问题非常方便。</p><h2 id="怎么调整或修改-ext-和本地加载路径">7.4怎么调整或修改 ext和本地加载路径？</h2><p>从前面的例子我们可以看到，假如什么都不设置，直接执行 java命令，默认也会加载非常多的 jar 包，怎么可以自定义加载哪些 jar包呢？比如我的代码很简单，只加载 rt.jar 行不行？答案是肯定的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java -Dsun.boot.class.path=<span class="hljs-string">&quot;D:\Program Files\Java\jre1.8.0_231\lib\rt.jar&quot;</span> -Djava.ext.dirs= jvm.JvmClassLoaderPrintPath<br><br>启动类加载器<br>   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar<br>扩展类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="hljs-variable">$ExtClassLoader</span>@15db9742<br>应用类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="hljs-variable">$AppClassLoader</span>@73d16e93<br>   ==&gt; file:/D:/git/studyjava/build/classes/java/main/<br>   ==&gt; file:/D:/git/studyjava/build/resources/main<br></code></pre></td></tr></table></figure><p>我们看到启动类加载器只加载了rt.jar，而扩展类加载器什么都没加载，这就达到了我们的目的。</p><p>其中命令行参数<code>-Dsun.boot.class.path</code>表示我们要指定启动类加载器加载什么，最基础的东西都在rt.jar 这个包了里，所以一般配置它就够了。</p><p>需要注意的是因为在 windows 系统默认 JDK安装路径有个空格，所以需要把整个路径用双引号括起来，如果路径没有空格，或是Linux/Mac 系统，就不需要双引号了。</p><p>参数<code>-Djava.ext.dirs</code>表示扩展类加载器要加载什么，一般情况下不需要的话可以直接配置为空即可。</p><h2id="怎么运行期加载额外的-jar-包或者-class-呢">7.5怎么运行期加载额外的jar 包或者 class 呢？</h2><p>有时候我们在程序已经运行了以后，还是想要再额外的去加载一些 jar或类，需要怎么做呢？</p><p>简单说就是不使用命令行参数的情况下，怎么用代码来运行时改变加载类的路径和方式。假如说，在<code>d:/app/jvm</code>路径下，有我们刚才使用过的Hello.class 文件，怎么在代码里能加载这个 Hello 类呢？</p><p>两个办法，<strong>一个是前面提到的自定义 ClassLoader的方式，还有一个就是直接在当前的应用类加载器里，使用 URLClassLoader类的方法 addURL，不过这个方法是 protected的，需要反射处理一下，然后又因为程序在启动时并没有显示加载 Hello类，所以在添加完了 classpath 以后，没法直接显式初始化，需要使用Class.forName的方式来拿到已经加载的Hello类（Class.forName("jvm.Hello")默认会初始化并执行静态代码块）</strong>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jvm;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JvmAppClassLoaderAddURL</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">appPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file:/d:/app/&quot;</span>;<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> (URLClassLoader) JvmAppClassLoaderAddURL.class.getClassLoader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">addURL</span> <span class="hljs-operator">=</span> URLClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;addURL&quot;</span>, URL.class);<br>            addURL.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(appPath);<br>            addURL.invoke(urlClassLoader, url);<br>            Class.forName(<span class="hljs-string">&quot;jvm.Hello&quot;</span>); <span class="hljs-comment">// 效果跟Class.forName(&quot;jvm.Hello&quot;).newInstance()一样</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行以下，结果如下：</p><blockquote><p>$ java JvmAppClassLoaderAddURL Hello Class Initialized!</p></blockquote><p>结果显示 Hello 类被加载，成功的初始化并执行了其中的代码逻辑。</p><h1 id="read-more">8.Read more</h1><p>:lollipop::https://blog.csdn.net/VincentlVL/article/details/120516607</p><p>:lollipop::https://doocs.gitee.io/jvm/08-load-class-time.html#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F</p><p>:lollipop::http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/06%20Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9A%E5%B1%B1%E4%B8%8D%E8%BE%9E%E5%9C%9F%EF%BC%8C%E6%95%85%E8%83%BD%E6%88%90%E5%85%B6%E9%AB%98.md</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识磁盘</title>
    <link href="/2022/10/13/system/disk/2022-10-13_%E8%AE%A4%E8%AF%86%E7%A3%81%E7%9B%98/"/>
    <url>/2022/10/13/system/disk/2022-10-13_%E8%AE%A4%E8%AF%86%E7%A3%81%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘">1.磁盘</h1><h2 id="前言">1.1 前言</h2><p>计算机的功能主要为：计算、存储和网络。而用于计算的数据以及计算后的结果很大一部分都需要存储起来，以备后续再次使用。向磁盘中存储和读取的过程叫磁盘I/O。磁盘的读取方式和速度会严重影响到整个业务的计算性能。</p><h2 id="认识磁盘">1.2 认识磁盘</h2><p>下面我们简单了解一下磁盘是如何工作的。</p><p>磁盘大概长这个样子：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172152777.png" /></p><p>磁盘主要由<code>磁盘盘片</code>、<code>传动手臂</code>、<code>读写磁头</code>和<code>马达</code>组成。为了存储容量,主轴像穿糖葫芦一样把多个磁盘片组成一个阵列。通过马达驱动主轴转动以及传动手臂移动，使读写磁头在磁盘片上读写数据。大概如下：</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172239121.png" alt="image-20240109172239121" style="zoom:50%;" /></p><h3 id="磁盘盘片platter">磁盘盘片（platter）</h3><p>磁盘盘片是由坚硬金属材料制成的涂以磁性介质的盘片，这些磁性物质用来记录二进制数据，不同容量硬盘的盘片数不等。因为正反两面都可涂上磁性物质，故一个盘片可能会有两个盘面。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。它们从上至下从“0”开始依次编号。</p><h4 id="磁道track">磁道（track）</h4><p>当磁盘旋转时,磁头若保持在一个位置上,则每个磁头都会在磁盘表面划出一个圆形轨迹,这些圆形轨迹就叫做<strong>磁道</strong>。这些磁道用肉眼是根本看不到的,因为它们仅是盘面上以特殊方式磁化了的一些磁化区,磁盘上的信息便是沿着这样的轨道存放的。相邻磁道之间并不是紧挨着的,这是因为磁化单元相隔太近时磁性会相互产生影响,同时也为磁头的读写带来困难。<strong>磁道从外向内从0开始顺序编号</strong>。数据就是写在这些磁道上。如下：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172316704.png" /></p><h4 id="扇区sector">扇区（sector）</h4><p>一个盘面划分为若干内角相同的扇形，这样盘面上的每个磁道就被分为若干段圆弧，<strong>每段圆弧</strong>叫一个<strong>扇区</strong>。</p><p>扇区是磁盘的最小组成单元，每个扇区可存储128×2的N次方（N＝0.1.2.3）字节信息。在DOS中每扇区是128×2的2次方＝512字节。</p><p>为了对扇区进行查找和管理，需要对扇区进行编号，扇区的编号<strong>由外向内</strong>从0磁道开始，起始扇区为1扇区，其后为2扇区、3扇区……，0磁道的扇区编号结束后，1磁道的起始扇区累计编号，直到最后一个磁道的最后一个扇区（n扇区）。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/9me5eyp5tb.png" /></p><p>在老式硬盘中，尽管磁道周长不同，但每个磁道上的扇区数是相等的，越往圆心扇区弧段越短，但其存储密度越高。不过这种方式显然比较浪费空间，因此现代硬盘则改为等密度结构，这意味着外围磁道上的扇区数量要大于内圈的磁道，寻址方式也改为以扇区为单位的线性寻址。为了兼容老式的3D 寻址方式，现代硬盘控制器中都有一个地址翻译器将 3D寻址参数翻译为线性参数。</p><blockquote><p>硬盘在进行扇区编号时与软盘有一些区别，在软盘的一个磁道中，扇区号一次编排，即1、2、3……n扇区。由于硬盘的转速较高，磁头在完成某个扇区数据的读写后，必须将数据传输到微机，这需要一个时间，但是这时硬盘在继续高速旋转，当数据传输完成后，磁头读写第二个扇区时，磁盘已经旋转到了另外一个扇区。因此在早期硬盘中，扇区号是按照某个间隔系数跳跃编排的。</p></blockquote><blockquote><p>3D 寻址参数：×× 磁道(柱面)，×× 磁头，×× 扇区</p></blockquote><h4 id="柱面cylinder">柱面（cylinder）</h4><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号（相同半径）的磁道形成一个圆柱，所以就是<strong>不同盘片相同半径的磁道</strong>所组成的<strong>圆柱</strong>称为<strong>柱面</strong>。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，柱面数等于磁道数。</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/tx1zz26zx6.png" style="zoom:67%;" /></p><h2 id="磁盘容量计算">1.3 磁盘容量计算</h2><p>扇区，磁道（或柱面）和磁头数构成了硬盘结构的基本参数，这些参数可以得到硬盘的容量，基计算公式为：</p><blockquote><p>存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数</p></blockquote><p>如上图，，磁盘是一个3个磁盘、6个磁头、7个柱面（每个磁盘有7个磁道）的磁盘，每条磁道有12个扇区，所以磁盘的容量为：</p><p>6 * 7 * 12 * 512 = 258048（字节）</p><blockquote><p>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</p></blockquote><p>并且：</p><blockquote><p>数据的读/写按柱面从外向内进行，而不是按盘面进行。是因为虽然每个盘面对应一个磁头。但是所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p></blockquote><h2 id="磁盘读取">1.4 磁盘读取</h2><p><strong>扇区编号定义</strong>：由前面介绍可知，我们可以用柱面 + 磁头+扇区来唯一定位磁盘上每一个区域，或是说柱面/磁头/扇区与磁盘上每一个扇区有一一对应关系，通常DOS 将“柱面/磁头/扇区”这样表示法称为“绝对扇区”表示法。</p><p>但 DOS不能直接使用绝对扇区进行磁盘上的信息管理，而是用所谓“相对扇区”或“DOS扇区”。</p><p>“相对扇区”只是一个数字，如柱面 140，磁头 3，扇区 4 对应的相对扇区号为2757。该数字与绝对扇区“柱面/磁头/扇区”具有一一对应关系。当使用相对扇区编号时，DOS是从柱面 0，磁头 1，扇区 1 开始（注：柱面 0，磁头 0，扇区 1 没有 DOS扇区编号，DOS下不能访问，只能调用 BIOS 访问），第一个 DOS 扇区编号为0，该磁道上剩余的扇区编号为 1 到 16（设每磁道 17个扇区），然后是磁头号为 2，柱面为 0的 17 个扇区，形成的 DOS 扇区号从 17到 33。直到该柱面的所有磁头。然后再移到柱面 1，磁头 1，扇区 1 继续进行DOS 扇区的编号，即按扇区号，磁头号，柱面号（磁道号）增长的顺序连续地分配DOS 扇区号。</p><blockquote><p>DOS:<ahref="https://baike.baidu.com/item/磁盘操作系统/3793138?fromModule=lemma_inlink">磁盘操作系统</a>（DiskOperating System）</p></blockquote><p>如果现在要读取某一位置的数据，磁盘需要：</p><ol type="1"><li>寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</li><li>旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。</li><li>数据传输时间：完成传输所请求的数据所需要的时间。</li></ol><h2 id="磁盘块簇page">1.5 磁盘块/簇、page</h2><p>扇区是硬盘数据存储的最小单位，但操作系统无法对数目众多的扇区进行寻址，所以操作系统就将<strong>相邻的扇区组合在一起，形成一个簇</strong>，然后再对簇进行管理.每个簇可以包括2、4、8、16、32、64个扇区。簇有时也称作磁盘块(block)。它是属于文件系统层面的概念，是文件系统层中数据存储的基本单位</p><p>“簇”是DOS进行分配的最小单位。当创建一个很小的文件时，如是一个字节，则它在磁盘上并不是只占一个字节的空间，而是占有整个一簇。</p><p>DOS视不同的存储介质（如软盘，硬盘），不同容量的硬盘，簇的大小也不一样。簇的大小可在称为磁盘参数块（BPB）中获取。簇的概念仅适用于数据区。磁盘驱动器在向磁盘读取和写入数据时，要以扇区为单位。<strong>在磁盘上，DOS操作系统是以“簇”为单位为文件分配磁盘空间的。硬盘的簇通常为多个扇区，与磁盘的种类、DOS版本及硬盘分区的大小有关</strong>。每个簇只能由一个文件占用，即使这个文件中有几个字节，决不允许两个以上的文件共用一个簇，否则会造成数据的混乱。</p><p>这种以簇为最小分配单位的机制，使硬盘对数据的管理变得相对容易，但也造成了磁盘空间的浪费，尤其是小文件数目较多的情况下，一个上千兆的大硬盘，其浪费的磁盘空间可达上百兆字节。（1）“簇”是DOS进行分配的最小单位。（2）不同的存储介质，不同容量的硬盘，不同的DOS版本，簇的大小也不一样。（3）簇的概念仅适用于数据区。</p><p>已经有了扇区，为什么还需要簇？</p><blockquote><p>读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。</p><p>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。</p></blockquote><p><strong>page</strong></p><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p><h4 id="扇区块簇page的关系">扇区、块/簇、page的关系</h4><ol type="1"><li>扇区： 硬盘的最小读写单元</li><li>块/簇： 是操作系统针对硬盘读写的最小单元</li><li>page： 是内存与操作系统之间操作的最小单元。</li></ol><p>扇区 &lt;= 块/簇 &lt;= page</p><h2 id="整体描述">1.6 整体描述</h2><p>下面我们用几张图来整体描述磁盘相关知识点：</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172239121.png" alt="image-20240109172239121" style="zoom:50%;" /></p><p>磁盘由<code>磁盘盘片</code>、<code>传动手臂</code>、<code>读写磁头</code>和<code>马达</code>组成。为了存储容量,主轴像穿糖葫芦一样把多个磁盘片组成一个阵列。通过马达驱动主轴转动以及传动手臂移动，使读写磁头在磁盘片上读写数据。</p><p>数据的读/写按柱面从外向内进行，而不是按盘面进行。是因为虽然每个盘面对应一个磁头。但是所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172330313.png" /></p><p>在磁盘中，磁道被分为多个内角相等的区域，这个区域叫做扇面，在扇面中，每一条被划分的磁道被称为扇区。</p><p>根据×× 磁道(柱面)（找第几个磁道），×× 磁头（找到第几个磁盘），××扇区（找到对应的区域）能定位磁盘上每一个区域。</p><p>磁盘驱动器在向磁盘读取和写入数据时，要以<strong>扇区</strong>为单位。在磁盘上，DOS操作系统是以“簇”为单位为文件分配磁盘空间的。硬盘的簇通常为多个扇区，与磁盘的种类、DOS版本及硬盘分区的大小有关。</p><p>如果磁盘是一记事本，那么一张磁盘片就是本子的一页纸，而主轴就是本子的装订线；磁道就是纸页的行，而扇区可以看作是很宽的列。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172342837.png" /></p><p>如果在磁盘中存储一首诗,想象中大概这个样子。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172357093.png" /></p><p>磁盘的读 I/O操作,需要找到数据所在的<strong>磁盘片</strong>，以及对应的磁道和<strong>扇区</strong>。这些操作类似于从一本书中找到数据所在的页，行，列。</p><p>因为每个磁盘片都对应一个磁头，所以性能的关键就在于找行和列，即<strong>寻道</strong>和磁盘旋转。寻道即通过磁头找到数据所在的磁道，相当于换行到数据所在行。由于磁头只能水平移动，即只能换行寻道，无法在指定磁道上移动，因此需要磁盘高速旋转移动到指定扇区，类似写春联时，笔不动，纸动。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172418949.png" /></p><p>综上所述，磁盘的读写是通过机械运动来定位数据所在位置，而 cpu是通过电信号进行数字运算。粗略的认为，机械查询数据，与光速处理数据的性能完全不是在一个量级，总之一句话就是<strong>磁盘处理太慢太慢了</strong>。</p><p>虽然磁盘处理数据太慢了，但是它是目前相对廉价且稳定的存储设备，所以又不能舍弃不用，但大致可以通过以下方法进行优化。</p><ul><li>尽量减少 I/O 次数，比如可以使用缓存；</li><li>每次 I/O 尽量获取更多的数据；</li><li>每次 I/O 尽量获取有用的数据，当然相应的也间接减少总 I/O 次数；</li></ul><h2 id="k对齐">1.7 4K对齐</h2><p>早期的硬盘一个扇区的大小是512个字节，后来随之磁盘容量的不断增加和读写效率提升的要求，将每个扇区的大小调整为4096个字节，也就是4KB，这种扇区又叫4K扇区。4K对齐指的就是对磁盘分区时，让分区的起始扇区位于某一个4K扇区的起始位置。所以分区起始位置只要是4096的倍数就是4K对齐了。</p><h1 id="read-more">Read more</h1><p>https://cloud.tencent.com/developer/article/1129947</p><p>https://blog.csdn.net/xiaominthere/article/details/19756551</p><p>https://blog.csdn.net/t_1007/article/details/53032682</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>磁盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式数据的一致性-ZAB协议</title>
    <link href="/2022/09/24/framework/zookeeper/2022-09-24_%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/09/24/framework/zookeeper/2022-09-24_%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-ZAB%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>我们知道在 ZooKeeper 集群中，服务器分为 Leader 服务器、 Follower服务器以及 Observer 服务器。</p><p>可以这样认为，Leader 选举是一个过程，在这个过程中 ZooKeeper主要做了两个重要工作，一个是数据同步，另一个是选举出新的 Leader服务器。今天我们主要先介绍第一个工作，ZooKeeper集群中的数据同步问题。</p><h3 id="leader-的协调过程">Leader 的协调过程</h3><p>在分布式系统中有一个著名的 CAP定理，是说一个分布式系统不能同时满足一致性、可用性，以及分区容错性。今天我们要讲的就是一致性。其实ZooKeeper中实现的一致性也不是强一致性，即集群中各个服务器上的数据每时每刻都是保持一致的特性。在ZooKeeper中，采用的是最终一致的特性，<strong>即经过一段时间后，ZooKeeper集群服务器上的数据最终保持一致的特性</strong>。</p><p>在 ZooKeeper 集群中，Leader服务器主要负责处理事物性的请求，而在接收到一个客户端的事务性请求操作时，Leader服务器会先向集群中的各个机器针对该条会话发起投票询问。</p><p><strong>什么情况下会对 ZooKeeper集群服务产生不一致的情况？</strong></p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230509160259683.png"alt="image-20230509160259683" /><figcaption aria-hidden="true">image-20230509160259683</figcaption></figure><p>在集群初始化启动的时候，首先要同步集群中各个服务器上的数据。而在集群中Leader 服务器崩溃时，需要选举出新的 Leader而在这一过程中会导致各个服务器上数据的不一致，所以当选举出新的 Leader服务器后需要进行数据的同步操作。</p><h1 id="zab协议">1.ZAB协议</h1><p>ZooKeeper最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群Leader节点发生重新选举时，都会产生数据不一致的情况。为了解决这个问题，ZooKeeper采用了 ZAB 协议算法。</p><p><strong>ZAB 协议算法</strong>（Zookeeper Atomic Broadcast ，Zookeeper原子广播协议）是 ZooKeeper专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是<strong>崩溃恢复</strong>和<strong>原子广播协议</strong>。</p><p>在整个 ZAB 协议的底层实现中，ZooKeeper集群主要采用<strong>主从模式</strong>的系统架构方式来保证 ZooKeeper集群系统的一致性。<strong>实现了一种主备模式的系统架构保持集群中各副本之间数据的一致性，主备模式保证了同一时刻集群汇总只能够有一个主进程来广播服务器的状态变更，因此可以很好的处理客户端大量的并发请求.</strong></p><blockquote><p>ZAB协议的核心是定义了<strong>对于那些会改变Zookeeper服务器数据状态的事务请求的处理方式</strong>。</p></blockquote><p>整个实现过程如下图所示，当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230306175503379.png"alt="image-20230306175503379" /><figcaption aria-hidden="true">image-20230306175503379</figcaption></figure><p>思想如下：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20220729222815112.png"alt="image-20220729222815112" /><figcaption aria-hidden="true">image-20220729222815112</figcaption></figure><p>以 ZooKeeper 集群为例，这个操作过程可以概括为：当 ZooKeeper集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow角色服务器会将该请求转发给 Leader 角色服务器进行处理。当 Leader节点服务器在处理完该条会话请求后。</p><p><strong><em>Leader服务器负责将一个客户端事务请求转化成一个事务Proposal(提议)，并将该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交，最终完成整个ZooKeeper 集群对客户端会话的处理工作。</em></strong></p><blockquote><p>所有事务请求必须由一个<strong>全局唯一的服务器</strong>来协调处理，这样的服务器被称为<code>Leader服务器</code>，余下的服务器则称为<code>Follower服务器</code>，</p></blockquote><h1 id="zab协议两种基本模式">2.ZAB协议两种基本模式</h1><p>ZAB协议包括两种基本模式：<code>崩溃恢复模式</code>和<code>消息广播模式</code>。</p><h2 id="崩溃恢复模式">2.1 <strong>崩溃恢复模式</strong></h2><p>当整个服务框架启动过程中,或者是Leader服务器出现<strong>网络中断</strong>、<strong>崩溃退出</strong>或<strong>重启</strong>等异常情况时,ZAB协议就会进入<code>崩溃恢复模式</code>,同时选举产生新的Leader服务器。当选举产生了新的Leader服务器,同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后,ZAB协议就会<code>退出恢复模式</code>,其中,所谓的状态同步就是指数据同步,用来<strong>保证集群中过半的机器能够和Leader服务器的数据状态保持一致。</strong></p><h2 id="消息广播模式">2.2 <strong>消息广播模式</strong></h2><p>当集群中已经有<strong>过半的Follower服务器完成了和Leader服务器的状态同步</strong>,那么整个服务框架就可以进入消息广播模式,当一台同样遵守ZAB协议的服务器启动后加入到集群中,如果此时集群中已经存在一个Leader服务器在负责进行消息广播,那么加入的服务器就会自觉地进入数据恢复模式:找到Leader所在的服务器,并与其进行数据同步,然后一起参与到消息广播流程中去。<code>Zookeeper只允许唯一的一个Leader服务器来进行事务请求的处理</code>,Leader服务器在接收到客户端的事务请求后,会生成对应的事务提议并发起一轮广播协议,而如果集群中的其他机器收到客户端的事务请求后,那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p><p>当Leader服务器出现崩溃或者机器重启、集群中已经不存在过半的服务器与Leader服务器保持正常通信时，那么在重新开始新的一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此到达一致状态，于是整个ZAB流程就会从<strong>消息广播模式进入到崩溃恢复模式</strong>。</p><p>http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/29%20ZAB%20%E5%8D%8F%E8%AE%AE%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E5%92%8C%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.md</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper服务数据与文件</title>
    <link href="/2022/09/20/framework/zookeeper/2022-09-20_Zookeeper%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/20/framework/zookeeper/2022-09-20_Zookeeper%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper服务数据与文件">Zookeeper服务数据与文件</h1><p>ZooKeeper框架能够实现的功能，而无论是什么程序，其本质就是对数据的操作。比如 MySQl数据库操作的是数据表，Redis 数据库操作的是存储在内存中的 Key-Value值。不同的数据格式和存储方式对系统运行的效率和处理能力都有很大影响。本课时就来学习，在ZooKeeper程序运行期间，都会处理哪些数据，以及他们的存储格式和存储位置。</p><p>ZooKeeper 服务提供了创建节点、添加 Watcher监控机制、集群服务等丰富的功能。这些功能服务的实现，离不开底层数据的支持。从数据存储地点角度讲，ZooKeeper服务产生的数据可以分为内存数据和磁盘数据。而从数据的种类和作用上来说，又可以分为事务日志数据和数据快照数据。</p><h1 id="内存数据">1.内存数据</h1><p>数据节点实际上就是 ZooKeeper 在服务运行过程中所操作的数据。ZooKeeper的数据模型可以看作一棵<strong>树形结构</strong>，而数据节点就是这棵树上的叶子节点。从数据存储的角度看，ZooKeeper的数据模型是存储在内存中的。我们可以把 ZooKeeper的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的ACL 权限信息以及 stat 状态信息等。</p><p>而在底层实现中，ZooKeeper 数据模型是通过 DataTree类来定义的。如下面的代码所示，DataTree 类定义了一个 ZooKeeper数据的内存结构。DataTree 的内部定义类 nodes 节点类型、root根节点信息、子节点的 WatchManager监控信息等数据模型中的相关信息。可以说，一个 DataTree 类定义了 ZooKeeper内存数据的逻辑结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataTree</span> &#123;<br><br>  <span class="hljs-keyword">private</span> DataNode root<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager dataWatches<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager childWatches<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">rootZookeeper</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事务日志">2.事务日志</h1><p>为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper集群中的 Follow 和 Observer服务器就会进行数据同步。而这两种角色服务器所接收到的信息就是 Leader服务器的事务日志。在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个ZooKeeper 集群的执行性能。</p><p>在我们启动一个 ZooKeeper 服务器之前，首先要创建一个 zoo.cfg文件并进行相关配置，其中有一项配置就是 <code>dataLogDir</code>。在这项配置中，我们会指定该台 ZooKeeper 服务器事务日志的存放位置</p><p>在 ZooKeeper 服务的底层实现中，是通过 FileTxnLog类来实现事务日志的底层操作的。如下图代码所示，在 FileTxnLog类中定义了一些属性字段，分别是：</p><ul><li><p>preAllocSize：可存储的日志文件大小。如用户不进行特殊设置，默认的大小为65536*1024 字节。</p></li><li><p>TXNLOG_MAGIC：设置日志文件的魔数信息为ZKLG。</p></li><li><p>VERSION：设置日志文件的版本信息。</p></li><li><p>lastZxidSeen：最后一次更新日志得到的 ZXID。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTxnLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TxnLog</span>, Closeable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TXNLOG_MAGIC</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;ZKLG&quot;</span>.getBytes()).getInt();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VERSION</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <br>      <span class="hljs-comment">/** Maximum time we allow for elapsed fsync before WARNing */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> fsyncWarningThresholdMS;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilePadding</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">preAllocSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">65536</span> * <span class="hljs-number">1024</span>;<br>    ... ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>定义了事务日志操作的相关指标参数后，在 FileTxnLog 类中调用 static静态代码块，来将这些配置参数进行初始化。比如读取 preAllocSize参数分配给日志文件的空间大小等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    LOG = LoggerFactory.getLogger(FileTxnLog.class);<br><br>    <span class="hljs-comment">/** Local variable to read fsync.warningthresholdms into */</span><br>    Long fsyncWarningThreshold;<br>    <span class="hljs-keyword">if</span> ((fsyncWarningThreshold = Long.getLong(ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY)) == <span class="hljs-literal">null</span>) &#123;<br>        fsyncWarningThreshold = Long.getLong(FSYNC_WARNING_THRESHOLD_MS_PROPERTY, <span class="hljs-number">1000</span>);<br>    &#125;<br>    fsyncWarningThresholdMS = fsyncWarningThreshold;<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">logSize</span> <span class="hljs-operator">=</span> Long.getLong(txnLogSizeLimitSetting, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (logSize &gt; <span class="hljs-number">0</span>) &#123;<br>        LOG.info(<span class="hljs-string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, txnLogSizeLimitSetting, logSize);<br><br>        <span class="hljs-comment">// Convert to bytes</span><br>        logSize = logSize * <span class="hljs-number">1024</span>;<br>        txnLogSizeLimit = logSize;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过参数定义和日志文件的初始化创建后，在 ZooKeeper 服务器的 dataDir路径下就生成了一个用于存储事务性操作的日志文件。我们知道在 ZooKeeper服务运行过程中，会不断地接收和处理来自客户端的事务性会话请求，这就要求每次在处理事务性请求的时候，都要记录这些信息到事务日志中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * append an entry to the transaction log</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hdr the header of the transaction</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> txn the transaction part of the entry</span><br><span class="hljs-comment">     * returns true iff something appended, otw false</span><br><span class="hljs-comment">     * 向事务日志追加一个条目</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">append</span><span class="hljs-params">(TxnHeader hdr, Record txn)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>              <span class="hljs-keyword">return</span> append(hdr, txn, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">append</span><span class="hljs-params">(TxnHeader hdr, Record txn, TxnDigest digest)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (hdr == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hdr.getZxid() &lt;= lastZxidSeen) &#123;<br>            LOG.warn(<br>                <span class="hljs-string">&quot;Current zxid &#123;&#125; is &lt;= &#123;&#125; for &#123;&#125;&quot;</span>,<br>                hdr.getZxid(),<br>                lastZxidSeen,<br>                Request.op2String(hdr.getType()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lastZxidSeen = hdr.getZxid();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (logStream == <span class="hljs-literal">null</span>) &#123;<br>            LOG.info(<span class="hljs-string">&quot;Creating new log file: &#123;&#125;&quot;</span>, Util.makeLogName(hdr.getZxid()));<br><br>            logFileWrite = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logDir, Util.makeLogName(hdr.getZxid()));<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(logFileWrite);<br>            logStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>            oa = BinaryOutputArchive.getArchive(logStream);<br>            <span class="hljs-type">FileHeader</span> <span class="hljs-variable">fhdr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileHeader</span>(TXNLOG_MAGIC, VERSION, dbId);<br>            fhdr.serialize(oa, <span class="hljs-string">&quot;fileheader&quot;</span>);<br>            <span class="hljs-comment">// Make sure that the magic number is written before padding.</span><br>            logStream.flush();<br>            filePadding.setCurrentSize(fos.getChannel().position());<br>            streamsToFlush.add(fos);<br>        &#125;<br>        filePadding.padFile(fos.getChannel());<br>        <span class="hljs-type">byte</span>[] buf = Util.marshallTxnEntry(hdr, txn, digest);<br>        <span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">null</span> || buf.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Faulty serialization for header &quot;</span> + <span class="hljs-string">&quot;and txn&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Checksum</span> <span class="hljs-variable">crc</span> <span class="hljs-operator">=</span> makeChecksumAlgorithm();<br>        crc.update(buf, <span class="hljs-number">0</span>, buf.length);<br>        oa.writeLong(crc.getValue(), <span class="hljs-string">&quot;txnEntryCRC&quot;</span>);<br>        Util.writeTxnBytes(oa, buf);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>从对事务日志的底底层代码分析中可以看出，在 datadir配置参数路径下存放着 ZooKeeper服务器所有的事务日志，所有事务日志的命名方法都是“log.+ 该条事务会话的zxid”。</p></blockquote><h1 id="数据快照">3.数据快照</h1><p>说到快照，可能很多技术人员都不陌生。一个快照可以看作是当前系统或软件服务运行状态和数据的副本。在ZooKeeper中，数据快照的作用是将内存数据结构存储到本地磁盘中。因此，从设计的角度说，数据快照与内存数据的逻辑结构一样，都使用DataTree 结构。在 ZooKeeper服务运行的过程中，数据快照每间隔一段时间，就会把 ZooKeeper内存中的数据存储到磁盘中，快照文件是间隔一段时间后对内存数据的备份。</p><p>因此，与内存数据相比，快照文件的数据具有滞后性。而与上面介绍的事务日志文件一样，在创建数据快照文件时，也是使用zxid 作为文件名称。</p><p>在代码层面，ZooKeeper 通过 FileTxnSnapLog类来实现数据快照的相关功能。如下图所示，在FileTxnSnapLog类的内部，最核心的方法是 save 方法，在 save方法的内部，首先会创建数据快照文件，之后调用 FileSnap类对<code>内存数据进行序列化，并写入到快照文件中</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(DataTree dataTree,</span><br><span class="hljs-params"></span><br><span class="hljs-params">                 ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeouts,</span><br><span class="hljs-params"></span><br><span class="hljs-params">                 <span class="hljs-type">boolean</span> syncSnap)</span><br><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">lastZxid</span> <span class="hljs-operator">=</span> dataTree.lastProcessedZxid;<br><br>    <span class="hljs-type">File</span> <span class="hljs-variable">snapshotFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(snapDir, Util.makeSnapshotName(lastZxid));<br><br>    LOG.info(<span class="hljs-string">&quot;Snapshotting: 0x&#123;&#125; to &#123;&#125;&quot;</span>, Long.toHexString(lastZxid),<br><br>            snapshotFile);<br><br>    snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">4.总结</h1><p>我们知道在 ZooKeeper服务的运行过程中，<strong>会涉及内存数据</strong>、<strong>事务日志</strong>、<strong>数据快照这三种数据文件</strong>。从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。事务日志数据主要用于记录本地事务性会话操作，用于ZooKeeper集群服务器之间的数据同步。事务快照则是将内存数据持久化到本地磁盘。</p><p>这里要注意的一点是，<strong>数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致</strong>。在单台ZooKeeper服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper-Watch 机制</title>
    <link href="/2022/09/19/framework/zookeeper/2022-09-19_Zookeeper-Watch%20%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/09/19/framework/zookeeper/2022-09-19_Zookeeper-Watch%20%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="watch-机制">1. Watch 机制</h1><p>在日常生活中也有很多订阅发布的场景。比如我们喜欢观看某一个剧集，视频网站会有一个订阅按钮，用户可以订阅自己喜欢的电视剧，当有新的剧集发布时，网站会通知该用户第一时间观看。或者我们在网站上看到一件心仪的商品，但是当前没有库存，网站会提供到货通知的功能，我们开启这个商品的到货通知功能后，商品补货的时候会通知我们，之后就可以进行购买了。ZooKeeper中的 Watch机制很像这些日常的应用场景，其中的客户端就是用户，而服务端的数据节点就好像是我们订阅的商品或剧集。</p><p>现在我们可以从技术实现的角度分析一下上边提到的这些场景，无论是订阅一集电视剧还是订购一件商品。都有几个核心节点，即用户端注册服务、服务端处理请求、客户端收到回调后执行相应的操作。</p><h1 id="zookeeper-watch机制">2. Zookeeper-Watch机制</h1><p>ZooKeeper 中的 Watch机制<strong>实现了分布式的通知功能，Zookeeper允许客户端向服务端注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，就会向客户端发送一个事件通知来实现分布式的通知功能。</strong></p><p>我们知道Zookeeper是通过<strong>节点</strong>储存数据的，因此当ZNode节点数据发生变化的时候就能触发。过程如下：</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/typora/project/20181030160347021812.jpeg" alt="技术分享图片" style="zoom:70%;" /></p><p><strong>ZooKeeper 的客户端也可以通过 Watch机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知</strong>，我们可以通过向ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(String connectString, <span class="hljs-type">int</span> sessionTimeout, Watcher watcher)<br></code></pre></td></tr></table></figure><p>上面代码的意思是定义了一个了 ZooKeeper客户端对象实例，并传入三个参数：</p><ul><li><p>connectString 服务端地址</p></li><li><p>sessionTimeout：超时时间</p></li><li><p>Watcher：监控事件</p></li></ul><p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文，一直被保存在客户端 <code>ZKWatchManager</code> 的<code>defaultWatcher</code> 中。</p><p>除此之外，ZooKeeper 客户端也可以通过 <code>getData</code>、<code>getChildren</code> 和<code>exists</code>三个接口来向 ZooKeeper服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p><blockquote><p>getData(String path, Watcher watcher, Stat stat)</p></blockquote><h1 id="状态和事件">3. 状态和事件</h1><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F61ILaAb7sQAAC6T3wMHDU651.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。例如在客户端连接服务端的时候，可以对数据节点的<code>创建、删除、数据变更、子节点的更新</code>等操作进行监控。</p><h1 id="watch-机制的底层原理">4. Watch 机制的底层原理</h1><p>由于 Watch机制涉及了客户端和服务端的多个函数和操作节点，单单按照程序执行流程分析跳跃性对整体实现机制的理解难度大。为了更好地阐述Watch 机制，我们另辟蹊径，从设计模式角度出发来分析其底层实现：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F61IL-AEQuUAABdpaAsy2k628.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>学习 Watch机制的时候，它给我的第一印象是，其结构很像设计模式中的”观察者模式“，一个对象或者数据节点可能会被多个客户端监控，当对应事件被触发时，会通知这些对象或客户端。我们可以将Watch机制理解为是分布式环境下的观察者模式。所以接下来我们就以<code>观察者模式</code>的角度点来看看ZooKeeper 底层 Watch 是如何实现的。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F61IMWAbWW9AABzXk9xuOs953.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>通常我们在实现观察者模式时，最核心或者说关键的代码就是<strong>创建一个列表来存放观察者</strong>。而在 ZooKeeper中则是在客户端和服务器端分别实现两个存放观察者列表，即：<code>ZKWatchManager</code>和 <code>WatchManager</code>。其核心操作就是围绕着这两个展开的。</p><h2 id="客户端-watch-注册实现过程">4.1 客户端 Watch 注册实现过程</h2><p>客户端在发送一个 Watch 监控事件的会话请求时，ZooKeeper客户端主要做了两个工作：</p><ul><li><p>标记该会话是一个带有 Watch 事件的请求</p></li><li><p>将 Watch 事件存储到 ZKWatchManager</p></li><li><p><strong>getData</strong></p></li></ul><p>我们以 getData 接口为例。当发送一个带有 Watch事件的请求时，客户端首先会把该会话标记为带有 Watch监控的事件请求，之后通过 DataWatchRegistration 类来保存 watcher事件和节点的对应关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the data and the stat of the node of the given path.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * If the watch is non-null and the call is successful (no exception is</span><br><span class="hljs-comment">     * thrown), a watch will be left on the node with the given path. The watch</span><br><span class="hljs-comment">     * will be triggered by a successful operation that sets data on the node, or</span><br><span class="hljs-comment">     * deletes the node.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * A KeeperException with error code KeeperException.NoNode will be thrown</span><br><span class="hljs-comment">     * if no node with the given path exists.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path the given path</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> watcher explicit watcher</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stat the stat of the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the data of the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException If the server signals an error with a non-zero error code</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException If the server transaction is interrupted.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if an invalid path is specified</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getData(<span class="hljs-keyword">final</span> String path, Watcher watcher, Stat stat) <span class="hljs-keyword">throws</span> KeeperException, InterruptedException &#123;<br>        ... ...<br>        <span class="hljs-type">WatchRegistration</span> <span class="hljs-variable">wcb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (watcher != <span class="hljs-literal">null</span>) &#123;<br>            wcb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataWatchRegistration</span>(watcher, clientPath);<br>        &#125;<br>        <br>        <span class="hljs-type">RequestHeader</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeader</span>();<br>        <br>        <span class="hljs-type">GetDataRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetDataRequest</span>();<br>        ... ...<br>        request.setWatch(watcher != <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">GetDataResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetDataResponse</span>();<br>        <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cnxn.submitRequest(h, request, response, wcb);<br>        ... ...<br>        <span class="hljs-keyword">return</span> response.getData();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>cnxn.submitRequest</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReplyHeader <span class="hljs-title function_">submitRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">    RequestHeader h,</span><br><span class="hljs-params">    Record request,</span><br><span class="hljs-params">    Record response,</span><br><span class="hljs-params">    WatchRegistration watchRegistration)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">return</span> submitRequest(h, request, response, watchRegistration, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> ReplyHeader <span class="hljs-title function_">submitRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">    RequestHeader h,</span><br><span class="hljs-params">    Record request,</span><br><span class="hljs-params">    Record response,</span><br><span class="hljs-params">    WatchRegistration watchRegistration,</span><br><span class="hljs-params">    WatchDeregistration watchDeregistration)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplyHeader</span>();<br>    <span class="hljs-type">Packet</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> queuePacket(<br>        h,<br>        r,<br>        request,<br>        response,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        watchRegistration,<br>        watchDeregistration);<br>     ... ...<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>queuePacket</strong></li></ul><p>之后客户端向服务器发送请求时，是将请求封装成一个 <code>Packet</code>对象，并添加到一个等待发送队列 outgoingQueue 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressFBWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)</span><br><span class="hljs-keyword">public</span> Packet <span class="hljs-title function_">queuePacket</span><span class="hljs-params">(</span><br><span class="hljs-params">    RequestHeader h,</span><br><span class="hljs-params">    ReplyHeader r,</span><br><span class="hljs-params">    Record request,</span><br><span class="hljs-params">    Record response,</span><br><span class="hljs-params">    AsyncCallback cb,</span><br><span class="hljs-params">    String clientPath,</span><br><span class="hljs-params">    String serverPath,</span><br><span class="hljs-params">    Object ctx,</span><br><span class="hljs-params">    WatchRegistration watchRegistration,</span><br><span class="hljs-params">    WatchDeregistration watchDeregistration)</span> &#123;<br>    <span class="hljs-type">Packet</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Note that we do not generate the Xid for the packet yet. It is</span><br>    <span class="hljs-comment">// generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),</span><br>    <span class="hljs-comment">// where the packet is actually sent.</span><br>    packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packet</span>(h, r, request, response, watchRegistration);<br>    packet.cb = cb;<br>    packet.ctx = ctx;<br>    packet.clientPath = clientPath;<br>    packet.serverPath = serverPath;<br>    packet.watchDeregistration = watchDeregistration;<br>    <br>    <span class="hljs-comment">// The synchronized block here is for two purpose:</span><br>    <span class="hljs-comment">// 1. synchronize with the final cleanup() in SendThread.run() to avoid race</span><br>    <span class="hljs-comment">// 2. synchronized against each packet. So if a closeSession packet is added,</span><br>    <span class="hljs-comment">// later packet will be notified.</span><br>    <span class="hljs-keyword">synchronized</span> (outgoingQueue) &#123;<br>        <span class="hljs-keyword">if</span> (!state.isAlive() || closing) &#123;<br>            conLossPacket(packet);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// If the client is asking to close the session then</span><br>            <span class="hljs-comment">// mark as closing</span><br>            <span class="hljs-keyword">if</span> (h.getType() == OpCode.closeSession) &#123;<br>                closing = <span class="hljs-literal">true</span>;<br>            &#125;<br>            outgoingQueue.add(packet);<br>        &#125;<br>    &#125;<br>    sendThread.getClientCnxnSocket().packetAdded();<br>    <span class="hljs-keyword">return</span> packet;<br>&#125;<br></code></pre></td></tr></table></figure><p>outgoingQueue是一个LinkedBlockingDeque。正如注释所说：队列存储的是需要被发送的packets。</p><blockquote><p>/**These are the packets that need to be sent.*/ private finalLinkedBlockingDeque<Packet> outgoingQueue = newLinkedBlockingDeque&lt;&gt;();</p></blockquote><p>最后，ZooKeeper客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的SendThread 线程类中的 readResponse 方法接收服务端的回调，并在最后执行finishPacket（）方法将 Watch 注册到 ZKWatchManager 中：</p><p><strong>sendThread</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * This class services the outgoing request queue and generates the heart</span><br><span class="hljs-comment">  * beats. It also spawns the ReadThread.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br>     ... ...<br><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">readResponse</span><span class="hljs-params">(ByteBuffer incomingBuffer)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         <span class="hljs-type">ByteBufferInputStream</span> <span class="hljs-variable">bbis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferInputStream</span>(incomingBuffer);<br>         <span class="hljs-type">BinaryInputArchive</span> <span class="hljs-variable">bbia</span> <span class="hljs-operator">=</span> BinaryInputArchive.getArchive(bbis);<br>         <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">replyHdr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplyHeader</span>();<br><br>         replyHdr.deserialize(bbia, <span class="hljs-string">&quot;header&quot;</span>);<br>         <span class="hljs-keyword">switch</span> (replyHdr.getXid()) &#123;<br>         <span class="hljs-keyword">case</span> PING_XID:<br>             ... ...<br>             <span class="hljs-keyword">return</span>;<br>           <span class="hljs-keyword">case</span> AUTHPACKET_XID:<br>              ... ...     <br>           <span class="hljs-keyword">return</span>;<br>         <span class="hljs-keyword">case</span> NOTIFICATION_XID:<br>             ... ...<br>             <span class="hljs-keyword">return</span>;<br>         <span class="hljs-keyword">default</span>:<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>         ... ...<br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">          * Since requests are processed in order, we better get a response</span><br><span class="hljs-comment">          * to the first request!</span><br><span class="hljs-comment">          */</span><br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;<br>                 packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());<br>                 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Xid out of order. Got Xid &quot;</span> + replyHdr.getXid()<br>                                       + <span class="hljs-string">&quot; with err &quot;</span> + replyHdr.getErr()<br>                                       + <span class="hljs-string">&quot; expected Xid &quot;</span> + packet.requestHeader.getXid()<br>                                       + <span class="hljs-string">&quot; for a packet with details: &quot;</span> + packet);<br>             &#125;<br><br>             packet.replyHeader.setXid(replyHdr.getXid());<br>             packet.replyHeader.setErr(replyHdr.getErr());<br>             packet.replyHeader.setZxid(replyHdr.getZxid());<br>             <span class="hljs-keyword">if</span> (replyHdr.getZxid() &gt; <span class="hljs-number">0</span>) &#123;<br>                 lastZxid = replyHdr.getZxid();<br>             &#125;<br>             <span class="hljs-keyword">if</span> (packet.response != <span class="hljs-literal">null</span> &amp;&amp; replyHdr.getErr() == <span class="hljs-number">0</span>) &#123;<br>                 packet.response.deserialize(bbia, <span class="hljs-string">&quot;response&quot;</span>);<br>             &#125;<br><br>             LOG.debug(<span class="hljs-string">&quot;Reading reply session id: 0x&#123;&#125;, packet:: &#123;&#125;&quot;</span>, Long.toHexString(sessionId), packet);<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             finishPacket(packet);<br>         &#125;<br>     &#125;<br>     ... ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>finishPacket</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishPacket</span><span class="hljs-params">(Packet p)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> p.replyHeader.getErr();<br><br>        <span class="hljs-keyword">if</span> (p.watchRegistration != <span class="hljs-literal">null</span>) &#123;<br><br>            p.watchRegistration.register(err);<br><br>        &#125;<br>       ...<br>&#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-type">int</span> rc)</span> &#123;<br>            <span class="hljs-keyword">if</span> (shouldAddWatch(rc)) &#123;<br>                Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);<br>                <span class="hljs-keyword">synchronized</span> (watches) &#123;<br>                    Set&lt;Watcher&gt; watchers = watches.get(clientPath);<br>                    <span class="hljs-keyword">if</span> (watchers == <span class="hljs-literal">null</span>) &#123;<br>                        watchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>                        watches.put(clientPath, watchers);<br>                    &#125;<br>                    watchers.add(watcher);<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>客户端当发送一个带有 Watch事件的请求时，客户端首先会把该会话标记为带有 Watch监控的事件请求，之后通过 <code>DataWatchRegistration</code> 类来保存watcher 事件和节点的对应关系，然后将请求封装成一个 <code>Packet</code>对象，并添加到一个等待发送队列 <code>outgoingQueue</code> 中。</p><p>最后，ZooKeeper客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的<code>SendThread</code> 线程类中的 <code>readResponse</code>方法接收服务端的回调，并在最后执行 <code>finishPacket</code>方法将 Watch注册到 ZKWatchManager 中。</p><h2 id="服务端-watch-注册实现过程">4.2 服务端 Watch 注册实现过程</h2><p>Zookeeper 服务端处理 Watch 事件基本有 2 个过程：</p><ul><li>解析收到的请求是否带有 Watch 注册事件</li><li>将对应的 Watch 事件存储到 WatchManager</li></ul><p>当 ZooKeeper服务器接收到一个客户端请求后，首先会对请求进行解析，判断该请求是否包含Watch 事件。这在 ZooKeeper 底层是通过 <code>FinalRequestProcessor</code>类中的 processRequest 函数实现的。当 getDataRequest.getWatch() 值为 True时，表明该请求需要进行 Watch 监控注册。并通过<code>zks.getZKDatabase().getData</code> 函数将 Watch 事件注册到服务端的WatchManager 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(Request request)</span> &#123;<br>         ... ...<br>              <span class="hljs-keyword">case</span> OpCode.multiRead: &#123;<br>                lastOp = <span class="hljs-string">&quot;MLTR&quot;</span>;<br>                <span class="hljs-type">MultiOperationRecord</span> <span class="hljs-variable">multiReadRecord</span> <span class="hljs-operator">=</span> request.readRequestRecord(MultiOperationRecord::<span class="hljs-keyword">new</span>);<br>                rsp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultiResponse</span>();<br>                OpResult subResult;<br>                <span class="hljs-keyword">for</span> (Op readOp : multiReadRecord) &#123;<br>                ... ...<br>                 rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);<br>                            <span class="hljs-type">GetDataResponse</span> <span class="hljs-variable">gdr</span> <span class="hljs-operator">=</span> (GetDataResponse) rec;<br>                ... ...            <br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>handleGetDataRequest</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Record <span class="hljs-title function_">handleGetDataRequest</span><span class="hljs-params">(Record request, ServerCnxn cnxn, List&lt;Id&gt; authInfo)</span> <span class="hljs-keyword">throws</span> KeeperException, IOException &#123;<br>     <span class="hljs-type">GetDataRequest</span> <span class="hljs-variable">getDataRequest</span> <span class="hljs-operator">=</span> (GetDataRequest) request;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> getDataRequest.getPath();<br>     <span class="hljs-type">DataNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> zks.getZKDatabase().getNode(path);<br>     <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeeperException</span>.NoNodeException();<br>     &#125;<br>     zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, <span class="hljs-literal">null</span>);<br>     <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br>     <span class="hljs-type">byte</span>[] b = zks.getZKDatabase().getData(path, stat, getDataRequest.getWatch() ? cnxn : <span class="hljs-literal">null</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetDataResponse</span>(b, stat);<br> &#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>zks.getZKDatabase().getData</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getData(String path, Stat stat, Watcher watcher) <span class="hljs-keyword">throws</span> NoNodeException &#123;<br>    <span class="hljs-type">DataNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nodes.get(path);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoNodeException</span>();<br>    &#125;<br>    <span class="hljs-type">byte</span>[] data;<br>    <span class="hljs-keyword">synchronized</span> (n) &#123;<br>        n.copyStat(stat);<br>        <span class="hljs-keyword">if</span> (watcher != <span class="hljs-literal">null</span>) &#123;<br>            dataWatches.addWatch(path, watcher);<br>        &#125;<br>        data = n.data;<br>    &#125;<br>    updateReadStat(path, data == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : data.length);<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过 dataWatches.addWatch(path, watcher);将 Watch 事件注册到服务端的WatchManager 中</p></blockquote><h2 id="服务端-watch-事件的触发过程">4.3 服务端 Watch事件的触发过程</h2><p>在客户端和服务端都对 watch 注册完成后， ZooKeeper会在特定场景汇总中触发Watch 事件。</p><p>以 <strong>setData</strong>接口即"节点数据内容发生变更"事件为例。</p><ul><li><strong>DataTree-&gt;setData</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Stat <span class="hljs-title function_">setData</span><span class="hljs-params">(String path, <span class="hljs-type">byte</span> data[], ...)</span>&#123;<br><br>        <span class="hljs-type">Stat</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br><br>        <span class="hljs-type">DataNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nodes.get(path);<br><br>        ...<br><br>        dataWatches.triggerWatch(path, EventType.NodeDataChanged);<br><br>        <span class="hljs-keyword">return</span> s;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在 setData 方法内部执行完对节点数据的变更后，会调用WatchManager.triggerWatch 方法触发数据变更事件。</p><ul><li><strong>triggerWatch</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">WatcherOrBitSet <span class="hljs-title function_">triggerWatch</span><span class="hljs-params">(String path, EventType type, WatcherOrBitSet supress)</span> &#123;<br>       <span class="hljs-type">WatchedEvent</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedEvent</span>(type, KeeperState.SyncConnected, path);<br>       Set&lt;Watcher&gt; watchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>       <span class="hljs-type">PathParentIterator</span> <span class="hljs-variable">pathParentIterator</span> <span class="hljs-operator">=</span> getPathParentIterator(path);<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              <span class="hljs-keyword">for</span> (String localPath : pathParentIterator.asIterable()) &#123;<br>               Set&lt;Watcher&gt; thisWatchers = watchTable.get(localPath);<br>               <span class="hljs-keyword">if</span> (thisWatchers == <span class="hljs-literal">null</span> || thisWatchers.isEmpty()) &#123;<br>                   <span class="hljs-keyword">continue</span>;<br>               &#125;<br>               Iterator&lt;Watcher&gt; iterator = thisWatchers.iterator();<br>               <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                   <span class="hljs-type">Watcher</span> <span class="hljs-variable">watcher</span> <span class="hljs-operator">=</span> iterator.next();<br>                   <span class="hljs-type">WatcherMode</span> <span class="hljs-variable">watcherMode</span> <span class="hljs-operator">=</span> watcherModeManager.getWatcherMode(watcher, localPath);<br>                   ... ...<br>                   watchers.add(watcher);<span class="hljs-comment">//添加到定义的 Wathcers 集合中</span><br>               &#125;<br>                  <br>               <span class="hljs-keyword">if</span> (thisWatchers.isEmpty()) &#123;<br>                   watchTable.remove(localPath);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (watchers.isEmpty()) &#123;<br>           ... ...<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span> (Watcher w : watchers) &#123;<br>           <span class="hljs-keyword">if</span> (supress != <span class="hljs-literal">null</span> &amp;&amp; supress.contains(w)) &#123;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           w.process(e);<span class="hljs-comment">//调用 process 方法</span><br>       &#125;<br><br>       <span class="hljs-keyword">return</span> watchers;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>triggerWatch函数内部首先封装了一个具有<code>会话状态</code>、<code>事件类型</code>、<code>数据节点</code>3 种属性的 WatchedEvent 对象。之后查询该节点注册的 Watch事件，如果为空说明该节点没有注册过 Watch 事件。如果存在 Watch事件则添加到定义的 Wathcers 集合中，并在 WatchManager管理中删除。最后，通过调用 process 方法向客户端发送通知。</p><h2 id="客户端回调的处理过程">4.4 客户端回调的处理过程</h2><p>服务器端 Watch事件的触发过程后，客户端接收到通知后就会进行相应处理。</p><p>客户端使用 SendThread.readResponse()方法来统一处理服务端的相应。首先反序列化服务器发送请求头信息replyHdr.deserialize(bbia, "header")，并判断相属性字段 xid 的值为-1，表示该请求响应为通知类型。在处理通知类型时，首先将己收到的字节流反序列化转换成WatcherEvent 对象。接着判断客户端是否配置了 chrootPath 属性，如果为 True说明客户端配置了 chrootPath 属性。需要对接收到的节点路径进行 chrootPath处理。最后调用 eventThread.queueEvent( ）方法将接收到的事件交给EventThread 线程进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">readResponse</span><span class="hljs-params">(ByteBuffer incomingBuffer)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         <span class="hljs-type">ByteBufferInputStream</span> <span class="hljs-variable">bbis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferInputStream</span>(incomingBuffer);<br>         <span class="hljs-type">BinaryInputArchive</span> <span class="hljs-variable">bbia</span> <span class="hljs-operator">=</span> BinaryInputArchive.getArchive(bbis);<br>         <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">replyHdr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplyHeader</span>();<br><br>         replyHdr.deserialize(bbia, <span class="hljs-string">&quot;header&quot;</span>);<span class="hljs-comment">//反序列化服务器发送请求头信息</span><br>         <span class="hljs-keyword">switch</span> (replyHdr.getXid()) &#123;<br>         <span class="hljs-keyword">case</span> PING_XID:<br>           ... ...<br>           <span class="hljs-keyword">return</span>;<br>             <span class="hljs-keyword">case</span> NOTIFICATION_XID:<span class="hljs-comment">//-1:通知类型</span><br>             LOG.debug(<span class="hljs-string">&quot;Got notification session id: 0x&#123;&#125;&quot;</span>,Long.toHexString(sessionId));<br>             <span class="hljs-type">WatcherEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatcherEvent</span>();<br>             event.deserialize(bbia, <span class="hljs-string">&quot;response&quot;</span>);<br><br>             <span class="hljs-comment">// convert from a server path to a client path</span><br>             <span class="hljs-keyword">if</span> (chrootPath != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//判断客户端是否配置了 chrootPath 属性</span><br>                 <span class="hljs-type">String</span> <span class="hljs-variable">serverPath</span> <span class="hljs-operator">=</span> event.getPath();<br>                 <span class="hljs-type">String</span> <span class="hljs-variable">clientPath</span> <span class="hljs-operator">=</span> stripChroot(serverPath);<br>                 event.setPath(clientPath);<br>             &#125;<br><br>             <span class="hljs-type">WatchedEvent</span> <span class="hljs-variable">we</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedEvent</span>(event);<br>             LOG.debug(<span class="hljs-string">&quot;Got &#123;&#125; for session id 0x&#123;&#125;&quot;</span>, we, Long.toHexString(sessionId));<br>             eventThread.queueEvent(we);<span class="hljs-comment">//将接收到的事件交给 EventThread 线程进行处理</span><br>             <span class="hljs-keyword">return</span>;<br>         <span class="hljs-keyword">default</span>:<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>queueEvent</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queueEvent</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>       queueEvent(event, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queueEvent</span><span class="hljs-params">(WatchedEvent event, Set&lt;Watcher&gt; materializedWatchers)</span> &#123;<br>    <span class="hljs-keyword">if</span> (event.getType() == EventType.None &amp;&amp; sessionState == event.getState()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    sessionState = event.getState();<br>    <span class="hljs-keyword">final</span> Set&lt;Watcher&gt; watchers;<br>    <span class="hljs-keyword">if</span> (materializedWatchers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// materialize the watchers based on the event</span><br>        watchers = watchManager.materialize(event.getState(), event.getType(), event.getPath());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        watchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(materializedWatchers);<br>    &#125;<br>    <span class="hljs-type">WatcherSetEventPair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatcherSetEventPair</span>(watchers, event);<br>    <span class="hljs-comment">// queue the pair (watch set &amp; event) for later processing</span><br>    waitingEvents.add(pair);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>materialize</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Set&lt;Watcher&gt; <span class="hljs-title function_">materialize</span><span class="hljs-params">(</span><br><span class="hljs-params">    Watcher.Event.KeeperState state,</span><br><span class="hljs-params">    Watcher.Event.EventType type,</span><br><span class="hljs-params">    String clientPath</span><br><span class="hljs-params">)</span> &#123;<br>    <span class="hljs-keyword">final</span> Set&lt;Watcher&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> None:<br>        ... ...    <br>    <span class="hljs-keyword">case</span> NodeDataChanged:<br>    <span class="hljs-keyword">case</span> NodeCreated:<br>        <span class="hljs-keyword">synchronized</span> (dataWatches) &#123;<br>            addTo(dataWatches.remove(clientPath), result);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (existWatches) &#123;<br>            addTo(existWatches.remove(clientPath), result);<br>        &#125;<br>        addPersistentWatches(clientPath, type, result);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> NodeChildrenChanged:<br>            ... ...<br>    <span class="hljs-keyword">case</span> NodeDeleted:<br>            ... ...<br>    <span class="hljs-keyword">default</span>:<br>            ... ...<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(errorMsg);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会发现此处的Type就是前面的状态：<code>None</code>，<code>NodeDataChanged</code>，<code>NodeCreated</code>，<code>NodeChildrenChanged</code>，<code>NodeDeleted</code>。</p><p>EventThread.queueEvent() 方法内部的执行逻辑。其主要工作分为 2点：</p><ul><li><p>第 1 步按照通知的事件类型，从 ZKWatchManager 中查询注册过的客户端Watch 信息。客户端在查询到对应的 Watch 信息后，会将其从 ZKWatchManager的管理中删除。因此这里多注意，<code>客户端的 Watcher 机制是一次性的，触发后就会被删除</code>。</p></li><li><p>第 2 步获取到对应的 Watcher 信息后，将查询到的 Watcher 存储到waitingEvents 队列中，调用 <code>EventThread</code> 类中的 run方法会循环取出在 <code>waitingEvents</code> 队列中等待的 Watcher事件进行处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressFBWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        isRunning = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> waitingEvents.take();<br>            <span class="hljs-keyword">if</span> (event == eventOfDeath) &#123;<br>                wasKilled = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                processEvent(event);<span class="hljs-comment">//执行实现了 Watcher 接口的 process方法</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (wasKilled) &#123;<br>                <span class="hljs-keyword">synchronized</span> (waitingEvents) &#123;<br>                    <span class="hljs-keyword">if</span> (waitingEvents.isEmpty()) &#123;<br>                        isRunning = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Event thread exiting due to interruption&quot;</span>, e);<br>    &#125;<br><br>    LOG.info(<span class="hljs-string">&quot;EventThread shut down for session: 0x&#123;&#125;&quot;</span>, Long.toHexString(getSessionId()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>processEvent</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processEvent</span><span class="hljs-params">(Object event)</span> &#123;<br>  ... ...<br>  <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> WatcherSetEventPair) &#123;<br>      <span class="hljs-type">WatcherSetEventPair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> (WatcherSetEventPair) event;<br>      <span class="hljs-keyword">for</span> (Watcher watcher : pair.watchers) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              watcher.process(pair.event);<span class="hljs-comment">//执行方法</span><br>          &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>              LOG.error(<span class="hljs-string">&quot;Error while calling watcher &quot;</span>, t);<br>          &#125;<br>      &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> LocalCallback) &#123;<br>      ... ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>processEvent(event) 方法来最终执行实现了 Watcher 接口的process（）方法。</p><h1 id="总结">5. 总结</h1><p>客户端当发送一个带有 Watch事件的请求时，客户端首先会把该会话标记为带有 Watch监控的事件请求，之后通过 <code>DataWatchRegistration</code> 类来保存watcher 事件和节点的对应关系，然后将请求封装成一个 <code>Packet</code>对象，并添加到一个等待发送队列 <code>outgoingQueue</code> 中。</p><p>最后，ZooKeeper客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的<code>SendThread</code> 线程类中的 <code>readResponse</code>方法接收服务端的回调，并在最后执行 <code>finishPacket</code>方法将 Watch注册到 ZKWatchManager 中。</p><hr /><p>当 ZooKeeper服务器接收到一个客户端请求后，首先会对请求进行解析，判断该请求是否包含Watch 事件。这在 ZooKeeper 底层是通过 <code>FinalRequestProcessor</code>类中的 processRequest 函数实现的。当 getDataRequest.getWatch() 值为 True时，表明该请求需要进行 Watch 监控注册。并通过<code>zks.getZKDatabase().getData</code> 函数将 Watch 事件注册到服务端的WatchManager 中。</p><hr /><p>在特定的场合会触发事件，因此调用 WatchManager.triggerWatch方法触发事件。 triggerWatch函数内部首先封装了一个具有<code>会话状态</code>、<code>事件类型</code>、<code>数据节点</code>3 种属性的 WatchedEvent 对象。之后查询该节点注册的 Watch事件，如果为空说明该节点没有注册过 Watch 事件。如果存在 Watch事件则添加到定义的 Wathcers 集合中，并在 WatchManager管理中删除。最后，通过调用 process 方法向客户端发送通知。</p><hr /><p>服务器端 Watch事件的触发过程后，客户端接收到通知后就会进行相应处理。</p><p>客户端使用 SendThread.readResponse()方法来统一处理服务端的相应。首先反序列化服务器发送请求头信息replyHdr.deserialize(bbia, "header")，并判断相属性字段 xid 的值为<code>-1</code>，表示该请求响应为<code>通知类型</code>。在处理通知类型时，首先将己收到的字节流反序列化转换成<code>WatcherEvent</code> 对象。接着判断客户端是否配置了 chrootPath属性，如果为 True 说明客户端配置了 chrootPath属性。需要对接收到的节点路径进行 chrootPath 处理。最后调用eventThread.queueEvent( ）方法将接收到的事件交给 EventThread线程进行处理。其主要工作分为 2 点：</p><ul><li><p>第 1 步按照通知的事件类型，从 ZKWatchManager 中查询注册过的客户端Watch 信息。客户端在查询到对应的 Watch 信息后，会将其从 ZKWatchManager的管理中删除。因此这里多注意，<code>客户端的 Watcher 机制是一次性的，触发后就会被删除</code>。</p></li><li><p>第 2 步获取到对应的 Watcher 信息后，将查询到的 Watcher 存储到waitingEvents 队列中，调用 <code>EventThread</code> 类中的 run方法会循环取出在 <code>waitingEvents</code> 队列中等待的 Watcher事件进行处理。</p></li></ul><h1 id="使用场景">6.使用场景</h1><h2 id="订阅发布场景实现">订阅发布场景实现</h2><p>现在我们已经知道 Watch 事件在 ZooKeeper中的完整处理过程，接下来我们通过一个实际应用来加深我们对 ZooKeeper 中Watch 机制的理解。</p><p>提到 ZooKeeper的应用场景，你可能第一时间会想到最为典型的发布订阅功能。发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。ZooKeeper采用了两种模式结合的方式实现订阅发布功能。下面我们来分析一个具体案例：</p><p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper的发布订阅功能就能解决这个问题。</p><p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper数据节点中。如图中的 /confs/data_item1。服务器集群客户端对该节点添加Watch事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。而当该节点数据发生变化时，ZooKeeper服务器会发送 Watch事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl61INaAJeAEAAA8lZ8lpbE688.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对ZooKeeper服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。<strong>要注意一点是，我们提到Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch事件。</strong></p><h1 id="section">7. 🍪</h1><p>当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？</p><p>否定的，通过本课时对 ZooKeeper 内部实现机制的解析可以知道，Watch事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的Watch 事件。</p><h1 id="read-more">8.Read more</h1><p>:lollipop::<ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/02%20%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Watch%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E7%9F%A5.md">发布订阅模式：如何使用Watch 机制实现分布式通知</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper Leader选举</title>
    <link href="/2022/09/17/framework/zookeeper/2022-09-17_Zookeeper%20Leader%E9%80%89%E4%B8%BE/"/>
    <url>/2022/09/17/framework/zookeeper/2022-09-17_Zookeeper%20Leader%E9%80%89%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper-leader选举">Zookeeper Leader选举</h1><p>Leader 服务器的作用是管理 ZooKeeper集群中的其他服务器。因此，如果是单独一台服务器，不构成集群规模。在ZooKeeper 服务的运行中不会选举 Leader 服务器，也不会作为 Leader服务器运行。</p><p>在前面，我们说过在 ZooKeeper 集群中将服务器分成 <code>Leader</code>、<code>Follow</code> 、<code>Observer</code>三种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p><ul><li>Leader角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者。</li><li>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个Follow 服务器作为新的 Leader 服务器。</li><li>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器。</li></ul><p>本文主要对"<strong>Leader 服务器是如何产生的</strong>"分析。</p><h1 id="leader-服务器的选举原理">1.Leader 服务器的选举原理</h1><p>一个 ZooKeeper服务要想满足集群方式运行，至少需要三台服务器。本课时我们就以三台服务器组成的ZooKeeper 集群为例，介绍一下 Leader 服务器选举的内部过程和底层实现。</p><h2 id="服务启动时的-leader-选举">1.1 服务启动时的 Leader 选举</h2><p>Leader 服务器的选举操作主要发生在两种情况下。</p><ul><li><p>第一种就是 ZooKeeper 集群服务启动的时候</p></li><li><p>第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时</p></li></ul><p>这时 ZooKeeper 集群需要选举出新的 Leader 服务器。我们先来介绍在ZooKeeper 集群服务最初启动的时候，Leader 服务器是如何选举的。</p><p>在 ZooKeeper 集群启动时，需要在集群中的服务器之间确定一台 Leader服务器。当 ZooKeeper集群中的三台服务器启动之后，首先会进行通信检查，如果集群中的服务器之间能够进行通信。集群中的三台机器开始尝试寻找集群中的Leader 服务器并进行数据同步等操作。如何这时没有搜索到 Leader服务器，说明集群中不存在 Leader 服务器。这时 ZooKeeper 集群开始发起Leader 服务器选举。在整个 ZooKeeper 集群中 Leader选举主要可以分为三大步骤分别是：<code>发起投票</code>、<code>接收投票</code>、<code>统计投票</code>。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308162822843.png"alt="image-20230308162822843" /><figcaption aria-hidden="true">image-20230308162822843</figcaption></figure><h3 id="发起投票">1.1.1 发起投票</h3><p>我们先来看一下发起投票的流程，在 ZooKeeper服务器集群初始化启动的时候，<code>集群中的每一台服务器都会将自己作为 Leader 服务器进行投票</code>。<strong>也就是每次投票时，发送的服务器的myid（服务器标识符）和 ZXID(集群投票信息标识符)等选票信息字段都指向本机服务器。</strong>而一个投票信息就是通过这两个字段组成的。以集群中三个服务器<code>Serverhost1</code>、<code>Serverhost2</code>、<code>Serverhost3</code>为例。</p><p>因为是初始化阶段，每一台服务器都会将自己作为leader服务器来投票，所以三个服务器的投票内容分别是：Severhost1的投票是（1，0）、Serverhost2 服务器的投票是（2，0）、Serverhost3服务器的投票是（3，0）。</p><blockquote><p>myid:server都会有一个用于惟一标识自己的id</p><p>zxid:事务id,初始为0</p></blockquote><h3 id="接收投票">1.1.2 接收投票</h3><p>集群中各个服务器在发起投票的同时，也通过网络接收来自集群中其他服务器的投票信息。在接收到网络中的投票信息后，服务器内部首先会判断该条投票信息的有效性。检查该条投票信息的时效性，是否是本轮最新的投票，并检查该条投票信息是否是处于LOOKING 状态的服务器发出的。</p><h3 id="处理投票">1.1.3 处理投票</h3><p>在接收到投票后，ZooKeeper集群就该处理和统计投票结果了。在接收到来自其它服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，pk的规则如下：</p><ul><li>优先检查ZXID，ZXID 数值比较大的投票信息优先作为 Leader 服务器。</li><li>如果每个投票信息中的 ZXID 相同，就会接着比对投票信息中的 myid信息字段，选举出 myid 较大的服务器作为 Leader 服务器。</li></ul><p>拿上面列举的三个服务器组成的集群例子来说，对于 Serverhost1：</p><p>他自己的投票信息是（1，0），该服务器接收到的 Serverhost2服务器的投票信息是（2，0）。在 ZooKeeper集群服务运行的过程中，首先会对比 ZXID，发现结果相同之后，对比 myid，发现Serverhost2 服务器的 myid比较大，于是更新自己的投票信息为（2，0），并重新向 ZooKeeper集群中的服务器发送新的投票信息。而 Serverhost2服务器则保留自身的投票信息，不需要更新自己的投票信息，只是再一次向集群中的所有机器发出上一次投票信息即可。</p><h3 id="统计投票">1.1.4 统计投票</h3><p>每轮投票过后，ZooKeeper服务都会统计集群中服务器的投票结果，<code>判断是否有过半数的机器投出一样的信息</code>。如果存在过半数投票信息指向的服务器，那么该台服务器就被选举为Leader 服务器。比如上面我们举的例子中，ZooKeeper 集群会选举 Severhost2服务器作为 Leader 服务器。</p><h3 id="改变服务器状态">1.1.5 <strong>改变服务器状态</strong></h3><p>一旦确定了leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为Following，并且会与：Leader进行数据同步。如果是Leader，就变更为Leading。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308164521147.png"alt="image-20230308164521147" /><figcaption aria-hidden="true">image-20230308164521147</figcaption></figure><h2 id="服务器运行时期的leader选举">1.2<strong>服务器运行时期的Leader选举</strong></h2><p>除了ZooKeeper 集群启动时 Leader 服务器的选举方法以外，还存在ZooKeeper 集群服务的运行过程中，Leader 服务器进行选举。</p><p>在集群中，一旦Leader确定后，集群中的角色一般不会再发生变化，即使是非Leader集群挂了或者有新的服务器加入也不会有影响，但是<code>当Leader发生宕机了。那么整个集群则无法对外提供服务。则会进入新的Leader选举</code>。ZooKeeper集群在重新选举 Leader时也经过了四个过程(<strong><em>也可以叫5个过程：统计投票包含处理投票</em></strong>)，分别是<code>变更服务器状态</code>、<code>发起投票</code>、<code>接收投票</code>、<code>统计投票</code>。其中，与初始化启动时Leader服务器的选举过程相比，变更状态和发起投票这两个阶段的实现是不同的。下面我们来分别看看这两个阶段。</p><p>现在假设有3台服务器：Severhost1、Severhost2 、Severhost3，当前Leader为Severhost2 且已经挂掉。此时开始Leader选举。</p><h3 id="变更状态">1.2.1 变更状态</h3><p>当 Leader 服务器崩溃后 ，ZooKeeper集群中的其他服务器会首先将自身的状态信息变为 LOOKING状态，该状态表示服务器已经做好选举新 Leader 服务器的准备了，这之后整个ZooKeeper 集群开始进入选举新的 Leader 服务器过程。</p><h3 id="发起投票-1">1.2.2 发起投票</h3><p>ZooKeeper 集群重新选举 Leader服务器的过程中发起投票的过程与初始化启动时发起投票的过程基本相同。首先每个集群中的服务器都会投票给自己，将投票信息中的Zxid 和 myid 分别指向本机服务器。</p><p>在这个过程中，需要生成投票信息(myid,zxid)，因为是运行期间，因此每个服务器上的zxid可能不同，我们假定Severhost1的zxid为123，而Severhost3的zxid为122.在第一轮投票中，Severhost1和Severhost3都会投给自己，即分别产生投票(1, 123)和(3,122)，然后各自将这个投票发给集群中的所有机器。</p><h1 id="底层实现">2.底层实现</h1><p>进行 Leader 头节点的选举操作。而在 ZooKeeper 中提供了三种 Leader选举算法，分别是 <strong>LeaderElection、AuthFastLeaderElection、FastLeaderElection</strong>。在后面的版本中，只支持<code>快速选举</code>这一种算法。</p><p>在代码层面的实现中，QuorumCnxManager 作为核心的实现类，用来管理Leader 服务器与 Follow 服务器的 TCP 通信，以及消息的接收与发送等功能。在QuorumCnxManager 中，主要定义了 ConcurrentHashMap&lt;Long,SendWorker&gt; 类型的 senderWorkerMap数据字段，用来管理每一个通信的服务器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuorumCnxManager</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;<span class="hljs-type">Long</span>, <span class="hljs-type">SendWorker</span>&gt; senderWorkerMap;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;<span class="hljs-type">Long</span>, <span class="hljs-type">ArrayBlockingQueue</span>&lt;<span class="hljs-type">ByteBuffer</span>&gt;&gt; queueSendMap;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;<span class="hljs-type">Long</span>, <span class="hljs-type">ByteBuffer</span>&gt; lastMessageSent;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而在 QuorumCnxManager 类的内部，定义了 RecvWorker内部类。该类继承了一个 ZooKeeperThread类的多线程类。主要负责消息接收。在 ZooKeeper的实现中，为每一个集群中的通信服务器都分配一个RecvWorker，负责接收来自其他服务器发送的信息。在 RecvWorker 的 run函数中，不断通过 queueSendMap 队列读取信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br>  Long sid;<br>  Socket sock;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  DataInputStream din;<br>  <span class="hljs-keyword">final</span> SendWorker sw;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  threadCnt.incrementAndGet();<br>  <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> din.readInt();<br>    <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">0</span> || length &gt; PACKETMAXSIZE) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<br>                <span class="hljs-string">&quot;Received packet with invalid packet: &quot;</span> + length);<br>    &#125;<br>    <span class="hljs-type">byte</span>[] msgArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    din.readFully(msgArray, <span class="hljs-number">0</span>, length);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msgArray);<br>    addToRecvQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(message.duplicate(), sid));<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了接收信息的功能外，QuorumCnxManager 内还定义了一个 SendWorker内部类用来向集群中的其他服务器发送投票信息。如下面的代码所示。在SendWorker 类中，不会立刻将投票信息发送到 ZooKeeper集群中，而是将投票信息首先插入到 pollSendQueue 队列，之后通过 send函数进行发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br><br>  Long sid;<br><br>  Socket sock;<br>  RecvWorker recvWorker;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  DataOutputStream dout;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);<br>        <span class="hljs-keyword">if</span> (bq != <span class="hljs-literal">null</span>) &#123;<br>            b = pollSendQueue(bq, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.error(<span class="hljs-string">&quot;No queue of incoming messages for &quot;</span> + <span class="hljs-string">&quot;server &quot;</span> + sid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b != <span class="hljs-literal">null</span>)&#123;<br>            lastMessageSent.put(sid, b);<br>            send(b);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>        LOG.warn(<span class="hljs-string">&quot;Interrupted while waiting for message on queue&quot;</span>,<br><br>                e);<br>    &#125;<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了投票信息的发送与接收后，接下来我们就来看看如何处理投票结果。在ZooKeeper 的底层，是通过 FastLeaderElection类实现的。如下面的代码所示，在 FastLeaderElection的内部，定义了最大通信间隔 maxNotificationInterval、服务器等待时间finalizeWait 等属性配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastLeaderElection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Election</span> &#123;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxNotificationInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">60000</span>;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">IGNOREVALUE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span><br><br>  QuorumCnxManager manager;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 ZooKeeper 底层通过 getVote函数来设置本机的投票内容，如下图面的代码所示，在 getVote 中通过proposedLeader 服务器信息、proposedZxid 服务器 ZXID、proposedEpoch投票轮次等信息封装投票信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> Vote <span class="hljs-title function_">getVote</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(proposedLeader, proposedZxid, proposedEpoch);<br><br> &#125;<br></code></pre></td></tr></table></figure><p>在完成投票信息的封装以及投票信息的接收和发送后。一个 ZooKeeper集群中，Leader 服务器选举底层实现的关键步骤就已经介绍完了。 Leader节点的底层实现过程的逻辑相对来说比较简单，基本分为封装投票信息、发送投票、接收投票等。</p><h1 id="section">3.🍪</h1><p>崩溃的 Leader 服务器是否会参与本次投票，以及是否能被重新选举为 Leader服务器?</p><blockquote><p>这主要取决于在选举过程中旧的 Leader服务器的运行状态。如果该服务器可以正常运行且可以和集群中其他服务器通信，那么该服务器也会参与新的Leader 服务器的选举，在满足条件的情况下该台服务器也会再次被选举为新的Leader 服务器。</p></blockquote><h1 id="read-more">4.Read more</h1><p>:lollipop:: <ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/15%20ZooKeeper%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%89%E4%B8%AD%20Leader%20%E7%9A%84%EF%BC%9F.md">ZooKeeper究竟是怎么选中 Leader 的？</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACL权限控制</title>
    <link href="/2022/09/14/framework/zookeeper/2022-09-14_ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/09/14/framework/zookeeper/2022-09-14_ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="acl-权限控制">1. ACL 权限控制</h1><p>ZooKeeper 基础知识基本分为三大模块：</p><ul><li>数据模型</li><li>Watch 监控</li><li>ACL 权限控制</li></ul><p>在前面已经讲了<code>数据模型</code>与<code>Watch 监控</code>，现在来讲一下ACL权限控制。</p><p>权限控制相信你一定很熟悉。比如 Linux系统将对文件的使用者分为三种身份，即User、Group、Others。使用者对文件拥有读（read）写（write）以及执行（execute）3种方式的控制权。这种权限控制方式相对比较粗糙，在复杂的授权场景下往往并不适用。比如下边一个应用场景。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl67twGANQ9kAABTpMHtYI0138.png" /></p><p>上图如果使用 Linux 权限来设计，则：</p><p>首先作为技术组长使用 User身份，具有读、写、执行权限。项目组其他成员使用 Group身份，具有读写权限，其他项目组的人员则没有任何权限。这样就实现了满足要求的权限设定了。</p><p>但是针对于Zookeeper来说。Zookeeper有临时节点的特性。比如现在新加入一个实习生，他只有熟悉项目的权限，却没有修改项目的能力。则此时使用的权限规则就无法满足要求。</p><p><strong>ZooKeeper 中的 ACl就能应对这种复杂的权限应用场景</strong></p><h1 id="acl的使用">2.ACL的使用</h1><p>ACL 权限设置通常可以分为 3部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。最终组成一条例如<code>scheme:id:permission</code>格式的ACL 请求信息。</p><h2 id="权限模式scheme">2.1 权限模式（Scheme）</h2><p>权限模式就是用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper的权限验证方式大体分为两种类型:</p><ul><li><p><strong>范围验证</strong></p><p>ZooKeeper 可以针对一个 IP 或者一段 IP地址授予某种权限。比如我们可以让一个 IP地址为“ip：192.168.1.10”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.1.10/22”给<strong>一段IP 地址的机器赋权</strong>。</p></li><li><p><strong>口令验证</strong></p><p>也可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。</p><p>在 ZooKeeper 中这种验证方式是 Digest认证，我们知道通过网络传输相对来说并不安全，所以“绝不通过明文在网络发送密码”也是程序设计中很重要的原则之一，而Digest这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper服务端会对密码 部分使用 SHA-1 和 BASE64算法进行加密，以保证安全性。另一种权限模式 Super 可以认为是一种特殊的Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper上的任意数据节点进行任意操作。下面这段代码给出了 Digest模式下客户端的调用方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">//创建节点<br><br>create /digest_node1<br><br>//设置digest权限验证<br><br>setAcl /digest_node1 digest:用户名:<span class="hljs-built_in">base64</span>格式密码:rwadc <br><br>//查询节点Acl权限<br><br>getAcl /digest_node1 <br><br>//授权操作<br><br>addauth digest user:passwd<br></code></pre></td></tr></table></figure><p>最后一种授权模式是 world模式，其实这种授权模式对应于系统中的所有用户，本质上起不到任何作用。设置了world 权限模式系统中的所有用户操作都可以不进行权限验证。</p></li></ul><h2 id="授权对象id">2.2 授权对象（ID）</h2><p>接下来我们再看一下授权对象部分，其实这个很好理解，所谓的授权对象就是说我们要把权限赋予谁，而对应于4 种不同的权限模式来说，如果我们选择采用 IP方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或Super 方式，则对应于一个用户名。如果是 World模式，是授权系统中所有的用户。</p><h2 id="权限信息permission">2.3 权限信息（Permission）</h2><p>权限就是指我们可以在数据节点上执行的操作种类，如下图所示：在ZooKeeper 中已经定义好的权限有 5 种：</p><ul><li>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li><li>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</li><li>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</li><li>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li><li>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行ACL 权限设置。</li></ul><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl67tw2AbgggAACW3WWz4D4066.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong><em>Mark:</em></strong></p><p><strong>每个节点都有维护自身的 ACL权限数据，即使是该节点的子节点也是有自己的 ACL权限而不是直接继承其父节点的权限</strong>。如下中“172.168.11.1”服务器有“/Config”节点的读取权限，但是没有其子节的“/Config/dataBase_Config1”权限。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl67txWALBicAABysKoJmFg484.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="权限扩展">2.4 权限扩展</h2><p>虽然 ZooKeeper自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p><p>官方文档中对这种机制的定义是<code>Pluggable ZooKeeper Authenication</code>，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。要想实现自定义的权限控制机制，最核心的一点是实现ZooKeeper 提供的权限控制器接口 <code>AuthenticationProvider</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AuthenticationProvider</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The String used to represent this provider. This will correspond to the</span><br><span class="hljs-comment">     * scheme field of an Id.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the scheme of this provider.</span><br><span class="hljs-comment">     * 用于表示此提供程序的字符串。这将对应于Id的scheme字段。</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">getScheme</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called when a client passes authentication data for this</span><br><span class="hljs-comment">     * scheme. The authData is directly from the authentication packet. The</span><br><span class="hljs-comment">     * implementor may attach new ids to the authInfo field of cnxn or may use</span><br><span class="hljs-comment">     * cnxn to send packets back to the client.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cnxn</span><br><span class="hljs-comment">     *                the cnxn that received the authentication information.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authData</span><br><span class="hljs-comment">     *                the authentication data received.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> TODO</span><br><span class="hljs-comment">     * 当客户端传递此方案的身份验证数据时，将调用此方法。authData直接来自认证报文。实现者可以将新的id附加到cnxn的authInfo字段，也可以使用cnxn将包发送回客户端</span><br><span class="hljs-comment">     */</span><br>    KeeperException.Code <span class="hljs-title function_">handleAuthentication</span><span class="hljs-params">(ServerCnxn cnxn, <span class="hljs-type">byte</span>[] authData)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called when admin server command passes authentication data for this</span><br><span class="hljs-comment">     * scheme.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     *                the request that contains the authentication information.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authData</span><br><span class="hljs-comment">     *                the authentication data received.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Ids</span><br><span class="hljs-comment">     *                the list of Id. Empty list means not authenticated</span><br><span class="hljs-comment">     * 当管理服务器命令为此方案传递身份验证数据时，将调用此方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> List&lt;Id&gt; <span class="hljs-title function_">handleAuthentication</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-type">byte</span>[] authData)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called to see if the given id matches the given id</span><br><span class="hljs-comment">     * expression in the ACL. This allows schemes to use application specific</span><br><span class="hljs-comment">     * wild cards.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     *                the id to check.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> aclExpr</span><br><span class="hljs-comment">     *                the expression to match ids against.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if the id can be matched by the expression.</span><br><span class="hljs-comment">     * 调用此方法以查看给定id是否与ACL中的给定id表达式匹配。这允许方案使用特定于应用程序的通配符。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String id, String aclExpr)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is used to check if the authentication done by this provider</span><br><span class="hljs-comment">     * should be used to identify the creator of a node. Some ids such as hosts</span><br><span class="hljs-comment">     * and ip addresses are rather transient and in general don&#x27;t really</span><br><span class="hljs-comment">     * identify a client even though sometimes they do.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if this provider identifies creators.</span><br><span class="hljs-comment">     * 此方法用于检查此提供程序完成的身份验证是否应用于标识节点的创建者。一些id，如主机和ip地址，是相当短暂的，通常不能真正识别客户端，即使有时它们可以。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAuthenticated</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Validates the syntax of an id.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     *                the id to validate.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if id is well formed.</span><br><span class="hljs-comment">     * 验证id的语法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;param&gt;id&lt;/param&gt; represents the authentication info which is set in server connection.</span><br><span class="hljs-comment">     * id may contain both user name as well as password.</span><br><span class="hljs-comment">     * This method should be implemented to extract the user name.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id authentication info set by client.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> String user name</span><br><span class="hljs-comment">     * 表示在服务器连接中设置的身份验证信息。Id可能包含用户名和密码。应该实现这个方法来提取用户名。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-comment">// Most of the authentication providers id contains only user name.</span><br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现了自定义权限后，如何才能让 ZooKeeper服务端使用自定义的权限验证方式呢？接下来就需要将自定义的权限控制注册到ZooKeeper 服务器中，而注册的方式通常有两种。</p><p>第一种是通过设置系统属性来注册自定义的权限控制器：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Dzookeeper.authProvider.x</span>=<span class="hljs-string">CustomAuthenticationProvider</span><br></code></pre></td></tr></table></figure><p>另一种是在配置文件 zoo.cfg 中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">authProvider.x</span>=<span class="hljs-string">CustomAuthenticationProvider</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义ACL此处不会详细讲解，感兴趣的盆友可以自己查询相关资料。</p></blockquote><h1 id="acl-内部实现原理">3. ACL 内部实现原理</h1><h2 id="客户端处理过程">3.1 客户端处理过程</h2><p>以节点授权 addAuth 接口为例，首先客户端通过 ClientCnxn 类中的addAuthInfo 方法向服务端发送 ACL 权限信息变更请求，该方法首先将 scheme和 auth 封装成 AuthPacket 类，并通过 RequestHeader方法表示该请求是权限操作请求，最后将这些数据统一封装到 packet中，并添加到 outgoingQueue 队列中发送给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAuthInfo</span><span class="hljs-params">(String scheme, <span class="hljs-type">byte</span>[] auth)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!state.isAlive()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    authInfo.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthData</span>(scheme, auth));<br>    queuePacket(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeader</span>(ClientCnxn.AUTHPACKET_XID, OpCode.auth),<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthPacket</span>(<span class="hljs-number">0</span>, scheme, auth),<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>queuePacket( RequestHeader h, ReplyHeader r, Record request, Recordresponse, AsyncCallback cb, String clientPath, String serverPath, Objectctx, WatchRegistration watchRegistration, WatchDeregistrationwatchDeregistration)</p><p>这个方法我们在讲Watcher机制的时候讲过，就是讲数据封装到packet中，然后添加到outgoingQueue队列中发送给服务端。</p></blockquote><h2 id="服务端实现过程">3.2 服务端实现过程</h2><p>相比于客户端的处理过程，服务器端对 ACL内部实现就比较复杂，当节点授权请求发送到服务端后，在服务器的处理中首先调用readRequest（）方法作为服务器处理的入口，其内部只是调用 processPacket方法。</p><p><strong>NIOServerCnxn:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">RequestHeader</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeader</span>();<br>        ByteBufferInputStream.byteBuffer2Record(incomingBuffer, h);<br>        <span class="hljs-type">RequestRecord</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestRecord.fromBytes(incomingBuffer.slice());<br>        zkServer.processPacket(<span class="hljs-built_in">this</span>, h, request);<br>    &#125;<br></code></pre></td></tr></table></figure><p>而在 processPacket 方法的内部，首先反序列化客户端的请求信息并封装到AuthPacket 对象中。之后通过 getServerProvider 方法根据不同的 scheme判断具体的实现类。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> processPacket(ServerCnxn cnxn, RequestHeader h, RequestRecord request) throws IOException &#123;<br><span class="hljs-params">...</span> <span class="hljs-params">...</span><br>  <span class="hljs-keyword">if</span> (h.getType() == OpCode.auth) &#123;<br>           <span class="hljs-params">...</span> <span class="hljs-params">...</span><br>           AuthPacket authPacket = request.readRecord(AuthPacket<span class="hljs-type">::new</span>);<br>           <span class="hljs-built_in">String</span> scheme = authPacket.getScheme();<br>           ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);<br>           Code authReturn = KeeperException.Code.AUTHFAILED;<br>           <span class="hljs-keyword">if</span> (ap != <span class="hljs-built_in">null</span>) &#123;<br>                   authReturn = ap.handleAuthentication(<br>                       <span class="hljs-literal">new</span> ServerAuthenticationProvider.ServerObjs(this, cnxn),<br>                       authPacket.getAuth());<br>                 <span class="hljs-params">...</span> <span class="hljs-params">...</span><br>               &#125;<br>        &#125;<br>    <span class="hljs-params">...</span> <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>authReturn == KeeperException.Code.OK表明权限验证成功。</p></blockquote><h2 id="digest-模式验证">3.3 Digest 模式验证</h2><p>这里我们使用 Digest 模式为例，因此该实现类是DigestAuthenticationProvider 。之后调用其<code>handleAuthentication()</code> 方法进行权限验证。如果返KeeperException.Code.OK则表示该请求已经通过了权限验证，如果返回的状态是其他或者抛出异常则表示权限验证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> KeeperException.Code <span class="hljs-title function_">handleAuthentication</span><span class="hljs-params">(ServerCnxn cnxn, <span class="hljs-type">byte</span>[] authData)</span> &#123;<br>    <span class="hljs-keyword">final</span> List&lt;Id&gt; ids = handleAuthentication(authData);<br>    <span class="hljs-keyword">if</span> (ids.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> KeeperException.Code.AUTHFAILED;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Id id : ids) &#123;<br>        cnxn.addAuthInfo(id);<br>    &#125;<br>    <span class="hljs-keyword">return</span> KeeperException.Code.OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>handleAuthentication</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> List&lt;Id&gt; handleAuthentication(<span class="hljs-keyword">final</span> byte[] authData) &#123;<br>     <span class="hljs-keyword">final</span> List&lt;Id&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> id = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(authData);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> digest = generateDigest(id);<br>         <span class="hljs-keyword">if</span> (digest.equals(superDigest)) &#123;<br>             ids.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Id</span>(<span class="hljs-string">&quot;super&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>         &#125;<br>         ids.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Id</span>(getScheme(), digest));<br>     &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> NoSuchAlgorithmException e) &#123;<br>         LOG.error(<span class="hljs-string">&quot;Missing algorithm&quot;</span>, e);<br>     &#125;<br>     <span class="hljs-keyword">return</span> Collections.unmodifiableList(ids);<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="addauthinfo">4.addAuthInfo</h1><p>重点讲解一下 addAuthInfo函数，其作用是<code>将解析到的权限信息存储到 ZooKeeper 服务器的内存中</code>，该信息在整个会话存活期间一直会保存在服务器上，如果会话关闭，该信息则会被删，<strong>这个特性很像我们之前学过的数据节点中的临时节点</strong>。</p><p>经过上面的步骤，服务器已经将客户端 ACL请求解析并将对应的会话权限信息存储在服务器上，下面我们再看一下服务器是如何进行权限验证的。</p><p>首先，在处理一次权限请求时，先通过 PrepRequestProcessor 中的 checkAcl函数检查对应的请求权限，</p><ul><li><p>如果该节点没有任何权限设置则直接返回</p></li><li><p>如果该节点有权限设置则循环遍历节点信息进行检查</p></li></ul><p>如果具有相应的权限则直接返回表明权限认证成功，否则最后抛出NoAuthException 异常中断操作表明权限认证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkACL</span><span class="hljs-params">(...)</span>&#123;<br><br>  ...<br><br>  <span class="hljs-keyword">for</span> (ACL a : acl) &#123;<br><br>    <span class="hljs-keyword">if</span>(authId.getScheme().equals(id.getScheme()..)&#123;<br><br>      <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeeperException</span>.NoAuthException();<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">5.总结</h1><p>到目前为止我们对 ACL 权限在 ZooKeeper服务器客户端和服务端的底层实现过程进行了深度的分析。总体来说，客户端在ACL权限请求发送过程的步骤比较简单：<code>首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。</code>本课时的例子采用了授权接口addAuth 而没有采用权限设置接口setAcl，是因为权限设置接口相对简单，其核心功能点已经包括在授权接口实现中。而在授权接口中，<strong>值得注意的是会话的授权信息存储在ZooKeeper服务端的内存中，如果客户端会话关闭，授权信息会被删除。下次连接服务器后，需要重新调用授权接口进行授权。</strong></p><h1 id="section">6.🍪</h1><p>如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。对其创建的节点要想进行修改应该怎么做呢？</p><blockquote><p>我们可以通过“super模式”即超级管理员的方式删除该节点或变更该节点的权限验证方式。正因为“super模式”有如此大的权限，我们在平时使用时也应该更加谨慎。</p></blockquote><h1 id="read-more">8.Read more</h1><p>:lollipop::<ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/03%20ACL%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%9C%AA%E7%BB%8F%E6%8E%88%E6%9D%83%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9F.md">ACL权限控制</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper启动流程</title>
    <link href="/2022/09/12/framework/zookeeper/2022-09-12_zookeeper%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/09/12/framework/zookeeper/2022-09-12_zookeeper%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器初始化到对外提供服务">服务器初始化到对外提供服务</h1><p>前面讲解了Zookeeper的基础知识，其实还涉及到Zookeeper-jute序列化，网络通信协议还没有讲。现在来讲讲ZooKeeper 中的启动与服务的初始化过程，来学习 ZooKeeper服务端相关的处理知识</p><h1 id="单机版">2.单机版</h1><p>我们在启动Zookeeper的时候，都会将<code>zoo_sample.cfg</code>文件复制重新命名为<code>zoo.cfg</code>，如下：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308140602652.png"alt="image-20230308140602652" /><figcaption aria-hidden="true">image-20230308140602652</figcaption></figure><h2 id="启动准备实现">2.1 启动准备实现</h2><p>ZooKeeper服务的初始化之前，首先要对配置文件等信息进行解析和载入。也就是在真正开始服务的初始化之前需要对服务的相关参数进行准备，而ZooKeeper服务的准备阶段大体上可分为<code>启动程序入口</code>、<code>zoo.cfg 配置文件解析</code>、<code>创建历史文件清理器</code>等，如下图所示：</p><p><img src="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308140659021.png" alt="image-20230308140659021" style="zoom:67%;" /></p><p><code>QuorumPeerMain</code> 类是 ZooKeeper 服务的启动接口，可以理解为Java 中的 main 函数。 通常我们在控制台启动 ZooKeeper 服务的时候，输入zkServer.cm 或 zkServer.sh 命令就是用来启动这个 Java类的。如下代码所示，QuorumPeerMain 类函数只有一个 initializeAndRun方法，是作用为所有 ZooKeeper 服务启动逻辑的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * When the main() method of this class is used to start the program, the first</span><br><span class="hljs-comment"> * argument is used as a path to the config file, which will be used to obtain</span><br><span class="hljs-comment"> * configuration information. This file is a Properties file, so keys and</span><br><span class="hljs-comment"> * values are separated by equals (=) and the key/value pairs are separated</span><br><span class="hljs-comment"> * by new lines. The following is a general summary of keys used in the</span><br><span class="hljs-comment"> * configuration file. For full details on this see the documentation in</span><br><span class="hljs-comment"> * docs/index.html</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *当使用该类的main()方法启动程序时，第一个参数将用作配置文件的路径，该配置文件将用于获取配置信息。该文件是一个   Properties文件，因此键和值用等号(=)分隔，键值对用新行分隔。下面是配置文件中使用的密钥的一般摘要。有关这方   面的详细信息，请参阅docsindex.html中的文档</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuorumPeerMain</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(QuorumPeerMain.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Usage: QuorumPeerMain configfile&quot;</span>;<br><br>    <span class="hljs-keyword">protected</span> QuorumPeer quorumPeer;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * To start the replicated server specify the configuration file name on</span><br><span class="hljs-comment">     * the command line.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args path to the configfile</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">QuorumPeerMain</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuorumPeerMain</span>();<br>        ... ...<br>        main.initializeAndRun(args);<br>        ... ... <br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="解析配置文件">2.2 解析配置文件</h2><p>上文写到<code>当使用该类的main()方法启动程序时，第一个参数将用作配置文件的路径，该配置文件将用于获取配置信息</code>，因此在ZooKeeper 启动过程中，首先要做的事情就是解析配置文件 zoo.cfg。</p><blockquote><p>zoo.cfg是服务端的配置文件，在这个文件中我们可以配置数据目录、端口号等信息。</p></blockquote><h2 id="创建文件清理器">2.3 创建文件清理器</h2><p>文件清理器在我们日常的使用中非常重要，我们都知道面对大流量的网络访问，ZooKeeper会因此产生海量的数据，如果磁盘数据过多或者磁盘空间不足，则会导致ZooKeeper服务器不能正常运行，进而影响整个分布式系统。所以面对这种问题，ZooKeeper采用了 <code>DatadirCleanupManager</code>类作为历史文件的清理工具类。</p><p>在 3.4.0 版本后的 ZooKeeper中更是增加了自动清理历史数据的功能以尽量避免磁盘空间的浪费(我是用的版本为3.9.0-SNAPSHOT)。</p><p>如下代码所示，DatadirCleanupManager 类有 5 个属性，其中 snapDir 和dataLogDir分别表示数据快照地址以及日志数据的存放地址。而我们在日常工作中可以通过在zoo.cfg 文件中配置 autopurge.snapRetainCount 和 autopurge.purgeInterval这两个参数实现数据文件的定时清理功能，autopurge.purgeInterval这个参数指定了清理频率，以小时为单位，需要填写一个 1或更大的整数，默认是0，表示不开启自己清理功能。autopurge.snapRetainCount这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目，默认是保留3 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatadirCleanupManager</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Status of the dataDir purge task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PurgeTaskStatus</span> &#123;<br>        NOT_STARTED,<br>        STARTED,<br>        COMPLETED<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File snapDir;<span class="hljs-comment">//数据快照地址</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File dataLogDir;<span class="hljs-comment">//日志数据的存放地址</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> snapRetainCount;<span class="hljs-comment">//需要保留的文件数目，默认是保留 3 个</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> purgeInterval;<span class="hljs-comment">//清理频率，以小时为单位,需要填写一个 1 或更大的整数，默认是 0</span><br><br>    <span class="hljs-keyword">private</span> Timer timer;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="服务初始化">2.4 服务初始化</h2><p>经过了上面的配置文件解析等准备阶段后， ZooKeeper开始服务的初始化阶段。<strong>初始化阶段可以理解为根据解析准备阶段的配置信息，实例化服务对象。服务初始化阶段的主要工作是创建用于服务统计的工具类</strong>，如下图所示主要有以下几种：</p><ol type="1"><li>ServerStats 类，它可以用于服务运行信息统计；</li><li>FileTxnSnapLog 类，可以用于数据管理。</li><li>会话管理类，设置服务器 TickTime和会话超时时间、创建启动会话管理器等操作。</li></ol><p><img src="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308143210537.png" alt="image-20230308143210537" style="zoom:67%;" /></p><h3 id="serverstats">2.4.1 ServerStats</h3><p>ServerStats是一个统计工具类，用于统计 ZooKeeper服务运行时的状态信息统计。主要统计的数据有<code>服务端向客户端发送的响应包次数</code>、<code>接收到的客户端发送的请求包次数</code>、<code>服务端处理请求的延迟情况</code>以及<code>处理客户端的请求次数</code>等。在日常运维工作中，监控服务器的性能以及运行状态等参数很多都是这个类负责收集的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerStats</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">packetsSent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">packetsReceived</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AvgMinMaxCounter</span> <span class="hljs-variable">requestLatency</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AvgMinMaxCounter</span>(<span class="hljs-string">&quot;request_latency&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">fsyncThresholdExceedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BufferStats</span> <span class="hljs-variable">clientResponseStats</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferStats</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">nonMTLSRemoteConnCntr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">nonMTLSLocalConnCntr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">authFailedCntr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="filetxnsnaplog">2.4.2 FileTxnSnapLog</h3><p>FileTxnSnapLog是一个持久化工具类，用来管理 ZooKeeper的数据存储等相关操作，可以看作为 ZooKeeper服务层提供底层持久化的接口。在 ZooKeeper 服务启动过程中，它会根据zoo.cfg 配置文件中的 dataDir 数据快照目录和 dataLogDir事物日志目录来创建 FileTxnSnapLog 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTxnSnapLog</span> &#123;<br>    <span class="hljs-comment">//the directory containing the</span><br>    <span class="hljs-comment">//the transaction logs</span><br>    <span class="hljs-keyword">final</span> File dataDir;<br>    <span class="hljs-comment">//the directory containing the</span><br>    <span class="hljs-comment">//the snapshot directory</span><br>    <span class="hljs-keyword">final</span> File snapDir;<br>    TxnLog txnLog;<br>    SnapShot snapLog;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> autoCreateDB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> trustEmptySnapshot;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VERSION</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;version-&quot;</span>;<br>  &#125;  <br></code></pre></td></tr></table></figure><h3 id="servercnxnfactory">2.4.3 ServerCnxnFactory</h3><p>ServerCnxnFactory是一个NIO类，ZooKeeper中客户端和服务端通过网络通信，其本质是通过 Java 的 IO数据流的方式进行通信，但是传统的 IO 方式具有阻塞等待的问题，而 NIO框架作为传统的 Java IO框架的替代方案，在性能上大大优于前者。也正因如此，NIO框架也被广泛应用于网络传输的解决方案中。而 ZooKeeper最早也是使用自己实现的 NIO 框架.</p><blockquote><p>但是从 3.4.0 版本后，引入了第三方 Netty等框架来满足不同使用情况的需求，而我们可以通过 ServerCnxnFactory类来设置 ZooKeeper 服务器，从而在运行的时候使用我们指定的 NIO 框架。</p></blockquote><p>如代码中 ServerCnxnFactory 类通过setServerCnxnFactory函数来创建对应的工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerCnxnFactory</span> &#123;<br>    <br>  <span class="hljs-comment">// Tells whether SSL is enabled on this ServerCnxnFactory</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> secure;<br>    <br>    <span class="hljs-keyword">protected</span> ZooKeeperServer zkServer;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZooKeeperServer</span><span class="hljs-params">(ZooKeeperServer zks)</span> &#123;<br>      <span class="hljs-built_in">this</span>.zkServer = zks;<br>      <span class="hljs-keyword">if</span> (zks != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">if</span> (secure) &#123;<br>             zks.setSecureServerCnxnFactory(<span class="hljs-built_in">this</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             zks.setServerCnxnFactory(<span class="hljs-built_in">this</span>);<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在通过 ServerCnxnFactory 类制定了具体的 NIO 框架类后。ZooKeeper首先会创建一个线程 Thread 类作为 ServerCnxnFactory 类的启动主线程。之后ZooKeeper 服务再初始化具体的 NIO类。这里请你注意的是，虽然初始化完相关的 NIO 类，比如已经设置好了服务端的对外端口，客户端也能通过诸如 2181端口等访问到服务端，但是此时 ZooKeeper服务器还是无法处理客户端的请求操作。<strong>这是因为 ZooKeeper启动后，还需要从本地的快照数据文件和事务日志文件中恢复数据</strong>。这之后才真正完成了ZooKeeper 服务的启动。</p><h2 id="初始化请求处理链">2.5 初始化请求处理链</h2><p>在完成了 ZooKeeper 服务的启动后，ZooKeeper会初始化一个请求处理逻辑上的相关类。这个操作就是初始化请求处理链。所谓的请求处理链是一种责任链模式的实现方式，根据不同的客户端请求，在ZooKeeper服务器上会采用不同的处理逻辑。而为了更好地实现这种业务场景，ZooKeeper中采用多个请求处理器类一次处理客户端请求中的不同逻辑部分。这种处理请求的逻辑方式就是责任链模式。而本课时主要说的是单机版服务器的处理逻辑，主要分为PrepRequestProcessor、SyncRequestProcessor、FinalRequestProcessor3 个请求处理器，而在一个请求到达 ZooKeeper服务端进行处理的过程，则是严格按照这个顺序分别调用这 3个类处理请求中的对应逻辑，如下图所示。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308151250635.png"alt="image-20230308151250635" /><figcaption aria-hidden="true">image-20230308151250635</figcaption></figure><h1 id="集群版">3.集群版</h1><h2 id="集群模式特点">3.1 集群模式、特点</h2><p>为了解决单机模式下性能的瓶颈问题，以及出于对系统可靠性的高要求，集群模式的系统架构方式被业界普遍采用。那什么是集群模式呢？<code>集群模式可以简单理解为将单机系统复制成几份，部署在不同主机或网络节点上，最终构成了一个由多台计算机组成的系统“集群”。而组成集群中的每个服务器叫作集群中的网络节点。</code></p><p>到现在我们对集群的组织架构形式有了大概的了解，那么你可能会产生一个问题：我们应该如何使用集群？当客户端发送一个请求到集群服务器的时候，究竟是哪个机器为我们提供服务呢？为了解决这个问题，我们先介绍一个概念名词“<code>调度者</code>”。<strong>调度者的工作职责就是在集群收到客户端请求后，根据当前集群中机器的使用情况，决定将此次客户端请求交给哪一台服务器或网络节点进行处理</strong>，例如我们都很熟悉的负载均衡服务器就是一种调度者的实现方式。</p><p><strong>特点：</strong></p><p>在 ZooKeeper 集群模式中，将服务器分成 Leader 、Follow 、Observer三种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p><ul><li>Leader角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者。</li><li>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个Follow 服务器作为新的 Leader 服务器。</li><li>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器。</li></ul><h2 id="启动准备实现-1">3.2 启动准备实现</h2><p>同单机版启动一样，ZooKeeper 服务启动会调用入口 QuorumPeerMain 类中的main 函数。在 main 函数中的 initializeAndRun 方法中根据 zoo.cfg配置文件，判断服务启动方式是集群模式还是单机模式。在函数中首先根据 arg参数和 config.isDistributed() 来判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeAndRun</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException &#123;<br>    <span class="hljs-type">QuorumPeerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuorumPeerConfig</span>();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>        config.parse(args[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// Start and schedule the the purge task</span><br>    <span class="hljs-type">DatadirCleanupManager</span> <span class="hljs-variable">purgeMgr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatadirCleanupManager</span>(<br>        config.getDataDir(),<br>        config.getDataLogDir(),<br>        config.getSnapRetainCount(),<br>        config.getPurgeInterval());<br>    purgeMgr.start();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span> &amp;&amp; config.isDistributed()) &#123;<br>        <span class="hljs-comment">//集群模式，完成之后的集群模式的初始化工作</span><br>        runFromConfig(config);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Either no config or no quorum defined in config, running in standalone mode&quot;</span>); <span class="hljs-comment">//单机模式</span><br>        ZooKeeperServerMain.main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="quorumpeer">3.2.1 QuorumPeer</h3><p>在 ZooKeeper 服务的集群模式启动过程中，一个最主要的核心类是QuorumPeer 类。</p><blockquote><p>我们可以将每个 QuorumPeer 类的实例看作集群中的一台服务器。</p></blockquote><p>在 ZooKeeper 集群模式的运行中，一个 QuorumPeer 类的实例通常具有 3种状态，分别是参与 Leader 节点的选举、作为 Follow 节点同步 Leader节点的数据，以及作为 Leader 节点管理集群中的 Follow 节点。</p><p>介绍完 QuorumPeer 类后，下面我们看一下在 ZooKeeper服务的启动过程中，针对 QuorumPeer类都做了哪些工作。如下面的代码所示，在一个 ZooKeeper服务的启动过程中，首先调用 runFromConfig函数将服务运行过程中需要的核心工具类注册到 QuorumPeer 实例中去。</p><p>这些核心工具就是我们在上一节课单机版服务的启动中介绍的诸如FileTxnSnapLog 数据持久化类、ServerCnxnFactory 类 NIO工厂方法等。这之后还需要配置服务器地址列表、Leader选举算法、会话超时时间等参数到 QuorumPeer 实例中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runFromConfig</span><span class="hljs-params">(QuorumPeerConfig config)</span>&#123;<br><br>  <span class="hljs-type">ServerCnxnFactory</span> <span class="hljs-variable">cnxnFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-type">ServerCnxnFactory</span> <span class="hljs-variable">secureCnxnFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  ...<br><br>  quorumPeer = getQuorumPeer()<br><br>  quorumPeer.setElectionType(config.getElectionAlg());<br><br>  quorumPeer.setCnxnFactory(cnxnFactory);<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>ZooKeeper 将集群中的机器分为 Leader 、 Follow 、Obervser三种角色，每种角色服务器在集群中起到的作用都各不相同。在 ZooKeeper中的这三种角色服务器，在服务启动过程中也有各自的不同，下面我们就以Leader 角色服务器的启动和 Follow服务器服务的启动过程来看一下各自的底层实现原理。</p><h3 id="leader-服务器启动过程">3.2.2 Leader 服务器启动过程</h3><p>在 ZooKeeper 集群中，Leader服务器负责管理集群中其他角色服务器，以及处理客户端的数据变更请求。因此，在整个ZooKeeper 服务器中，Leader 服务器非常重要。所以在整个 ZooKeeper集群启动过程中，首先要先选举出集群中的 Leader 服务器。</p><p>在 ZooKeeper 集群选举 Leader节点的过程中，首先会根据服务器自身的服务器 ID（SID）、最新的ZXID、和当前的服务器 epoch（currentEpoch）这三个参数来生成一个选举标准。之后，ZooKeeper 服务会根据zoo.cfg 配置文件中的参数，选择参数文件中规定的 Leader 选举算法，进行Leader 头节点的选举操作。而在 ZooKeeper 中提供了三种 Leader选举算法，分别是 LeaderElection、AuthFastLeaderElection、FastLeaderElection。在我们日常开发过程中，可以通过在zoo.cfg 配置文件中使用 electionAlg参数属性来制定具体要使用的算法类型。具体的 Leader选举算法我们会在之后的章节中展开讲解。</p><p>这里我们只需要知道，在 ZooKeeper集群模式下服务启动后。首先会创建用来选举 Leader 节点的工具类QuorumCnxManager 。下面这段代码给出了 QuorumCnxManager在创建实例的时候首先要实例化 Listener 对象用于监听 Leader 选举端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.zookeeper.server.quorum;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuorumCnxManager</span> &#123;<br><br>...<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">QuorumCnxManager</span><span class="hljs-params">(QuorumPeer self)</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cnxToValue</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;zookeeper.cnxTimeout&quot;</span>)<br><br>    listener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>();<br><br>    listener.setName(<span class="hljs-string">&quot;QuorumPeerListener&quot;</span>);<br><br>  &#125;<br><br> ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而在 ZooKeeper 中，Leader选举的大概过程，总体说来就是在集群中的所有机器中直接进行一次选举投票，选举出一个最适合的机器作为Leader 节点。而具体的评价标准就是我们上面提到的三种选举算法。而从 3.4.0版本开始，ZooKeeper 只支持 FastLeaderElection这一种选举算法。同时没有被选举为 Leader 节点的机器则作为 Follow 或Observer 节点机器存在。</p><h3 id="follow-服务器启动过程">3.2.3 Follow 服务器启动过程</h3><p>在服务器的启动过程中，Follow 机器的主要工作就是和 Leader节点进行数据同步和交互。当 Leader 机器启动成功后，Follow节点的机器会收到来自 Leader 节点的启动通知。而该通知则是通过LearnerCnxAcceptor类来实现的。该类就相当于一个接收器。专门用来接收来自集群中 Leader节点的通知信息。下面这段代码中 LearnerCnxAcceptor 类首先初始化要监听的Leader 服务器地址和设置收到监听的处理执行方法等操作 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LearnerCnxAcceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperCriticalThread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LearnerCnxAcceptor</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;LearnerCnxAcceptor-&quot;</span> + ss.getLocalSocketAddress(), zk<br><br>                .getZooKeeperServerListener());<br><br>    &#125;<br><br> &#125;   <br></code></pre></td></tr></table></figure><p>在接收到来自 Leader 服务器的通知后，Follow 服务器会创建一个LearnerHandler 类的实例，用来处理与 Leader 服务器的数据同步等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.zookeeper.server.quorum;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LearnerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Socket sock;<br><br>  <span class="hljs-keyword">final</span> Leader leader;<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在完成数据同步后，一个 ZooKeeper服务的集群模式下启动的关键步骤就完成了，整个服务就处于运行状态，可以对外提供服务了。</p><h1 id="section">4.🍪</h1><p>在我们日常使用 ZooKeeper集群服务器的时候，集群中的机器个数应该如何选择？</p><blockquote><p>最好使用奇数原则，最小的集群配置应该是三个服务器或者节点。而如果采用偶数，在Leader节点选举投票的过程中就不满足大多数原则，这时就产生“脑裂”这个问题。</p></blockquote><h1 id="read-more">5.Read more</h1><p>:lollipop::<ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/08%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%EF%BC%9F.md">服务启动过程</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper简介</title>
    <link href="/2022/09/11/framework/zookeeper/2022-09-11_zookeeper%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/11/framework/zookeeper/2022-09-11_zookeeper%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230306150013020.png" /></p><h1 id="what-is-zookeeper">1. What is ZooKeeper?</h1><p>ZooKeeper 是 Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p><a href="https://zookeeper.apache.org/">Zookeeper官网:</a></p><p><ahref="https://zookeeper.apache.org/doc/r3.6.0/zookeeperProgrammers.html">Zookeeper官方文档:</a></p><p>ZooKeeper is a centralized service for maintaining configurationinformation, naming, providing distributed synchronization, andproviding group services. All of these kinds of services are used insome form or another by distributed applications. Each time they areimplemented there is a lot of work that goes into fixing the bugs andrace conditions that are inevitable. Because of the difficulty ofimplementing these kinds of services, applications initially usuallyskimp on them, which make them brittle in the presence of change anddifficult to manage. Even when done correctly, different implementationsof these services lead to management complexity when the applicationsare deployed.</p><p>Learn more about ZooKeeper on the <ahref="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index">ZooKeeperWiki</a>.</p><blockquote><p>简而言之：ZooKeeper是一个用于维护配置信息、命名、提供分布式同步和提供组服务的集中式服务。</p></blockquote><h2 id="设计目标">1.2设计目标</h2><h3 id="zookeeper-is-simple">1.2.1 <strong>ZooKeeper issimple</strong></h3><p>ZooKeeper允许分布式进程通过类似于标准文件系统组织的共享分层命名空间相互协调。命名空间由数据寄存器组成——用ZooKeeper 的说法称为znodes——它们类似于文件和目录。与为存储而设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟数。</p><p>ZooKeeper实现非常重视高性能、高可用性、严格有序的访问。<strong>ZooKeeper的性能方面意味着它可以用于大型分布式系统。可靠性方面使其不会成为单点故障。严格的排序意味着可以在客户端实现复杂的同步原语</strong>。</p><h3 id="zookeeper-is-replicated.">1.2.2 <strong>ZooKeeper isreplicated.</strong></h3><p>就像它协调的分布式进程一样，ZooKeeper本身旨在通过一组称为集成的主机进行复制。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/zkservice.jpg"alt="动物园管理员服务" /><figcaption aria-hidden="true">动物园管理员服务</figcaption></figure><p>构成 ZooKeeper服务的服务器必须相互了解。它们在内存中维护状态数据，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。</p><p>客户端连接到单个 ZooKeeper 服务器。客户端维护一个 TCP连接，通过它发送请求、获取响应、获取监视事件和发送心跳。如果与服务器的TCP 连接中断，客户端将连接到另一台服务器。</p><h3 id="zookeeper-is-ordered">1.2.3 <strong>ZooKeeper isordered</strong></h3><p>ZooKeeper 用反映所有 ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原语。</p><h3 id="zookeeper-is-fast">1.2.4 <strong>ZooKeeper is fast</strong></h3><p>它在“读主导”工作负载中特别快。ZooKeeper应用程序在数千台机器上运行，它在读取比写入更常见的情况下表现最佳，比率约为10:1。</p><h1 id="zookeeper安装">2.Zookeeper安装</h1><ul><li><ahref="https://www.runoob.com/w3cnote/zookeeper-setup.html">Zookeeper安装</a></li><li><ahref="https://blog.51cto.com/u_15856491/5815098">Zookeeper常见错误</a></li></ul><p><strong><em>本文省略Zookeeper安装具体教程，如果有兴趣查找以上资料进行安装。</em></strong></p><p>zoo.cfg相关参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># The number of milliseconds of each tick</span><br><span class="hljs-comment"># 这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳，以毫秒为单位。</span><br><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of ticks that the initial </span><br><span class="hljs-comment"># synchronization phase can take</span><br><span class="hljs-comment"># 这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 52000=10 秒</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of ticks that can pass between </span><br><span class="hljs-comment"># sending a request and getting an acknowledgement</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-comment"># do not use /tmp for storage, /tmp here is just </span><br><span class="hljs-comment"># example sakes.</span><br><span class="hljs-comment"># 顾名思义就是 Zookeeper 保存数据的目录，默认情况下</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\software\zookeeper\apache-zookeeper-3.7.0\data</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Zookeeper 将写数据的日志文件保存在这个目录里。</span><br><span class="hljs-attr">dataLogDir</span>=<span class="hljs-string">D:\software\zookeeper\apache-zookeeper-3.7.0\log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the port at which the clients will connect</span><br><span class="hljs-comment"># 这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the maximum number of client connections.</span><br><span class="hljs-comment"># increase this if you need to handle more clients</span><br><span class="hljs-comment">#maxClientCnxns=60</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Be sure to read the maintenance section of the </span><br><span class="hljs-comment"># administrator guide before turning on autopurge.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of snapshots to retain in dataDir</span><br><span class="hljs-comment">#autopurge.snapRetainCount=3</span><br><span class="hljs-comment"># Purge task interval in hours</span><br><span class="hljs-comment"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="hljs-comment">#autopurge.purgeInterval=1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">## Metrics Providers</span><br><span class="hljs-comment"># https://prometheus.io Metrics Exporter</span><br><span class="hljs-comment">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="hljs-comment">#metricsProvider.httpPort=7000</span><br><span class="hljs-comment">#metricsProvider.exportJvmInfo=true</span><br></code></pre></td></tr></table></figure><h1 id="zookeeper概念">3.Zookeeper概念</h1><h2 id="数据模型和分层命名空间">3.1 数据模型和分层命名空间</h2><p>ZooKeeper中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。ZooKeeper的数据模型也具有一个固定的根节点（/），我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。ZooKeeper树中的每一层级用斜杠（/）分隔开，且只能用绝对路径（如“get/work/task1”）的方式查询 ZooKeeper节点，而不能使用相对路径。具体的结构看看下面这张图：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl6yL9uAbpHYAABF_GHyGNc950.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>ZooKeeper数据模型的结构与Unix文件系统很类似，每个节点称作一个ZNode，ZNode 是以key-value 形式存在的。名称 key 由斜线 / 分割的一系列路径元素，zookeeper名称空间中的每个节点都是由一个路径标识。</p><p>注意：ZooKeeper不使用相对路径。所以以下是无效的：“/a/b/./c”或“/a/b/../c”。</p></blockquote><h2 id="节点和临时节点">3.2 节点和临时节点</h2><p>与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以有与其关联的数据以及子节点。这就像拥有一个允许文件也可以是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息、配置、位置信息等，因此每个节点存储的数据通常很小，在字节到千字节范围内。）我们使用术语znode 来<em>明确</em>我们正在谈论 ZooKeeper 数据节点。</p><p>Znodes 维护一个统计结构，其中包括数据更改的版本号、ACL更改和时间戳，以允许缓存验证和协调更新。每次 znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</p><p>存储在命名空间中每个 znode 的数据是原子读取和写入的。读取获取与 znode关联的所有数据字节，写入替换所有数据。每个节点都有一个访问控制列表(ACL)，用于限制谁可以做什么。</p><p>ZooKeeper 也有临时节点的概念。只要创建 znode 的会话处于活动状态，这些znode 就会存在。当会话结束时，znode 将被删除。</p><h2 id="条件更新和监视">3.3 条件更新和监视</h2><p><em>ZooKeeper 支持watches</em>的概念。客户端可以在 znode上设置监视。当 znode 更改时，将触发并删除watch。触发监视时，客户端会收到一个数据包，说明 znode已更改。如果客户端和其中一个 ZooKeeper服务器之间的连接断开，客户端将收到本地通知。</p><p><strong>3.6.0 中的新增功能：</strong>客户端还可以在 znode上设置永久的递归监视，这些监视在触发时不会被删除，并且会递归地触发已注册znode 以及任何子 znode 上的更改。</p><h2 id="保证">3.4 保证</h2><p>ZooKeeper非常快速且非常简单。但是，由于它的目标是成为构建更复杂服务（例如同步）的基础，因此它提供了一组保证。这些都是：</p><ul><li>顺序一致性——来自客户端的更新将按照它们发送的顺序应用。</li><li>原子性——更新要么成功要么失败。没有部分结果。</li><li>单一系统映像——无论连接到哪个服务器，客户端都将看到相同的服务视图。即，即使客户端故障转移到具有相同会话的不同服务器，客户端也永远不会看到系统的旧视图。</li><li>可靠性——应用更新后，它将一直持续到客户端覆盖更新为止。</li><li>及时性——系统的客户视图保证在特定时间范围内是最新的。</li></ul><h2 id="simple-api">3.5 Simple Api</h2><p>ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持这些操作：</p><ul><li><em>create</em>：在树中的某个位置创建一个节点</li><li><em>delete</em> : 删除一个节点</li><li><em>exists</em> : 测试节点是否存在于某个位置</li><li><em>获取数据</em>：从节点读取数据</li><li><em>设置数据</em>：将数据写入节点</li><li><em>get children</em>：检索节点的子节点列表</li><li><em>sync</em>：等待数据传播</li></ul><h1 id="zookeeper节点">4.Zookeeper节点</h1><h2 id="节点的状态结构">4.1 节点的状态结构</h2><p>节点称为 <strong>ZNode</strong>。每个 ZNode有一个名称标识，即树根到该节点的路径（用 “/” 分隔），ZooKeeper树中的每个节点都可以拥有子节点，这与文件系统的目录树类似。</p><p>上图中，每一个节点都是一个ZNode，每个ZNode都会保存自己的数据内容和一系列属性信息，维护一个stat结构。比如上面我们创建的<code>works</code>节点：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[zk</span>: <span class="hljs-string">localhost:2181(CONNECTED) 15] stat /works</span><br><span class="hljs-attr">cZxid</span> = <span class="hljs-string">0x4</span><br><span class="hljs-attr">ctime</span> = <span class="hljs-string">Mon Mar 06 16:07:21 CST 2023</span><br><span class="hljs-attr">mZxid</span> = <span class="hljs-string">0x4</span><br><span class="hljs-attr">mtime</span> = <span class="hljs-string">Mon Mar 06 16:07:21 CST 2023</span><br><span class="hljs-attr">pZxid</span> = <span class="hljs-string">0x7</span><br><span class="hljs-attr">cversion</span> = <span class="hljs-string">3</span><br><span class="hljs-attr">dataVersion</span> = <span class="hljs-string">0</span><br><span class="hljs-attr">aclVersion</span> = <span class="hljs-string">0</span><br><span class="hljs-attr">ephemeralOwner</span> = <span class="hljs-string">0x0</span><br><span class="hljs-attr">dataLength</span> = <span class="hljs-string">0</span><br><span class="hljs-attr">numChildren</span> = <span class="hljs-string">3</span><br><span class="hljs-attr">[zk</span>: <span class="hljs-string">localhost:2181(CONNECTED) 16]</span><br></code></pre></td></tr></table></figure><p>其中每个字段的含义为：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F6zbwWAVkt5AAC_yMQVCFo712.png"alt="表.png" /><figcaption aria-hidden="true">表.png</figcaption></figure><blockquote><p>在zookeeper中，事务是指能够改变zookeeper服务器状态的操作，称为事务操作和更新操作。一般包括数据节点的创建与删除、数据节点内容更新等操作。</p><p>每一次事务请求，zk都会为其分配一个全局唯一的事务id，用ZXID表示，通常是一个64位数字。每一个ZXID对应一次更新更新操作。</p></blockquote><p><strong>为什么 ZooKeeper 不能采用相对路径查找节点呢？</strong></p><blockquote><p>因为 ZooKeeper大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。ZooKeeper在底层实现的时候，使用了一个 hashtable，即hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes，用节点的完整路径来作为 key 存储节点数据。这样就大大提高了 ZooKeeper的性能。</p></blockquote><p>上述众多节点特性，使得 zookeeper能开发不出不同的经典应用场景，比如：</p><ul><li><ol type="1"><li>数据发布/订阅</li></ol></li><li><ol start="2" type="1"><li>负载均衡</li></ol></li><li><ol start="3" type="1"><li>分布式协调/通知</li></ol></li><li><ol start="4" type="1"><li>集群管理</li></ol></li><li><ol start="5" type="1"><li>集群管理</li></ol></li><li><ol start="6" type="1"><li>master 管理</li></ol></li><li><ol start="7" type="1"><li>分布式锁</li></ol></li><li><ol start="8" type="1"><li>分布式队列</li></ol></li></ul><h2 id="节点类型">4.2 <strong>节点类型</strong></h2><p>与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以有与其关联的数据以及子节点。这就像拥有一个允许文件也可以是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息、配置、位置信息等，因此每个节点存储的数据通常很小，在字节到千字节范围内。）我们使用术语<code>znode</code>来<em>明确</em>我们正在谈论 ZooKeeper 数据节点。</p><p>Znodes 维护一个统计结构，其中包括数据更改的版本号、ACL更改和时间戳，以允许缓存验证和协调更新。每次 znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</p><p>存储在命名空间中每个 znode 的数据是原子读取和写入的。读取获取与 znode关联的所有数据字节，写入替换所有数据。<strong>每个节点都有一个访问控制列表(ACL)，用于限制谁可以做什么</strong>。</p><p>ZooKeeper 由节点来存储信息，ZooKeeper 中的数据节点也分为<code>持久节点</code>、<code>临时节点</code>和<code>有序节点</code>三种类型：</p><h3 id="持久节点">4.2.1 <strong>持久节点</strong></h3><p>持久节点，这种节点也是在 ZooKeeper最为常用的，持久节点一旦将节点创建为持久节点，该数据节点会一直存储在ZooKeeper服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用delete 函数进行删除操作。</p><p>### 4.2.2 临时节点</p><p>ZooKeeper 也有临时节点的概念。只要创建 znode 的会话处于活动状态，这些znode 就会存在。当会话结束时，znode 将被删除。</p><p>临时节点的一个最重要的特性就是临时性。所谓临时性是指，如果将节点创建为临时节点，那么该节点数据不会一直存储在ZooKeeper服务器上。<code>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除</code>。同样，我们可以像删除持久节点一样主动删除临时节点。</p><p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为“/servers”节点，并为集群下的每台服务器创建一个临时节点“/servers/host”，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。如下图所示：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl6yL-SAb0zaAABQBLohKvo019.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>临时节点不允许有子节点，因为它随时可能被删除。</p></blockquote><p>### 4.2.3 有序节点</p><p>其实有序节点并不算是一种单独种类的节点，而是在之前提到的持久节点和临时节点特性的基础上，增加了一个节点有序的性质。所谓节点有序是说在我们创建有序节点的时候，ZooKeeper服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。例如一个客户端创建了一个路径为works/task- 的有序节点，那么 ZooKeeper将会生成一个序号并追加到该节点的路径后，最后该节点的路径为works/task-1。通过这种方式我们可以直观的查看到节点的创建顺序。</p><blockquote><p>因此可以分为：</p><ul><li><strong>持久节点</strong>：节点被创建后会一直存在服务器，除非主动进行ZNode删除操作，主动清除。否则一直被保存</li><li><strong>持久顺序节点</strong>：创建节点时会在节点名后面加上一个数字后缀来表示顺序，和持久节点特性一样</li><li><strong>临时节点</strong>：生命周期和客户端会话绑在一起，客户端会话结束，节点会被删除；不能创建子节点</li><li><strong>临时顺序节点</strong>：有顺序的临时节点</li></ul></blockquote><p>到目前为止我们知道在 ZooKeeper 服务器上存储数据的基本信息，知道了ZooKeeper中的数据节点种类有持久节点和临时节点等。上述这几种数据节点虽然类型不同，但ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组（bytedata[]），用来存储节点的数据、ACL访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p><h1 id="zookeeper命令">5.Zookeeper命令</h1><p><strong>命令：</strong></p><p>为了后续讲解，此处只展示常用的基础命令。</p><ul><li><strong>connect host:port</strong> 连接zookeeper</li></ul><blockquote><p>connect 127.0.0.1:2181</p></blockquote><p>可选的“chroot”后缀也可以附加到连接字符串。这将运行客户端命令，比如我们运行：</p><blockquote><p>connect 127.0.0.1:2181/works</p></blockquote><p>其中客户端将根于此路径，所有路径都将相对于此根</p><ul><li><strong>ls</strong>查看某个路径下目录列表，<strong>path</strong>：代表路径。</li></ul><blockquote><p>ls path</p></blockquote><ul><li><strong>ls2</strong> 查看某个路径下目录列表，它比 ls命令列出更多的详细信息</li></ul><blockquote><p>ls2 path</p></blockquote><ul><li><strong>get</strong>用于获取节点数据和状态信息，<strong>[watch]</strong>：对<strong>节点</strong>进行事件监听。</li></ul><blockquote><p>get path [watch]</p><p>节点监听：如果有另一个终端对该节点进行了修改，则监听此节点的终端会得到事件通知</p></blockquote><ul><li><strong>stat</strong> 查看节点状态信息。</li></ul><blockquote><p>stat path [watch]</p></blockquote><ul><li><strong>create</strong> 用于创建节点并赋值。</li></ul><blockquote><p>create [-s] [-e] path data acl</p></blockquote><ul><li><strong>[-s] [-e]</strong>：-s 和 -e 都是可选的，-s 代表顺序节点，-e 代表临时节点，</li><li><strong>path</strong>：指定要创建节点的路径，比如<strong>/runoob</strong>。</li><li><strong>data</strong>：要在此节点存储的数据。</li><li><strong>acl</strong>：访问权限相关，默认是world，相当于全世界都能访问。</li></ul><p><strong>注意其中 -s 和 -e可以同时使用的，并且临时节点不能再创建子节点。</strong></p><ul><li><strong>set</strong>修改节点存储的数据。<strong>[version]</strong>：可选项，版本号(可用作乐观锁)。</li></ul><blockquote><p>set path data [version]</p></blockquote><ul><li><strong>delete</strong> 删除某节点</li></ul><blockquote><p>delete path [version]</p></blockquote><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl6yL9uAbpHYAABF_GHyGNc950.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>举例，现在我们创建上图节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: localhost:2181(CONNECTED) 0] <span class="hljs-built_in">ls</span> /<br>[zookeeper]<br>[zk: localhost:2181(CONNECTED) 1] create /locks<br>Created /locks<br>[zk: localhost:2181(CONNECTED) 2] create /works<br>Created /works<br>[zk: localhost:2181(CONNECTED) 3] create /works/test1<br>Created /works/test1<br>[zk: localhost:2181(CONNECTED) 4] create /works/test2<br>Created /works/test2<br>[zk: localhost:2181(CONNECTED) 5] create /works/test3<br>Created /works/test3<br>[zk: localhost:2181(CONNECTED) 6] <span class="hljs-built_in">ls</span> /<br>[locks, works, zookeeper]<br>[zk: localhost:2181(CONNECTED) 7]<br></code></pre></td></tr></table></figure><h1 id="read-more">6.Read more</h1><p>:lollipop::https://www.runoob.com/w3cnote/zookeeper-znode-data-model.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring依赖注入</title>
    <link href="/2022/05/27/framework/spring/2022-05-22_Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/05/27/framework/spring/2022-05-22_Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="spring依赖注入">Spring依赖注入</h1><p>spring依赖注入包括三种：<strong>1.setter注入，2.构造器注入，3,属性注入</strong>，</p><h1 id="基于构造器注入">1.基于构造器注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于setter注入">2.基于setter注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> UserDao userDao;<br>  <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>      <span class="hljs-built_in">this</span>.userDao = userDao;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="基于filed注解注入">3.基于Filed(注解)注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>    <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-comment">//@Inject</span><br>  <span class="hljs-keyword">private</span> UserDao userDao;<br>  <br>  <span class="hljs-comment">//简单的使用例子，下同</span><br>  <span class="hljs-keyword">public</span> List <span class="hljs-title function_">listFoo</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> userDao.list();<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们使用最多的方式就是属性注入的方式：</p><ol type="1"><li>注入方式非常简单：加入要注入的字段，附上<code>@Autowired</code>，即可完成。</li><li>使得整体代码简洁明了，看起来美观大方</li></ol></blockquote><h1id="spring为什么推荐构造器注入方式">4.spring为什么推荐构造器注入方式？</h1><p>先来看看Spring在文档里怎么说：</p><blockquote><p>The Spring team generally advocates constructor injection as itenables one to implement application components as immutable objects andto ensure that required dependencies are not null. Furthermoreconstructor-injected components are always returned to client (calling)code in a fully initialized state.As a side note, a large number ofconstructor arguments is a bad code smell, implying that the classlikely has too many responsibilities and should be refactored to betteraddress proper separation of concerns.”</p></blockquote><p>简单的翻译一下：这个构造器注入的方式<strong>能够保证注入的组件不可变，并且确保需要的依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。与此同时，从代码质量的角度来看，一个巨大的构造方法通常代表着出现了代码异味，这个类可能承担了过多的责任。</p><blockquote><p>对于这个类可能承担了过多的责任这个问题，说明你的类当中有太多的责任，那么你要好好想一想是不是自己违反了类的<ahref="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#s单一职责srp">单一性职责原则</a>，从而导致有这么多的依赖要注入。</p></blockquote><ul><li><p><strong>依赖不可变</strong>：其实说的就是final关键字。</p></li><li><p><strong>依赖不为空</strong>（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK。2：无该类型的参数-&gt;报错。</p></li><li><p><strong>完全初始化的状态</strong>：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</p></li></ul><h1 id="autowiredresourceinject">5.@Autowired、<span class="citation"data-cites="Resource">@Resource</span>、<span class="citation"data-cites="Inject">@Inject</span></h1><p>Spring 支持使用<code>@Autowired</code>, <code>@Resource</code>,<code>@Inject</code> 三个注解进行依赖注入。那@Autowired和<spanclass="citation" data-cites="Resource以及">@Resource以及</span><spanclass="citation"data-cites="Inject等注解注入有何区别">@Inject等注解注入有何区别</span>？</p><h2 id="autowired">5.1 <span class="citation"data-cites="Autowired">@Autowired</span></h2><p>在Spring 2.5 引入了 <span class="citation"data-cites="Autowired">@Autowired</span> 注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从Autowired注解源码上看，可以使用在下面这些地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> #方法<br><span class="hljs-meta">@Target(ElementType.PARAMETER)</span> #方法参数<br><span class="hljs-meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量<br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span> #注解<br></code></pre></td></tr></table></figure><ul><li><strong>字段属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><ul><li><strong>构造函数，方法参数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HelloDao helloDao;<br><br><span class="hljs-comment">//@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloServiceImpl</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> HelloDao helloDao)</span> &#123;<br> <span class="hljs-built_in">this</span>.helloDao = helloDao;<br>&#125;<br><span class="hljs-comment">// 构造器注入也可不写@Autowired，也可以注入成功。</span><br></code></pre></td></tr></table></figure><ul><li><strong>方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HelloDao helloDao;<br><br><span class="hljs-keyword">public</span> HelloDao <span class="hljs-title function_">getHelloDao</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">return</span> helloDao;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHelloDao</span><span class="hljs-params">(HelloDao helloDao)</span> &#123;<br>    <span class="hljs-built_in">this</span>.helloDao = helloDao;<br>&#125;<br></code></pre></td></tr></table></figure><p>将@Autowired写在被注入的成员变量上，setter或者构造器上，就不用再xml文件中配置了。</p><p>如果有多个类型一样的Bean候选者，则默认根据设定的属性名称进行获取。如HelloDao 在Spring中有 helloWorldDao 和 helloDao 两个Bean候选者。</p><p>首先根据类型获取，发现多个HelloDao，然后根据helloDao进行获取，如果要获取限定的其中一个候选者，结合@Qualifier进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;helloWorldDao&quot;)</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><blockquote><p>注入名称为helloWorldDao 的Bean组件。<span class="citation"data-cites="Qualifier">@Qualifier</span>("XXX") 中的 XX是 Bean的名称，所以 <span class="citation"data-cites="Autowired">@Autowired</span> 和 <span class="citation"data-cites="Qualifier">@Qualifier</span> 结合使用时，自动注入的策略就从byType 转变成 byName 了。</p></blockquote><p>注入名称为helloWorldDao的Bean组件。<code>@Qualifier("XXX")</code>中的 XX是 Bean 的名称，所以<code>@Autowired</code> 和 <code>@Qualifier</code>结合使用时，自动注入的策略就从 byType 转变成 byName 了。</p><p>多个类型一样的Bean候选者，也可以<code>@Primary</code>进行使用，设置首选的组件，也就是默认优先使用哪一个。</p><p>注意：使用@Qualifier时候，如何设置的指定名称的Bean不存在，则会抛出异常，如果防止抛出异常，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier(&quot;xxxxyyyy&quot;)</span><br><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><p>举例：</p><p>声明一个接口UserDao与2个实现类UserDaoImpl、UserDaoImpl2，如下：</p><p><strong>UserDao</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserDaoImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello111...&quot;</span> + data1 + <span class="hljs-string">&quot;  &quot;</span> + data2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserDaoImpl2</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello222...&quot;</span> + data1+<span class="hljs-string">&quot;  &quot;</span> + data2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">(String data1,<span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.gogo&quot;</span>);<br>        userDao.sayHello(data1,data2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后通过测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    ApplicationContext applicationContext= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config.xml&quot;</span>);<br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>    userService.gogo(<span class="hljs-string">&quot;xx1&quot;</span>,<span class="hljs-number">798</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>就会发现控制台报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="hljs-string">&#x27;userService&#x27;</span>: Unsatisfied dependency expressed through field <span class="hljs-string">&#x27;userDao&#x27;</span>; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;com.itszt.ioc.dao.UserDao&#x27;</span> available: expected single matching bean but found 2: userDaoImpl,userDaoImpl2<br>... ...<br><br>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;com.itszt.ioc.dao.UserDao&#x27;</span> available: expected single matching bean but found 2: userDaoImpl,userDaoImpl2<br></code></pre></td></tr></table></figure><p>加上<code>@Qualifier</code>注解，：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value = &quot;userDaoImpl&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">(String data1,<span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.gogo&quot;</span>);<br>        userDao.sayHello(data1,data2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>则运行正常:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">17:35:58,153  INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [com/xxx/ioc/spring-config.xml]<br>UserServiceImpl.gogo<br>hello111...xx1  798<br></code></pre></td></tr></table></figure><ul><li><strong>简单总结</strong>：</li></ul><p>1、<span class="citation"data-cites="Autowired是Spring自带的注解">@Autowired是Spring自带的注解</span>，通过<code>AutowiredAnnotationBeanPostProcessor</code>类实现的依赖注入</p><p>2、<span class="citation"data-cites="Autowired可以作用在CONSTRUCTOR">@Autowired可以作用在CONSTRUCTOR</span>、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE</p><p>3、<span class="citation"data-cites="Autowired默认是根据类型">@Autowired默认是根据类型</span>（byType）进行自动装配的</p><p>4、如果有多个类型一样的Bean候选者，需要指定按照名称（byName）进行装配，则需要配合@Qualifier。</p><blockquote><p>指定名称后，如果SpringIOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常。</p><p>如果容器中有同种类型的多个实现，使用@Autowired则会抛出NoUniqueBeanDefinitionException异常，存在多个实现类会不知道选择哪一个而报错。所以说，存在多个实现类的情况，不能用byType的形式。</p></blockquote><h2 id="resouce">5.2 <span class="citation"data-cites="Resouce">@Resouce</span></h2><ul><li><strong>Resource注解源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">// 其他省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从Resource注解源码上看，可以使用在下面这些地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> #接口、类、枚举、注解<br><span class="hljs-meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> #方法<br></code></pre></td></tr></table></figure><p>name 指定注入指定名称的组件。</p><ul><li><strong>字段属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resouce</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><blockquote><p>同理，如果有多个候选bean，则也会抛出NoUniqueBeanDefinitionException异常</p></blockquote><p>也可以直接指定注入的bean，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;userDaoImpl&quot;)</span><br><span class="hljs-keyword">private</span> UserDao userDao ;<br></code></pre></td></tr></table></figure><blockquote><p>name 的作用类似 <span class="citation"data-cites="Qualifier">@Qualifier</span>，所以Autowired</p></blockquote><ul><li><strong>简单总结</strong>：</li></ul><p>1、<span class="citation"data-cites="Resource是JSR250规范的实现">@Resource是JSR250规范的实现</span>，在javax.annotation包下</p><p>2、<span class="citation"data-cites="Resource可以作用TYPE">@Resource可以作用TYPE</span>、FIELD、METHOD上</p><p>3、<span class="citation"data-cites="Resource是默认根据属性名称进行自动装配的">@Resource是默认根据属性名称进行自动装配的</span>，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入</p><h2 id="inject">5.3 <span class="citation"data-cites="Inject">@Inject</span></h2><ul><li><strong>Inject注解源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123; METHOD, CONSTRUCTOR, FIELD &#125;)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Inject &#123;&#125;<br></code></pre></td></tr></table></figure><p>从Inject注解源码上看，可以使用在下面这些地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> #方法<br><span class="hljs-meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量<br></code></pre></td></tr></table></figure><ul><li><strong>字段属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><blockquote><p>同理，如果有多个候选bean，则也会抛出NoUniqueBeanDefinitionException异常</p></blockquote><p>也可以直接指定注入的bean，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-meta">@Named(name = &quot;userDaoImpl&quot;)</span><br><span class="hljs-keyword">private</span> UserDao userDao ;<br></code></pre></td></tr></table></figure><blockquote><p>name 的作用类似 <span class="citation"data-cites="Qualifier">@Qualifier</span>，所以Autowired</p></blockquote><ul><li><strong>简单总结</strong>：</li></ul><p>1、<span class="citation"data-cites="Inject是JSR330">@Inject是JSR330</span> (Dependency Injectionfor Java)中的规范，需要导入javax.inject.Inject jar包 ，才能实现注入</p><p>2、<span class="citation"data-cites="Inject可以作用CONSTRUCTOR">@Inject可以作用CONSTRUCTOR</span>、METHOD、FIELD上</p><p>3、<span class="citation"data-cites="Inject是根据类型进行自动装配的">@Inject是根据类型进行自动装配的</span>，如果需要按名称进行装配，则需要配合@Named；</p><h1 id="autowiredresourceinject总结">6.@Autowired、<spanclass="citation" data-cites="Resource">@Resource</span>、<spanclass="citation" data-cites="Inject总结">@Inject总结</span></h1><p>1、<span class="citation"data-cites="Autowired是Spring自带的">@Autowired是Spring自带的</span>，<spanclass="citation"data-cites="Resource是JSR250规范实现的">@Resource是JSR250规范实现的</span>，<spanclass="citation"data-cites="Inject是JSR330规范实现的">@Inject是JSR330规范实现的</span>。</p><p>2、<span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Inject用法基本一样">@Inject用法基本一样</span>，不同的是@Inject没有required属性。</p><p>3、<span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Inject是默认按照">@Inject是默认按照</span><strong>类型</strong>匹配的，<spanclass="citation"data-cites="Resource是按照">@Resource是按照</span><strong>名称</strong>匹配的。</p><p>4、<span class="citation"data-cites="Autowired如果需要按照名称匹配需要和">@Autowired如果需要按照名称匹配需要和</span><spanclass="citation"data-cites="Qualifier一起使用">@Qualifier一起使用</span>，<spanclass="citation" data-cites="Inject和">@Inject和</span><spanclass="citation" data-cites="Named一起使用">@Named一起使用</span>，<spanclass="citation"data-cites="Resource则通过name进行指定">@Resource则通过name进行指定</span>。</p><h1 id="read-more">7.Read more</h1><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc.html</p><p>:lollipop::https://www.cnblogs.com/diandianquanquan/p/11518365.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="/2022/05/27/framework/spring/2022-05-27_Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <url>/2022/05/27/framework/spring/2022-05-27_Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="bean实例化循环依赖">1.Bean实例化、循环依赖</h1><h2 id="什么是循环依赖">1.1 什么是循环依赖？</h2><p>如下有 A、B、C三个类，可以看到发生了循环依赖：<code>彼此互相依赖，导致各自都需要对方的依赖，形成依赖闭环。</code></p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230302103233180.png" /></p><p>但是我们会发现field属性注入、setter方法注入的循环依赖：<code>即使发生了循环依赖，我们依然可以启动，使用并没有任何影响。</code>这种方式是我们最为常用的依赖注入方式，Spring会解决<code>field属性注入、setter方法注入</code>的循环依赖。但是无法解决构造器注入的循环依赖。</p><p>Spring IoC容器会在运行时检测到<strong>构造函数</strong>注入循环引用，并抛出<code>BeanCurrentlyInCreationException</code>。从而提醒你避免循环依赖。所以要避免构造函数注入，可以使用setter 注入替代。根据官方文档说明，Spring 会自动解决基于 setter注入的循环依赖。当然在咱们工作中现在都使用 <span class="citation"data-cites="Autowired">@Autowired</span> 注解来注入属性。 <spanclass="citation" data-cites="Autowired">@Autowired</span>是通过反射进行赋值。</p><p>依赖注入的方式：</p><ol type="1"><li>注解注入：<span class="citation"data-cites="Autowire和">@Autowire和</span><span class="citation"data-cites="Resource">@Resource</span>：这种注解可以直接解决循环依赖问题，不需要额外处理</li><li>构造方法器注入：构造方法注入需要使用@Lazy注解来作用于循环依赖的属性</li><li>setter注入：setter注入也可以直接解决循环依赖问题，不需要额外处理</li></ol><blockquote><p>Spring只是解决了单例模式下属性依赖的循环问题；Spring为了解决单例的循环依赖问题，使用了三级缓存。</p></blockquote><h1 id="spring的循环依赖">2.Spring的循环依赖</h1><p>现在有循环依赖代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServiceB serviceB;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceB</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServiceA serviceA;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论先创建ServiceA还是ServiceB时，都会发生循环依赖！</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/format,png.png" /></p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自己依赖自己</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServiceA serviceA;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自己依赖自己其实也是循环依赖的一种</p></blockquote><h2 id="实例化与初始化">2.1 实例化与初始化</h2><p>在介绍spring如何解决循环依赖前，我们必须先了解一个完整的对象其实包含两部分：当前对象实例化和对象属性的实例化：</p><ul><li><p><strong>类的实例化：</strong></p><p>是指创建一个对象的过程。这个过程中会在堆中开辟内存，将一些<strong>非静态</strong>的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。（就是调用构造函数，生成一个对象。）</p></li><li><p><strong>类的初始化：</strong></p></li></ul><p>是完成程序执行前的准备工作。在这个阶段，<strong><em>*静态的*</em></strong>（变量，方法，代码块）会被执行。同时在会开辟一块存储空间用来存放静态的数据。初始化只在类加载的时候执行一次（为变量设置值）</p><p>这个过程可以按照如下方式进行理解：</p><blockquote><p>在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。</p></blockquote><h2 id="解决循环依赖">2.2 解决循环依赖</h2><p>在spring中，通过三级缓存来解决循环依赖的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton objects: bean name --&gt; bean instance（一级缓存，存储单例对象，Bean 已经实例化，初始化完成） */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="hljs-number">64</span>);<br><br><span class="hljs-comment">/** Cache of early singleton objects: bean name --&gt; bean instance（二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化） */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory（三级缓存，单例的工厂Bean缓存集合） */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, ObjectFactory&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Names of beans that are currently in creation 正在创建的对象*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =<br>Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><br></code></pre></td></tr></table></figure><ul><li><p>「<strong>singletonObjects</strong>」：缓存某个 beanName对应的经过了完整生命周期的bean；</p></li><li><p>「<strong>earlySingletonObjects</strong>」：缓存提前拿原始对象进行了AOP 之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcesso r等生命周期；</p></li><li><p>「<strong>singletonFactories</strong>」：缓存的是一个ObjectFactory ，主要用来去生成原始对象进行了AOP之后得到的「代理对象」，在每个 Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本 bean 按照自己的生命周期执行，执行完后直接把本bean 放入 singletonObjects 中即可，如果出现了循环依赖依赖了本bean，则另外那个 bean 执行 ObjectFactory 提交得到一个 AOP之后的代理对象（如果有 AOP 的话，如果无需 AOP，则直接得到一个原始对象</p></li></ul><p>spring容器的实现从根源上来看的话是通过<code>BeanFactory</code>实现的，但是<code>BeanFactory</code>只是一个接口类，真正作为一个可以独立使用的容器还是通过<code>DeafultListableBeanFactory</code>实现的，<code>DefaultListableBeanFactory</code>结构图解：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230302114741837.png" /></p><h1 id="源码角度">3.源码角度</h1><h2 id="defaultlistablebeanfactory的preinstantiatesingletons方法">3.1<strong>DefaultListableBeanFactory的preInstantiateSingletons方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   ... ...<br>   List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>   <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>   <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>      <span class="hljs-comment">//获取指定名称的Bean定义</span><br>      <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>      <span class="hljs-comment">//Bean不是抽象的，是单态模式的，且lazy-init属性配置为false</span><br>      <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>        ... ...<br>            <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>               <span class="hljs-comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程</span><br>               getBean(beanName);<br>            &#125;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>            getBean(beanName);<br>         &#125;<br>      &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>最终都会调用<code>getBean</code>方法，触发容器对Bean实例化和依赖注入过程。<code>getBean</code>方法是在<code>Beanfactory</code>中的一个接口，由<code>AbstractBeanFactory</code>实现，执行<code>doGetBean</code>方法，在Spring中，凡是以do开头的方法一般都是细节上的逻辑处理，也就是具体的实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取IOC容器中指定名称的Bean</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span><br>   <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在spring中，想要使用对象最终都会调用<code>AbstractBeanFactory</code>的<code>getBean()</code>方法，进而执行<code>doGetBean()</code>方法。</p><p>在spring中，凡是以do开头的方法一般都是细节上的逻辑实现，所以在<code>doGetBean()</code>中执行了<code>DefaultSingletonBeanRegistry</code>的<code>getSingleton()</code>方法。</p></blockquote><h2 id="abstractbeanfactory的dogetbean方法">3.2<strong>AbstractBeanFactory的doGetBean方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType, <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>        <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//1、转换beanName，返回 bean 名称，必要时去除工厂取消引用前缀，并将别名解析为规范名称</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    Object bean;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 有缓存，如果指定名称的Bean在容器中已有单例模式的Bean被创建。直接返回已经创建的Bean</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ... ...<br>        <span class="hljs-comment">// Check if bean definition exists in this factory.</span><br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// 父 factory 里加载</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">//2、转换成RootBeanDefinition</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        checkMergedBeanDefinition(mbd, beanName, args);<br><br>        <span class="hljs-comment">//依赖，先不考虑</span><br>        String[] dependsOn = mbd.getDependsOn();<br>        <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//...</span><br>        &#125;<br><br>        <span class="hljs-comment">// Create bean instance.</span><br>        <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>            <span class="hljs-comment">//3、关键：单例类的初始化</span><br>            sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                        <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>                        <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>                        <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>            <span class="hljs-comment">//prototype ...</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他scope ...</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><br>    <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; bean != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;<br>        <span class="hljs-comment">// 如果类型不一致，做类型转换</span><br>        <span class="hljs-keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="defaultsingletonbeanregistry的getsingletonstring-beanname-boolean-allowearlyreference">3.3DefaultSingletonBeanRegistry的getSingleton(String beanName， booleanallowEarlyReference)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">----&gt; <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getSingleton(beanName);<br><br><span class="hljs-comment">//返回在给定名称下注册的（原始）单例对象。 &lt;p&gt;检查已经实例化的单例，并允许提前引用当前创建的单例（解决循环引用）</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>   <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>   <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>          <span class="hljs-comment">/** </span><br><span class="hljs-comment">          * 如果singletonObjects还没有此bean，有两种情况</span><br><span class="hljs-comment">          * 1.这个bean正在创建状态，先从earlySingletonObjects获取</span><br><span class="hljs-comment">          * 2.这个bean还没开始创建</span><br><span class="hljs-comment">          */</span><br>         singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>         <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>              <span class="hljs-comment">/** </span><br><span class="hljs-comment">             * 如果earlySingletonObjects还没有此bean，有两种情况</span><br><span class="hljs-comment">             * 1.说明还未被其他bean注入，正在创建状态，先从singletonFactories获取</span><br><span class="hljs-comment">             * 2.该bean还没开始创建</span><br><span class="hljs-comment">             */</span><br>            ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>            <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                *将此bean放到提前缓存到earlySingletonObjects中</span><br><span class="hljs-comment">                * 从singletonObject删除bean</span><br><span class="hljs-comment">                */</span><br>               singletonObject = singletonFactory.getObject();<br>               <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>               <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法做了这么一件事，</p><ol type="1"><li><p>先到singletonObjects中获取，如果有表示实例化已经完成；</p></li><li><p>否则到earlySingletonObjects获取，如果有表示已经有bean，且存在循环依赖，将此bean作为属性注入了</p></li><li><p>否则到singletonFactories获取，如果存在循环依赖，且此属性是第一次被其他bean作为属性</p></li></ol><h2id="defaultsingletonbeanregistry的getsingletonstring-beanname-objectfactory-singletonfactory">3.4DefaultSingletonBeanRegistry的getSingleton(String beanName,ObjectFactory&lt;?&gt; singletonFactory)</h2><p>上面的代码主要就是执行一些条件判断，重要的是单例类的getSingleton()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Create bean instance.</span><br>      <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>          <span class="hljs-comment">//3、关键：单例类的初始化</span><br>          sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                  &#125;<br>                  <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                      <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>                      <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>                      <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                      destroySingleton(beanName);<br>                      <span class="hljs-keyword">throw</span> ex;<br>                  &#125;<br>              &#125;<br>          &#125;);<br>          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>      &#125;<br></code></pre></td></tr></table></figure><p>其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">---&gt; sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;()<br>                                   <br><span class="hljs-comment">//返回以给定名称注册的（原始）单例对象，如果尚未注册，则创建并注册一个新对象  </span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br> Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>      <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>         ... ...<br>         beforeSingletonCreation(beanName);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">newSingleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">recordSuppressedExceptions</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.suppressedExceptions == <span class="hljs-literal">null</span>);<br>         <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>            <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>         &#125;<br>         <span class="hljs-keyword">try</span> &#123;<br>            singletonObject = singletonFactory.getObject();<br>            newSingleton = <span class="hljs-literal">true</span>;<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (<br>             ... ...<br>         &#125;<br>         <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>               <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>            &#125;<br>            afterSingletonCreation(beanName);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>            addSingleton(beanName, singletonObject);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> singletonObject;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个getSingleton中，还会再去从一级缓存中获取一次，如果有则直接返回，没有则在<code>beforeSingletonCreation</code>将要创建的对象存入set 集合中。同理，还有<code>afterSingletonCreation</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Singleton &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; isn&#x27;t currently in creation&quot;</span>);<br>   &#125;<br>&#125;<br>-----&gt;<br><span class="hljs-comment">//当前正在创建的bean的名称</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =<br>      Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><blockquote><p>由此可知：创建的时候存在singletonsCurrentlyInCreation队列里，创建成功则被移除。</p></blockquote><p>最后回到在3.4第一哥代码块中执行下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> createBean(beanName, mbd, args)<br></code></pre></td></tr></table></figure><p>方法中进行Bean的创建，<strong>AbstractAutowireCapableBeanFactory</strong>中的createBean方法。</p><h2 id="abstractautowirecapablebeanfactory的createbean方法">3.5AbstractAutowireCapableBeanFactory的createBean方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>      <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>   ... ...<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//创建Bean的入口</span><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>         logger.debug(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> beanInstance;<br>   &#125;<br>   ... ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abstractautowirecapablebeanfactory的docreatebean">3.6AbstractAutowireCapableBeanFactory的doCreateBean</h2><p>主要是进行了一些判断处理，重要方法就是其中的doCreateBean，里面是执行创建对象的细节.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//真正创建Bean的方法</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>      <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>   <span class="hljs-comment">// Instantiate the bean.</span><br>   <span class="hljs-comment">//封装被创建的Bean对象</span><br>   <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>      instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>   &#125;<br>   <span class="hljs-comment">//createBeanInstance----&gt;//创建Bean的实例对象,返回BeanWrapper</span><br>   <span class="hljs-comment">//protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;&#125;</span><br>    <br>   <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>      instanceWrapper = createBeanInstance(beanName, mbd, args);<br>   &#125;<br>   <span class="hljs-comment">//得到bean</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>   ... ...<br>   <br>   <span class="hljs-comment">//判断是否有循环依赖，是否需要暴露对象的引用</span><br>   <span class="hljs-comment">/* Eagerly cache singletons to be able to resolve circular references</span><br><span class="hljs-comment">    *even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="hljs-comment">    * 向容器中缓存单例模式的Bean对象，以防循环引用</span><br><span class="hljs-comment">    * 单例 </span><br><span class="hljs-comment">    * 允许循环依赖</span><br><span class="hljs-comment">    * 当前Bean正在创建中,检测到了循环依赖</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>         isSingletonCurrentlyInCreation(beanName));<br>   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>     ... ...<br>      <span class="hljs-comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span><br>      <span class="hljs-comment">//getEarlyBeanReference方法作用：获取对指定bean的早期访问的引用，通常用于解析循环引用</span><br>      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>   &#125;<br><br>   <span class="hljs-comment">// Initialize the bean instance.</span><br>   <span class="hljs-comment">//Bean对象的初始化，依赖注入在此触发</span><br>   <span class="hljs-comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象</span><br>      populateBean(beanName, mbd, instanceWrapper);<br>      <span class="hljs-comment">//初始化Bean对象</span><br>      exposedObject = initializeBean(beanName, exposedObject, mbd);<br>   &#125;<br>   ... ...<br>   <br>   <span class="hljs-comment">// Register bean as disposable.</span><br>   <span class="hljs-comment">//注册完成依赖注入的Bean</span><br>   <span class="hljs-keyword">try</span> &#123;<br>      registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的addSingletonFactory方法：判断是否是循环引用，是的话执行下面方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">---&gt; addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>   Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br>          <span class="hljs-comment">//添加到三级缓存</span><br>         <span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br>         <span class="hljs-comment">//消除此Bean在二级缓存里的缓存信息</span><br>         <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>         <span class="hljs-comment">//这里为了记录注册单例的顺序</span><br>         <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>消除此Bean在二级缓存里的缓存信息，将其包装成singletonFactory实例往三级缓存里添加，判断是否是循环引用，是的话需要添加到三级缓存中。</p><p>这里有一个重点就是Spring解决循环依赖的真相就在这一段源码中：在这里beanFactory被put进了singletonFactories，此时的bean只是完成了初始化构造的bean，还没有进行set或者注解注入的bean，是bean的一个中间状态，但是已经能被识别出来了，所以Spring此时将这个对象提前曝光出来让大家认识、使用。</p></blockquote><p>在3.3 节中，getSingleton(String beanName, booleanallowEarlyReference) 方法中，如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) <br></code></pre></td></tr></table></figure><p>则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*将此bean放到提前缓存到earlySingletonObjects中</span><br><span class="hljs-comment">* 从singletonObject删除bean</span><br><span class="hljs-comment">*/</span><br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br></code></pre></td></tr></table></figure><h1 id="spring循环依赖解决">4.Spring循环依赖解决</h1><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230302103233180.png" /></p><p>以上面为例子，<strong>A</strong>在<code>DefaultListableBeanFactory</code>的<code>preInstantiateSingletons</code>中，调用<code>AbstractBeanFactory</code>的getBean方法，然后调用doGetBean方法，进入方法的时候会调用getSingleton方法，会进行如下判断：</p><ul><li>先到singletonObjects中获取，如果有表示实例化已经完成；</li><li>到earlySingletonObjects获取，如果没有则找三级缓存，如果有表示已经有bean，且存在循环依赖，返回对象。</li><li>到singletonFactories获取，如果有则返回对象，且将对象存入二级缓存，三级缓存将此对象清除。</li></ul><p>此处<strong>A</strong>在这三个缓存中都获取不到，然后就创建对象，在创建的时候还会再去从一级缓存中获取一次，如果有则直接返回，没有则先在<code>beforeSingletonCreation</code>将要创建的对象存入set集合中，因此是不可重复的，然后执行<strong>AbstractAutowireCapableBeanFactory</strong>中的createBean方法中的doCreateBean方法，所有的对象都封装成BeanWrapper对象，通过BeanWrapper的.getWrappedInstance()得到具体的实例，然后再根据条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>      isSingletonCurrentlyInCreation(beanName));<br></code></pre></td></tr></table></figure><p>是否从二级缓存移除，存入三级缓存，此处<strong>A</strong>已经存入三级缓存。</p><p><strong>B</strong>的过程和 <strong>A</strong>的一样，也是创建了三级缓存，然后去创建<strong>C</strong>，同理，<strong>C</strong>也进入三级缓存，这时候三级缓存里面有它们三个的singletonFactory 。<strong>C</strong> 也调用到 doGetBean 方法去获取<strong>A</strong>.</p><blockquote><p>填充属性ServiceA的时候，这时候能够从三级缓存中拿到半成品的ObjectFactory，拿到ObjectFactory对象后，调用ObjectFactory.getObject()方法最终会调用getEarlyBeanReference()方法，getEarlyBeanReference这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是beanProxy对象，如果未被代理则返回的是原bean实例。</p></blockquote><p>不过这次<strong>C</strong>调用到 Object sharedInstance =getSingleton(beanName); 的时候, <strong>A</strong>已经存在了。这次调用虽然没有从一级缓存 （singletonObjects） 中获取到A，但是 <strong>A</strong>在<strong>创建中</strong>，所以进入判断在这里执行完之后，<strong>A</strong>从三级缓存升级到二级缓存。</p><blockquote><p>这里获取到的是 <strong>A</strong> 的引用，注意 <strong>A</strong>这时候还没创建完成，只是引用。所以这里赋值的是 <strong>A</strong>的引用。</p></blockquote><p>填充属性的时候，spring会提前将已经实例化的bean通过ObjectFactory半成品暴露出去，<strong>为什么称为半成品是因为这时候的bean对象实例化，但是未进行属性填充，是一个不完整的bean实例对象</strong>，这时我们会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存earlySingletonObjects中，而此时<strong>C</strong>注入的是一个半成品的实例<strong>A</strong>对象，不过随着<strong>C</strong>初始化完成后，A会继续进行后续的初始化操作，最终<strong>C</strong>会注入的是一个完整的<strong>A</strong>实例，因为在内存中它们是同一个对象。</p><p>到这里 <strong>C</strong> 就创建完了。如上所示，<strong>C</strong>创建完成之后，会执行addSingleton方法，然后会将 <strong>C</strong>添加到一级缓存和已注册列表中，同时从二级三级缓存中删除 C。继续执行<strong>B</strong> 和 <strong>A</strong>的属性赋值以及后续的初始化流程。最后 <strong>B</strong> 和<strong>A</strong> 都进入一级缓存。至此，循环依赖解决完毕。</p><blockquote><p>对于“prototype”作用域bean, Spring 容器无法完成依赖注入，因为Spring容器不进行缓存“prototype”作用域的bean ，因此无法提前暴露一个创建中的bean。</p></blockquote><h1 id="半成品bean">5.半成品"Bean"</h1><p>半成品的bean可能不太理解，我们可以看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String number;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(student);<br><br>        student.setNumber(<span class="hljs-string">&quot;01&quot;</span>);<br>        student.setAge(<span class="hljs-string">&quot;18&quot;</span>);<br>        student.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        System.out.println(student);<br>    &#125;<br><br>---&gt;<br>com.example.demo.aaa.Student@36baf30c<br>com.example.demo.aaa.Student@36baf30c<br></code></pre></td></tr></table></figure><p>如上，打印的地址是一样的，第一次打印的就是所谓的"<strong>半成品</strong>"。虽然它此时的属性没有赋值，但是它是可以使用（被别人引用）的半成品。在最终使用的时候，它经过一系列执行，注入的就是成熟的bean对象。</p><h1id="为什么要使用三级缓存仅仅使用二级缓存行吗">6.为什么要使用三级缓存，仅仅使用二级缓存行吗？</h1><p>使用 earlySingletonObjects 和 singletonObjects两级缓存，一个存放早期对象，一个存放初始化完成后的对象，也能实现同样的功能，singletonFactories好像显得有些多此一举。其实不是的，对于普通对象，确实只要返回刚创建完的早期对象就好了，二级缓存已经可以解决循环依赖。</p><p>但如果A 的原始对象进行了 AOP 产生了一个代理对象，此时就会出现，对于 A而言，如果仅有二级缓存，它的 Bean 对象其实应该是 AOP之后的代理对象，而此时的B 的 a 属性对应的并不是 AOP之后的代理对象，这就产生了冲突：<strong>B 依赖的 A 和最终的 A不是同一个对象</strong>，因此才出现三级缓存，singletonFactories（三级缓存） 根据 beanName 得到一个 ObjectFactory，然后执行 ObjectFactory ，也就是执行 getEarlyBeanReference方法，此时会得到一个 A 原始对象经过 AOP之后的代理对象，然后把该代理对象放入 earlySingletonObjects中。后续为B所用，此时得到的A都是代理对象。</p><p>链接：https://segmentfault.com/a/1190000023647227</p><p>总结：</p><blockquote><p>Spring 的设计原则是在 <strong>Bean初始化完成之后才为其创建代理，</strong>如果只有二级缓存，这样违背了Spring设计原则。Spring结合AOP跟Bean的生命周期，是在Bean创建完全之后----通过AnnotationAwareAspectJAutoProxyCreator这个---后置处理器来完成的，在这个后置处理的postProcessAfterInitialization方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。<strong>Spring需要三级缓存的目的是为了在没有循环依赖的情况下，延迟代理对象的创建，使Bean 的创建符合 Spring 的设计原则。</strong></p></blockquote><h1id="为什么spring无法解决构造器的循环依赖">7.为什么Spring无法解决构造器的循环依赖？</h1><p>在spring中，springIOC容器在运行时检测到构造函数注入循环依赖则直接抛出异常，因此要避免构造器的循环依赖而使用setter注入。spring也会自动解决基于setter注入的循环依赖。</p><blockquote><p>Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化，但还没初始化的状态。而构造器是完成实例化的，所以构造器的循环依赖Spring并没有解决，bean都是需要可以先被实例化才可以的，所以这也就是为什么构造器依赖可能会失败的原因。假如A构造器依赖B，因为实例化A需要先调用A的构造函数，发现依赖B，那么需要去初始化B，但是B也依赖A，不管B是通过构造器注入还是setter注入，此时由于A没有被实例化，没有放入三级缓存，所以B无法被初始化，所以spring会直接报错。反之，如果A通过setter注入的话，那么则可以通过构造函数先实例化，放入缓存，然后再填充属性，这样的话不管B是通过setter还是构造器注入A，都能在缓存中获取到，于是可以初始化。</p><p><strong>解决办法：</strong></p><p>​Spring构造器注入循环依赖的解决方案是@Lazy，其基本思路是：对于强依赖的对象，一开始并不注入对象本身，而是注入其代理对象，以便顺利完成实例的构造，形成一个完整的对象，这样与其它应用层对象就不会形成互相依赖的关系；当需要调用真实对象的方法时，通过TargetSource去拿到真实的对象[DefaultListableBeanFactory#doResolveDependency]，然后通过反射完成调用</p></blockquote><h1id="什么情况下循环依赖可以被处理">8.什么情况下循环依赖可以被处理？</h1><p>首先要明确一点，Spring解决循环依赖是有前置条件的</p><ol type="1"><li>出现循环依赖的Bean必须要是单例</li><li>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</li></ol><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceA</span><span class="hljs-params">(ServiceB b)</span>&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceB</span> &#123;<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceB</span><span class="hljs-params">(ServiceA a)</span>&#123;<br>     <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：</p><blockquote><p>Caused by:org.springframework.beans.factory.BeanCurrentlyInCreationException:Error creating bean with name 'a': Requested bean is currently increation: Is there an unresolvable circular reference?</p></blockquote><p>如下四种情况的循环依赖测试</p><table><thead><tr class="header"><th style="text-align: left;">依赖情况</th><th style="text-align: left;">依赖注入方式</th><th style="text-align: left;">循环依赖是否被解决</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用setter方法注入</td><td style="text-align: left;">是</td></tr><tr class="even"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用属性自动注入</td><td style="text-align: left;">是</td></tr><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用构造器注入</td><td style="text-align: left;">否</td></tr><tr class="even"><td style="text-align: left;">AB相互依赖（循环依赖）</td><tdstyle="text-align: left;">A中注入B的方式为setter方法，B中注入A的方式为构造器</td><td style="text-align: left;">是</td></tr><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><tdstyle="text-align: left;">B中注入A的方式为setter方法，A中注入B的方式为构造器</td><td style="text-align: left;">否</td></tr></tbody></table><blockquote><p>不是只有在setter方法注入的情况下循环依赖才能被解决，即使存在构造器注入的场景下，循环依赖依然被可以被正常处理掉。</p><p>所以日常所说的只解决setter注入方式是错误的。spring解决循环依赖是不能全是构造器注入的方式。</p></blockquote><p><strong>为什么在下表中的第四种情况的循环依赖能被解决，而第五种情况不能被解决呢？</strong></p><p>是因为Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建，A会首先暴露出来。然后才回去注入B，B再注入A的时候，就可以通过三级缓存拿到A了。此时的A是一个实例化的一个中间状态的Bean.</p><p>反之：如果使用如果A先使用构造器，在注入的时候，他会去找B，B再注入A，可此时A并没有暴露(因为还没有实例化成功)，也就失败了。</p><h1 id="read-more">9.Read more</h1><p>:lollipop::https://developer.aliyun.com/article/766880</p><p>:lollipop::https://juejin.cn/post/6985337310472568839</p><p>:lollipop::https://segmentfault.com/a/1190000023647227</p><p>:lollipop::https://blog.csdn.net/weixin_48777366/article/details/123645686</p><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html</p><p>:lollipop::https://www.zhihu.com/question/438247718/answer/1730527725</p><p>:lollipop::https://juejin.cn/post/6844903843596107790</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="/2022/05/20/framework/spring/2022-05-20_Spring%20Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/20/framework/spring/2022-05-20_Spring%20Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="spring中bean的生命周期">1.Spring中bean的生命周期</h1><p>在spring中，bean是springIOC容器实例化、组装和管理的对象，因此spring中的bean的生命周期也由spring管理。</p><p>bean的生命周期分为4个阶段为：</p><ul><li>实例化 - Instantiation</li><li>初始化 - Populate</li><li>使用 - Initialization</li><li>销毁 - Destruction</li></ul><h1 id="bean的生命周期图">2.Bean的生命周期图</h1><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20220731180239724.png" /></p><h1 id="代码测试">3.代码测试</h1><h2 id="person">3.1 <strong>Person</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xxx.beancycle.instant;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanNameAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.DisposableBean;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> javax.annotation.PreDestroy;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, DisposableBean &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> phone;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【构造器】调用Person的构造器实例化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【注入属性】注入属性name:&quot;</span> + name);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【注入属性】注入属性address:&quot;</span>+address);<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> phone;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPhone</span><span class="hljs-params">(<span class="hljs-type">int</span> phone)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【注入属性】注入属性phone:&quot;</span>+ phone);<br>        <span class="hljs-built_in">this</span>.phone = phone;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [address=&quot;</span> + address + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, phone=&quot;</span><br>                + phone + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//@PostConstruct--&gt;InitializingBean接口方法(afterPropertiesSet)--&gt;自定义的方法</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PostConstruct</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;PostConstruct!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这是InitializingBean接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>+<span class="hljs-built_in">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myInit</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;</span>);<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">//@PreDestroy--&gt;DiposibleBean接口方法(destroy)--&gt;自定义的方法</span><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PreDestroy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;PreDestroy!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//这是DiposibleBean接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myDestory</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;</span>);<br>    &#125;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>三个属性：name、address、phone。且分别有3个方法@PostConstruct、afterPropertiesSet()、myInit()。针对于bean的初始化方法。同理，有3个方法对应bean销毁调用的方法。</p></blockquote><h2 id="mybeanpostprocessor">3.2 MyBeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是BeanPostProcessor实现类构造器！！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object arg0, String arg1)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性1进行更改！&quot;</span>);<br>        <span class="hljs-keyword">return</span> arg0;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object arg0, String arg1)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性1进行更改！&quot;</span>);<br>        <span class="hljs-keyword">return</span> arg0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现<code>BeanPostProcessor</code>接口，覆写postProcessBeforeInitialization、postProcessAfterInitialization方法。</p></blockquote><h2 id="myinstantiationawarebeanpostprocessor">3.3MyInstantiationAwareBeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span><br>        <span class="hljs-title class_">InstantiationAwareBeanPostProcessorAdapter</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInstantiationAwareBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;</span>);<br>    &#125;<br>    <br>        <span class="hljs-comment">// 接口方法、实例化Bean之前调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//实例化后置方法调用:return false时，不再走spring的逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object o, String s)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;:=============&quot;</span>+o +<span class="hljs-string">&quot;---------&quot;</span> + s);<br>        System.out.println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口方法、设置某个属性时调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessPropertyValues</span><span class="hljs-params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> pvs;<br>    &#125;<br><br>    <span class="hljs-comment">//初始化前置方法调用</span><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="hljs-comment">//        System.out.println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInitialization方法对属性2进行更改&quot;);</span><br><span class="hljs-comment">//        return bean;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    // 接口方法、初始化Bean之后调用</span><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="hljs-comment">//        System.out.println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法对属性2进行更改&quot;);</span><br><span class="hljs-comment">//        return bean;</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现MyInstantiationAwareBeanPostProcessor，只覆写postProcessPropertyValues、postProcessBeforeInstantiation、postProcessAfterInstantiation三个接口。它也实现了<code>BeanPostProcessor</code>接口，在上文我们已经覆写postProcessBeforeInitialization、postProcessAfterInitialization方法。此处就不用再次覆写。---可以覆写，只不过会先执行BeanPostProcessor的实现类，然后再依次执行。</p></blockquote><h2 id="spring-config.xml">3.4 spring-config.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>       <span class="hljs-comment">&lt;!--IoC的注解扫描--&gt;</span><br> <span class="hljs-comment">&lt;!--    &lt;context:component-scan base-package=&quot;com.xxx.beancycle.instant&quot;&gt;&lt;/context:component-scan&gt;--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.MyBeanPostProcessor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;instantiationAwareBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.MyInstantiationAwareBeanPostProcessor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;myInit&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;myDestory&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;广州&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15900&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过setter注入的方式将上述bean对象注入到ioc容器中。</p></blockquote><h2 id="test">3.5 Test</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBean</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:com/xxx/beancycle/spring-config.xml&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;容器初始化成功！！！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;现在开始关闭容器！！！&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;person&quot;</span>, Person.class);<br>    System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>+bean);<br>    applicationContext.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台打印如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">17:20:52,762  INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [com/xxx/beancycle/spring-config.xml]<br>这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性name:张三<br>【注入属性】注入属性address:广州<br>【注入属性】注入属性phone:15900<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性1进行更改！<br>==================Person [address=广州, name=张三, phone=15900]<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性1进行更改！<br>容器初始化成功！！！<br>现在开始关闭容器！！！<br>-----------Person [address=广州, name=yangxin, phone=177]<br>17:20:52,892  INFO ClassPathXmlApplicationContext:984 - Closing org.springframework.context.support.ClassPathXmlApplicationContext@3ac3fd8b: startup <span class="hljs-built_in">date</span> [Fri Mar 03 17:20:52 CST 2023]; root of context hierarchy<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br><br>Process finished with <span class="hljs-built_in">exit</span> code 0<br><br></code></pre></td></tr></table></figure><h1 id="详解日志">4.详解日志</h1><h2 id="实例化">4.1 实例化</h2><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230303172218383.png" /></p><p><strong>对应下列日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br></code></pre></td></tr></table></figure><blockquote><p>首先，spring会实例化MyBeanPostProcessor、MyInstantiationAwareBeanPostProcessor这些实现或者继承spring的类。然后再实例化我们定义的"bean"，此处实例化Person类时，会优先执行InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法，也就是实例化前置方法。改方法允许我们在实例化对象的时候，可以对bean进行前置处理。然后通过反射实例化对象，</p><p>实例化完成之后会调用postProcessAfterInstantiation方法，<strong>该方法返回布尔值，如果返回false则不执行postProcessPropertyValues</strong>方法，也就是不会进行属性修改。</p><p>剩余的初始化方法会执行，也就是BeanPostProcessor的postProcessBeforeInitialization与postProcessAfterInitialization方法会执行。如果在这些方法里对bean都没有进行任何处理，则该bean的所有属性值均为默认值。</p></blockquote><p>如下是返回false的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInitialization方法对属性2进行更改<br>==================Person [address=null, name=null, phone=0]<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法对属性2进行更改<br>容器初始化成功！！！<br>现在开始关闭容器！！！<br>-----------Person [address=null, name=null, phone=0]<br>17:33:33,215  INFO ClassPathXmlApplicationContext:984 - Closing org.springframework.context.support.ClassPathXmlApplicationContext@3ac3fd8b: startup <span class="hljs-built_in">date</span> [Fri Mar 03 17:33:33 CST 2023]; root of context hierarchy<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br><br>-------&gt;打印的Person对象的属性值为空。<br></code></pre></td></tr></table></figure><h2 id="初始化">4.2 初始化</h2><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230303174845027.png" /></p><p><strong>对应下列日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">【注入属性】注入属性name:张三<br>【注入属性】注入属性address:广州<br>【注入属性】注入属性phone:15900<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性1进行更改！<br>==================Person [address=广州, name=张三, phone=15900]<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性1进行更改！<br></code></pre></td></tr></table></figure><p>我们可以看到在xml里、配置了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;myInit&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;myDestory&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;广州&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15900&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过postProcessPropertyValues方法给bean填充属性、填充的就是我们在xml配置的属性。</p><p>aware接口我们暂时不用管。</p><p>然后执行BeanPostProcessor的postProcessBeforeInitialization方法，对bean进行初始化前置操作处理。</p><p>然后执行初始化方式（上文没有执行@PostConstruct标注的方法是因为我没有让spring扫描Persond对象。因此注解没有生效）</p></blockquote><p><strong>初始化方法优先级：</strong></p><blockquote><p><span class="citation"data-cites="PostConstruct">@PostConstruct</span>---&gt;InitializingBean.afterPropertiesSet()---&gt;xml配置的Init-method</p></blockquote><h2 id="销毁">4.3 销毁</h2><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230303182021701.png" /></p><p><strong>对应下列日志：</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-<span class="hljs-keyword">method</span>】调用&lt;<span class="hljs-title function_">bean</span>&gt;的<span class="hljs-title function_">destroy</span>-<span class="hljs-title function_">method</span>属性指定的初始化方法<br></code></pre></td></tr></table></figure><p><strong>销毁方法优先级：</strong></p><blockquote><p><span class="citation"data-cites="PreDestroy">@PreDestroy</span>---&gt;DiposibleBean.destory()---&gt;xml配置的destroy-method</p></blockquote><h1 id="beanfactorypostprocessor">5.BeanFactoryPostProcessor</h1><ul><li><strong>BeanPostProcessor</strong></li><li><strong>InstantiationAwareBeanPostProcessor</strong></li></ul><p>这两兄弟可能是Spring扩展中<strong>最重要</strong>的两个接口！InstantiationAwareBeanPostProcessor作用于<strong>实例化</strong>阶段的前后，BeanPostProcessor作用于<strong>初始化</strong>阶段的前后。</p><p>说到BeanPostProcessor，不得不提一下<code>BeanFactoryPostProcessor</code>，BeanFactoryPostProcessor和BeanPostProcessor，这两个接口，都是Spring初始化bean时对外暴露的扩展点。两个接口名称看起来很相似，但作用及使用场景却不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Modify the application context&#x27;s internal bean factory after its standard</span><br><span class="hljs-comment"> * initialization. All bean definitions will have been loaded, but no beans</span><br><span class="hljs-comment"> * will have been instantiated yet. This allows for overriding or adding</span><br><span class="hljs-comment"> * properties even to eager-initializing beans.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanFactory the bean factory used by the application context</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们新写一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanFactoryPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是BeanFactoryPostProcessor实现类构造器！！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory arg0)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanFactoryPostProcessor调用postProcessBeanFactory方法&quot;</span>);<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> arg0.getBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues());<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues().get(<span class="hljs-string">&quot;address&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues().get(<span class="hljs-string">&quot;name&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues().get(<span class="hljs-string">&quot;phone&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;----------:操作bean的定义&quot;</span>);<br>        bd.getPropertyValues().addPropertyValue(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;110&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>并且通过xml注入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanFactoryPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.MyBeanFactoryPostProcessor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再运行测试类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">这是BeanFactoryPostProcessor实现类构造器！！<br>BeanFactoryPostProcessor调用postProcessBeanFactory方法<br>-=-=-=-=-=-=PropertyValues: length=3; bean property <span class="hljs-string">&#x27;name&#x27;</span>; bean property <span class="hljs-string">&#x27;address&#x27;</span>; bean property <span class="hljs-string">&#x27;phone&#x27;</span><br>-=-=-=-=-=-=TypedStringValue: value [广州], target <span class="hljs-built_in">type</span> [null]<br>-=-=-=-=-=-=TypedStringValue: value [张三], target <span class="hljs-built_in">type</span> [null]<br>-=-=-=-=-=-=TypedStringValue: value [15900], target <span class="hljs-built_in">type</span> [null]<br>----------:操作bean的定义<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性name:张三<br>【注入属性】注入属性address:广州<br>【注入属性】注入属性phone:110  <br>... ...<br></code></pre></td></tr></table></figure><p>我们会发现我们在xml里定义的参数已经被改变了。以前的<code>【注入属性】注入属性phone:15900</code>变为<code>【注入属性】注入属性phone:110</code>。</p><blockquote><p>实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前<strong>读取配置元数据，并可以根据需要进行修改</strong>，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置'order'属性来控制各个BeanFactoryPostProcessor的执行次序。</p></blockquote><h1 id="aware接口">6.Aware接口</h1><p>为了更好的理解生命周期，我们前面暂时没有解释生命周期图中的第六步，也就是<code>Aware</code>接口，在此处我们来讲一下Aware接口。我们看一下spring对aware接口的解释：</p><blockquote><p>A marker superinterface indicating that a bean is eligible to benotified by the Spring container of a particular framework objectthrough a callback-style method. The actual method signature isdetermined by individual subinterfaces but should typically consist ofjust one void-returning method that accepts a single argument. Note thatmerely implementing Aware provides no default functionality. Rather,processing must be done explicitly, for example in a BeanPostProcessor.Refer to ApplicationContextAwareProcessor for an example of processingspecific *Aware interface callbacks.</p></blockquote><p>含义：</p><blockquote><p>一个标记超接口，指示bean有资格通过回调样式方法被Spring容器通知特定框架对象。实际的方法签名由各个子接口确定，但通常只应由一个接受单个参数的返回空值的方法组成。</p><p>注意，仅实现Aware不提供默认功能。相反，处理必须显式完成，例如在BeanPostProcessor中。有关处理特定*Aware接口回调的示例，请参阅ApplicationContextAwareProcessor。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanClassLoaderAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanNameAware;<br><span class="hljs-keyword">import</span> org.springframework.context.*;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportAware;<br><span class="hljs-keyword">import</span> org.springframework.context.weaving.LoadTimeWeaverAware;<br><span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ResourceLoader;<br><span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;<br><span class="hljs-keyword">import</span> org.springframework.instrument.classloading.LoadTimeWeaver;<br><span class="hljs-keyword">import</span> org.springframework.jmx.export.notification.NotificationPublisher;<br><span class="hljs-keyword">import</span> org.springframework.jmx.export.notification.NotificationPublisherAware;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StringValueResolver;<br><span class="hljs-keyword">import</span> org.springframework.web.context.ServletConfigAware;<br><span class="hljs-keyword">import</span> org.springframework.web.context.ServletContextAware;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletConfig;<br><span class="hljs-keyword">import</span> javax.servlet.ServletContext;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllAwareInterface</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>, BeanClassLoaderAware,<br>        BeanFactoryAware, EnvironmentAware, EmbeddedValueResolverAware,<br>        ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware,<br>        ApplicationContextAware, ServletContextAware, LoadTimeWeaverAware, ImportAware ,<br>        NotificationPublisherAware, ServletConfigAware, ApplicationStartupAware  &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-comment">// BeanNameAware作用：让Bean对Name有知觉</span><br>        <span class="hljs-comment">//这个方法只是简单的返回我们当前的beanName,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用</span><br>        System.out.println(<span class="hljs-string">&quot;1 我是 BeanNameAware 的 setBeanName 方法  ---参数：name，内容：&quot;</span>+ name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2 我是 BeanClassLoaderAware 的 setBeanClassLoader 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 注意： 如果使用 @Configuration 注解的话，setBeanFactory方法会执行2次，</span><br>        System.out.println(<span class="hljs-string">&quot;3 我是 BeanFactoryAware 的 setBeanFactory 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnvironment</span><span class="hljs-params">(Environment environment)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;4 我是 EnvironmentAware 的 setEnvironment 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver stringValueResolver)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;5 我是 EmbeddedValueResolverAware 的 setEmbeddedValueResolver 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResourceLoader</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;6 我是 ResourceLoaderAware 的 setResourceLoader 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher applicationEventPublisher)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;7 我是 ApplicationEventPublisherAware 的 setApplicationEventPublisher 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageSource</span><span class="hljs-params">(MessageSource messageSource)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;8 我是 MessageSourceAware 的 setMessageSource 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">//实现ApplicationContextAware接口的类，都可以取得applicationContext</span><br>        System.out.println(<span class="hljs-string">&quot;9 我是 ApplicationContextAware 的 setApplicationContext 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>        <span class="hljs-comment">//实现ServletContextAware接口的类，都可以取得ServletContext</span><br>        System.out.println(<span class="hljs-string">&quot;10 我是 ServletContextAware 的 setServletContext 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLoadTimeWeaver</span><span class="hljs-params">(LoadTimeWeaver loadTimeWeaver)</span> &#123;<br>        <span class="hljs-comment">//LoadTimeWeaver 简称LTW，LTW是AOP的一种实现方式，此方法是为了获取Aop织入的对象，使用的织入方式是：类加载期织入，</span><br>        <span class="hljs-comment">// 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是LTW是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法</span><br>        <span class="hljs-comment">// 只有在使用 @EnableLoadTimeWeaving 或者存在 LoadTimeWeaver 实现的 Bean 时才会调用，顺序也很靠后</span><br>        System.out.println(<span class="hljs-string">&quot;11 我是 LoadTimeWeaverAware 的 setLoadTimeWeaver 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImportMetadata</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>        <span class="hljs-comment">//只有被其他配置类 @Import(XX.class) 时才会调用，这个调用对 XX.class 中的所有 @Bean 来说顺序是第 1 的。</span><br>        System.out.println(<span class="hljs-string">&quot;12 我是 ImportAware 的 setImportMetadata 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNotificationPublisher</span><span class="hljs-params">(NotificationPublisher notificationPublisher)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;13 我是 NotificationPublisherAware 的 setNotificationPublisher 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServletConfig</span><span class="hljs-params">(ServletConfig servletConfig)</span> &#123;<br>        <span class="hljs-comment">//实现ServletContextAware接口的类，都可以取得ServletContext</span><br>        System.out.println(<span class="hljs-string">&quot;14 我是 ServletConfigAware 的 setServletConfig 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationStartup</span><span class="hljs-params">(ApplicationStartup applicationStartup)</span> &#123;<br>        <span class="hljs-comment">//容器启动成功后，通过ApplicationStartup进行相应处理。</span><br>        System.out.println(<span class="hljs-string">&quot;15 我是 ApplicationStartupAware 的 setApplicationStartup 方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>spring中所有的<code>aware</code>接口：</p><p><code>ApplicationEventPublisherAware</code>,<code>ApplicationStartupAware</code>, <code>BeanClassLoaderAware</code>,<code>BeanFactoryAware</code>, <code>BeanNameAware</code>,<code>EmbeddedValueResolverAware</code>, <code>EnvironmentAware</code>,<code>ImportAware</code>, <code>LoadTimeWeaverAware</code>,<code>MessageSourceAware</code>,<code>NotificationPublisherAware</code>,<code>ResourceLoaderAware</code>, <code>SchedulerContextAware</code>,<code>ServletConfigAware</code>, <code>ServletContextAware</code></p><p>本着最简单的原则，本文不会讲aware接口全部讲解，只讲最常用的aware接口。</p><h2 id="applicationcontextaware">6.1 ApplicationContextAware</h2><p>该接口是最常用的一个注解，通过实现ApplicationContextAware接口，我们能够得到applicationContext，因此我们可以再spring容器启动的试试，对容器进行处理。</p><h2 id="applicationstartupaware">6.2 ApplicationStartupAware</h2><p>通过实现ApplicationStartupAware接口，可以在容器启动成功后，通过ApplicationStartup进行相应处理。</p><h2 id="beanfactoryaware">6.3 BeanFactoryAware</h2><p>让Bean获取配置他们的BeanFactory的引用。</p><h2 id="beannameaware">6.4 BeanNameAware</h2><p>调用BeanNameAware接口的实现类中的setBeanName方法，获取容器中 Bean的名称，</p><h2 id="environmentaware">6.5 EnvironmentAware</h2><p>实现了EnvironmentAware接口重写setEnvironment方法后，在工程启动时可以获得application.properties、xml、yml 的配置文件配置的属性值。</p><h1 id="总结">7. 总结</h1><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/spring生命周期.png"alt="spring生命周期" /><figcaption aria-hidden="true">spring生命周期</figcaption></figure><p><strong>总结：</strong></p><p>spring的生命周期分为<code>实例化</code>、<code>属性赋值</code>、<code>初始化</code>、<code>销毁</code></p><ul><li>如果 BeanFactoryPostProcessor 和 Bean 关联,则调用postProcessBeanFactory方法.(即首<strong>先尝试从Bean工厂中获取Bean</strong>)</li><li>如果 InstantiationAwareBeanPostProcessor 和 Bean关联，则调用postProcessBeforeInstantiation方法</li><li>根据配置情况调用 Bean 构造方法<strong>实例化 Bean</strong>。</li><li>如果 InstantiationAwareBeanPostProcessor 和 Bean关联，则调用postProcessAfterInstantiation方法和postProcessPropertyValues方法（前几个版本叫postProcessProperty）</li><li>调用setter方法完成 Bean 中<strong>属性注入</strong>。</li><li>调用xxxAware接口<ul><li>第一类Aware接口<ul><li>如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的setBeanName() 方法传入当前 Bean 的 id 值。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，则 Spring 调用setBeanClassLoader() 方法传入classLoader的引用。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用setBeanFactory() 方法传入当前工厂实例的引用。</li></ul></li><li>第二类Aware接口<ul><li>如果 Bean 实现了 EnvironmentAware 接口，则 Spring 调用setEnvironment() 方法传入当前 Environment 实例的引用。</li><li>如果 Bean 实现了 EmbeddedValueResolverAware 接口，则 Spring 调用setEmbeddedValueResolver() 方法传入当前 StringValueResolver实例的引用。</li><li>如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用setApplicationContext() 方法传入当前 ApplicationContext实例的引用。</li><li>... ...</li></ul></li></ul></li></ul><hr /><ul><li>如果 <code>BeanPostProcessor</code> 和 Bean 关联，则 Spring将调用该接口的预初始化方法<code>postProcessBeforeInitialzation()</code>对 Bean进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</li><li><strong>Bean初始化前置方法</strong><ul><li>如果 Bean有执行@PostConstruct注解的方法，则调用该初始化方法。</li><li>如果 Bean 实现了<code>InitializingBean</code> 接口，则 调用<code>afterPropertiesSet()</code> 方法。</li><li>如果在配置文件中通过 <strong>init-method</strong>属性指定了初始化方法，则调用该初始化方法。</li></ul></li><li>如果 BeanPostProcessor 和 Bean 关联，则 Spring将调用该接口的初始化方法<code>postProcessAfterInitialization()</code>。此时，Bean已经可以被应用系统使用了。</li><li>如果在 <code>&lt;bean&gt;</code> 中指定了该 Bean 的作用范围为scope="singleton"，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring对该 Bean 的生命周期管理；如果在 <code>&lt;bean&gt;</code> 中指定了该Bean 的作用范围为 scope="prototype"，则将该 Bean交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</li></ul><hr /><ul><li><strong>Bean销毁前置方法</strong><ul><li>如果 Bean有执行@PreDestroy注解的方法，则调用该初始化方法。</li><li>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory()方法将 Spring 中的 Bean 销毁</li><li>如果在配置文件中通过 <strong>destory-method</strong> 属性指定了 Bean的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</li></ul></li></ul><hr /><p><strong>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类</strong>：(结合上图，需要有如下顶层思维)</p><ul><li><strong>Bean自身的方法</strong>：这个包括了Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的init-method和destroy-method指定的方法</li><li><strong>Bean级生命周期接口方法</strong>：这个包括了BeanNameAware、BeanFactoryAware、ApplicationContextAware；当然也包括InitializingBean和DiposableBean这些接口的方法（可以被@PostConstruct和<spanclass="citation"data-cites="PreDestroy注解替代">@PreDestroy注解替代</span>)</li><li><strong>容器级生命周期接口方法</strong>：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor这两个接口实现，一般称它们的实现类为“后处理器”。</li><li><strong>工厂后处理器接口方法</strong>：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor,CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li></ul><h1 id="read-more">8.Read more</h1><p>:lollipop::https://blog.csdn.net/caihaijiang/article/details/35552859</p><p>:lollipop::https://www.cnblogs.com/zrtqsk/p/3735273.html</p><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Core-IOC</title>
    <link href="/2022/05/15/framework/spring/2022-05-15_Spring%20Core-IOC/"/>
    <url>/2022/05/15/framework/spring/2022-05-15_Spring%20Core-IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="spring-bean是什么">1. Spring Bean是什么？</h1><p>我们常说IOC容器，<em>容器</em>是指用以容纳物料并以壳体为主的基本装置。在Spring中，IOC容器同样也是用来容纳“东西”的。但是这个东西在Spring中变成了bean对象。</p><p>在 Spring 中，构成应用程序主干的对象和由 Spring IoC容器管理的对象称为 Bean。Bean 是由 Spring IoC容器实例化、组装和管理的对象。否则，Bean只是应用程序中的许多对象之一。Bean以及它们之间的依赖关系反映在容器使用的配置元数据中。</p><h1 id="spring-ioc">2. Spring IoC</h1><h2 id="spring-ioc简介">2.1 Spring IoC简介</h2><p><code>IoC（Inversion of Control）</code>就是常说的控制反转。依赖注入(DI) 是 IoC的一种特殊形式，对象仅通过构造函数参数、工厂方法的参数或在对象实例上设置的属性来定义其依赖关系（即它们使用的其他对象）。由工厂方法构造或返回。然后，IoC容器在创建 bean 时注入这些依赖项。这个过程从根本上来说是 bean本身的逆过程（因此得名“控制反转”），通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖项的实例化或位置。</p><p><code>org.springframework.beans</code>和包<code>org.springframework.context</code>是Spring Framework 的 IoC 容器的基础。该 <ahref="https://docs.spring.io/spring-framework/docs/6.1.6/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>接口提供了能够管理任何类型对象的高级配置机制。 <ahref="https://docs.spring.io/spring-framework/docs/6.1.6/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>是<code>BeanFactory</code>接口的子接口。它在<code>BeanFactory</code>接口功能基础上添加了更多企业特定的功能。如aop特性、事件发布功能等等，因此我们使用最多的也是<code>ApplicationContext</code>。</p><blockquote><p>Ioc—Inversion ofControl，即“控制反转”，<strong>不是什么技术，而是一种设计思想</strong>。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><p><code>BeanFactory</code>提供了配置框架和基本功能，<code>ApplicationContext</code>在此基础上添加了更多企业特定的功能。</p></blockquote><h2 id="控制反转">2.2 控制反转</h2><p><code>org.springframework.context.ApplicationContext</code> 代表Spring IoC容器，负责实例化、配置和组装Bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。</p><p>配置元数据以 XML、Java annotations或 JavaCode表示。组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p><p>讲解控制反转之前，我们先来思考一下：</p><ul><li><strong>谁控制谁，控制什么</strong>？</li></ul><p>传统JavaSE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是<strong>IoC容器控制了对象</strong>；控制什么？那就是主要控制了<strong>外部资源获取</strong>（不只是对象包括比如文件等）。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152049160.png"alt="image-20230228152049160" /><figcaption aria-hidden="true">image-20230228152049160</figcaption></figure><ul><li><strong>为何是反转，哪些方面反转了</strong>?</li></ul><p>有反转就有正转，传统应用程序是由<strong>我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象</strong>；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152120929.png"alt="image-20230228152120929" /><figcaption aria-hidden="true">image-20230228152120929</figcaption></figure><p>主动创建：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/spring-framework-ioc-1.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>IOC容器注入：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/spring-framework-ioc-2.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，<strong>把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</strong>。</p></blockquote><h1 id="didependency-injection">3. DI—Dependency Injection</h1><p>即依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由<strong>容器动态的将某个依赖关系注入到组件之中。</strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><blockquote><p>控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p></blockquote><ul><li><strong>谁依赖谁？</strong></li></ul><p>在spring项目中，将对象理解为Bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，<strong>bean对象的创建是依赖容器的</strong></p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152658783.png"alt="image-20230228152658783" /><figcaption aria-hidden="true">image-20230228152658783</figcaption></figure><ul><li><strong>谁注入谁?</strong></li></ul><p>通过容器注入了bean对象，而且这个过程是自动化的，也就是说<strong>容器会自动找到和bean对象匹配的类型实例注入到对象中</strong>。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152243110.png"alt="image-20230228152243110" /><figcaption aria-hidden="true">image-20230228152243110</figcaption></figure><h1 id="ioc配置元数据configuration-metadata">4.<strong>IoC配置元数据(Configuration metadata)</strong></h1><p>容器通过读取配置元数据获取关于实例化、配置和组装什么对象的指令。配置元数据用XML、 Java 注释或 Java 代码表示。目前的主流方式是 <strong>注解 + Java配置</strong></p><blockquote><p>元数据(metadata)描述的是“自身”的一些信息，包括</p><p>ClassMetadata 描述的是class类的基本信息</p><p>AnnotationMetadata描述的是注解信息</p><p>MethodMetadata描述的是方法的信息</p></blockquote><h2 id="xml方式">4.1 XML方式</h2><p>顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。</p><ul><li><strong>优点</strong>：可以使用于任何场景，结构清晰，通俗易懂，所以xml方式是最全面的配置元数据的方式</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;userDao1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.dao.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>     <br>     <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;services.xml&quot;</span>/&gt;</span><br>     <span class="hljs-comment">&lt;!--使用一个或多个出现的 &lt; import/&gt; 元素从另一个文件加载 bean 定义前导斜杠被忽略，但是考虑到这些路径</span><br><span class="hljs-comment">相对的，最好不要使用斜杠--&gt;</span><br>     <br>     <span class="hljs-comment">&lt;!--使用Bean节点来创建对象id属性标识着对象，不能重复name属性代表着要创建对象的类全名--&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="java-配置">4.2Java 配置</h2><p>从 Spring 3.0开始，Spring JavaConfig 项目提供的许多特性成为核心Spring 框架的一部分。因此，您可以使用 Java 而不是 XML文件在应用程序类之外定义bean。要使用这些新特性，请参见@Configuration、<span class="citation"data-cites="bean">@bean</span>、<span class="citation"data-cites="import">@import</span> 和@DependsOn 注释</p><ol type="1"><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理</li></ol><blockquote><p><span class="citation"data-cites="Configuration注解声明为配置类">@Configuration注解声明为配置类</span>，<spanclass="citation"data-cites="Bean来修饰方法">@Bean来修饰方法</span>，该方法返回一个对象，容器中bean的ID默认为方法名（方法名建议与实例名相同（首字母小写）），Spring内部会将该对象加入到Spring容器中。</p></blockquote><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configuration</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> UserDao <span class="hljs-title function_">userDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br>        System.out.println(<span class="hljs-string">&quot;我是在configuration中的&quot;</span>+userDao);<br>        <span class="hljs-keyword">return</span> userDao;<br>    &#125;<br>     <br>    <span class="hljs-comment">//可以不写，默认为方法名</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserServiceImpl <span class="hljs-title function_">userService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.setUserDao(userDao());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Bird <span class="hljs-title function_">bird</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        bird.setBirdAge(<span class="hljs-number">18</span>);<br>        bird.setBirDid(<span class="hljs-string">&quot;1&quot;</span>);<br>        bird.setBirdName(<span class="hljs-string">&quot;小小鸟&quot;</span>);<br>        <span class="hljs-keyword">return</span> bird;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解方式">4.3 注解方式</h2><p>Spring 2.5引入了对基于注释的配置元数据的支持：<ahref="https://docs.spring.io/spring-framework/docs/5.0.x/spring-framework-reference/core.html#beans-annotation-config">Annotation-basedconfiguration</a>，使得我们可以通过简单的注解方式即可使用spring容器中的bean</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>           xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>       http://www.springframework.org/schema/beans/spring-beans.xsd<br>        http://www.springframework.org/schema/context<br>        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>    &lt;!--IoC的注解扫描--&gt;<br>    &lt;context:component-scan base-package=&quot;com.xxx.ioc.service, com.xxx.ioc.dao&quot;&gt;&lt;/context:component-scan&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>自定义扫描类以@CompoentScan修饰来扫描IOC容器的Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表明该类是配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;bb&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationScan</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>就可以在代码中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">(String data1,<span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.gogo&quot;</span>);<br>        userDao.sayHello(data1,data2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过注解把对象添加到IOC容器中，对象名默认首字母小写。注解方式注入在XML注入之前执行，因此对于通过两种方法连接的属性，后者的配置将覆盖前者。</p></blockquote><h1 id="依赖注入">5.依赖注入</h1><p>上述我们简单的讲述了如何向spring容器中注入bean对象。一个bean对象可以有自己的属性（基本数据类型或者引用数据类型），因此需要通过“<strong>依赖注入</strong>”将所需要的属性注入到目标对象中去。</p><p>举个例子：现在我们像IOC容器里注入一个自定义的bean，且我们为其注入值或者依赖。</p><p><strong>Dog：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String dogname;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dogage;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDogname</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dogname;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDogname</span><span class="hljs-params">(String dogname)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dogname = dogname;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDogage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dogage;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDogage</span><span class="hljs-params">(<span class="hljs-type">int</span> dogage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dogage = dogage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;dogname=&#x27;&quot;</span> + dogname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dogage=&quot;</span> + dogage +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="setter注入setter-injection">5.1 setter注入<strong>(SetterInjection)</strong></h2><p>setter注入也叫setter装配，本质是在xml里配置，然后通过setter方法给对象注入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> data1;<br>    <span class="hljs-keyword">private</span> int data2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span>[] data3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; data4;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Integer</span>&gt; data5;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Dog</span>&gt; data6;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Dog</span> data7;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData6</span>(<span class="hljs-params">List&lt;Dog&gt; data6</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data6</span> = data6;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData5</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; data5</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data5</span> = data5;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData4</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; data4</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data4</span> = data4;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData3</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] data3</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data3</span> = data3;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> data1</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data1</span> = data1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData2</span>(<span class="hljs-params">int data2</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data2</span> = data2;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData7</span>(<span class="hljs-params">Dog data7</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data7</span> = data7;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyBean1&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;data1=&#x27;&quot;</span> + data1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, data2=&quot;</span> + data2 +<br>                <span class="hljs-string">&quot;, data3=&quot;</span> + <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">toString</span>(data3) +<br>                <span class="hljs-string">&quot;, data4=&quot;</span> + data4 +<br>                <span class="hljs-string">&quot;, data5=&quot;</span> + data5 +<br>                <span class="hljs-string">&quot;, data6=&quot;</span> + data6 +<br>                <span class="hljs-string">&quot;, data7=&quot;</span> + data7 +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>在XML配置方式中</strong>，property都是setter方式注入，比如下面的xml:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--setter装配--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mybean1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.setter.MyBean1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;呵呵哒&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data3&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--String[]--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data4&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--List&lt;String&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data5&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--Map&lt;String, Integer&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;222333&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data6&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--List&lt;Dog&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Dog--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data7&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.setter.Dog&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;55&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.setter.Dog&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot; 另一个接口/类 &quot;  ref=&quot;xx(另一个类的id) &quot;&gt;&lt;/property&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang222&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;888&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSetter</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config-setter.xml&quot;</span>);<br><br>        <span class="hljs-type">MyBean1</span> <span class="hljs-variable">mybean1</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;mybean1&quot;</span>, MyBean1.class);<br>        System.out.println(mybean1.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">31</span>:<span class="hljs-number">33</span>,<span class="hljs-number">050</span>  INFO XmlBeanDefinitionReader:<span class="hljs-number">317</span> - Loading XML bean definitions from <span class="hljs-keyword">class</span> <span class="hljs-title class_">path</span> resource [com/xxx/ioc/spring-config-setter.xml]<br>MyBean1&#123;data1=<span class="hljs-string">&#x27;呵呵哒&#x27;</span>, data2=<span class="hljs-number">123456</span>, data3=[hehe1, hehe2, hehe3, hehe4], data4=[haha1, haha2, haha3, haha4], data5=&#123;xx1=<span class="hljs-number">123456</span>, xx2=<span class="hljs-number">222333</span>&#125;, data6=[Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;, Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang222&#x27;</span>, dogage=<span class="hljs-number">888</span>&#125;], data7=Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="构造器注入constructor-injection">5.2 构造器注入（ConstructorInjection）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String data1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data2;<br>    <span class="hljs-keyword">private</span> String[] data3;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; data4;<br>    <span class="hljs-keyword">private</span> Map&lt;String,Integer&gt; data5;<br>    <span class="hljs-keyword">private</span> List&lt;Dog&gt; data6;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBean2</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2, String[] data3, List&lt;String&gt; data4, Map&lt;String, Integer&gt; data5, List&lt;Dog&gt; data6)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data1 = data1;<br>        <span class="hljs-built_in">this</span>.data2 = data2;<br>        <span class="hljs-built_in">this</span>.data3 = data3;<br>        <span class="hljs-built_in">this</span>.data4 = data4;<br>        <span class="hljs-built_in">this</span>.data5 = data5;<br>        <span class="hljs-built_in">this</span>.data6 = data6;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyBean2&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;data1=&#x27;&quot;</span> + data1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, data2=&quot;</span> + data2 +<br>                <span class="hljs-string">&quot;, data3=&quot;</span> + Arrays.toString(data3) +<br>                <span class="hljs-string">&quot;, data4=&quot;</span> + data4 +<br>                <span class="hljs-string">&quot;, data5=&quot;</span> + data5 +<br>                <span class="hljs-string">&quot;, data6=&quot;</span> + data6 +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>在XML配置方式中</strong>，<code>&lt;constructor-arg&gt;</code>是通过构造函数参数注入，比如下面的xml:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--构造器装配1--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mybean2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo.xx.MyBean2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;222333&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--构造器装配1--&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--构造器装配2--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mybean22&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo.xx.MyBean2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data3&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data4&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data5&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;222333&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data6&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--构造器装配2--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>构造器赋初始值的时候，index=角标（指定索引还可以解决构造函数具有两个相同类型的参数时的不确定性。注意，索引是基于0的。）或者<strong>name="名称"</strong>这两种方式都可以赋初始值，属性为String和int在里面不用写<strong>""</strong></p><p>我们在上面通过<strong>index=角标</strong>和<strong>name="名称"</strong>分别额注入了不同的bean。</p><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>      ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config-constructor.xml&quot;</span>);<br>      <span class="hljs-type">MyBean2</span> <span class="hljs-variable">mybean2</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;mybean2&quot;</span>, MyBean2.class);<br>      System.out.println(mybean2.toString());<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>      ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config-constructor.xml&quot;</span>);<br>      <span class="hljs-type">MyBean2</span> <span class="hljs-variable">mybean22</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;mybean22&quot;</span>, MyBean2.class);<br>      System.out.println(mybean22.toString());<br>  &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">mybean2:MyBean2&#123;data1=<span class="hljs-string">&#x27;dahuang2&#x27;</span>, data2=<span class="hljs-number">123456</span>, data3=[hehe1, hehe2, hehe3, hehe4], data4=[haha1, haha2, haha3, haha4], data5=&#123;xx1=<span class="hljs-number">123456</span>, xx2=<span class="hljs-number">222333</span>&#125;, data6=[Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;, Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang222&#x27;</span>, dogage=<span class="hljs-number">888</span>&#125;]&#125;<br><br><br>mybean22:MyBean2&#123;data1=<span class="hljs-string">&#x27;dahuang2&#x27;</span>, data2=<span class="hljs-number">123456</span>, data3=[hehe1, hehe2, hehe3, hehe4], data4=[haha1, haha2, haha3, haha4], data5=&#123;xx1=<span class="hljs-number">123456</span>, xx2=<span class="hljs-number">222333</span>&#125;, data6=[Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;, Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang222&#x27;</span>, dogage=<span class="hljs-number">888</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><h2 id="注解注入">5.3 注解注入</h2><p>也叫属性注入以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p><ul><li><strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</li><li><strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</li><li><strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</li></ul><blockquote><p>解释一下参数类型：java思想是一切皆对象，因此可以通过接口或者抽象类，父类等方式去标识一类。byType就是限定于同一种"参数类型"下。</p></blockquote><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="为什么推荐构造器注入方式">为什么推荐构造器注入方式？</h1><p>先来看看Spring在文档里怎么说：</p><blockquote><p>The Spring team generally advocates constructor injection as itenables one to implement application components as immutable objects andto ensure that required dependencies are not null. Furthermoreconstructor-injected components are always returned to client (calling)code in a fully initialized state.As a side note, a large number ofconstructor arguments is a bad code smell, implying that the classlikely has too many responsibilities and should be refactored to betteraddress proper separation of concerns.”</p></blockquote><p>简单的翻译一下：这个构造器注入的方式<strong>能够保证注入的组件不可变，并且确保需要的依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。与此同时，从代码质量的角度来看，一个巨大的构造方法通常代表着出现了代码异味，这个类可能承担了过多的责任。</p><p><strong>依赖不可变</strong>：其实说的就是final关键字。</p><p><strong>依赖不为空</strong>（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK。2：无该类型的参数-&gt;报错。</p><p><strong>完全初始化的状态</strong>：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</p><blockquote><p>在另一篇文章，详细的介绍了为什么推荐构造器注入方式？</p></blockquote><h1 id="spring-core-ioc">Spring Core-IOC</h1><p>1.Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫<strong>控制反转- Inversion of Control (IoC)</strong></p><p>2.Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>IoCContainer</strong>;</p><p>3.Spring框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean？这便是xml配置，Java配置，注解配置</strong>等支持</p><p>4.Spring框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等；</p><p>5.应用程序代码从IocContainer中获取依赖的Bean，注入到应用程序中，这个过程叫<strong>依赖注入(Dependency Injection，DI)</strong> ；所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></p><p>6.在依赖注入时，有哪些方式呢？这就是构造器方式，<spanclass="citation" data-cites="Autowired">@Autowired</span>, <spanclass="citation" data-cites="Resource">@Resource</span>, <spanclass="citation" data-cites="Qualifier">@Qualifier</span>...同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖问题</strong>等）</p><h1 id="read-more">6.Read more</h1><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架介绍</title>
    <link href="/2022/05/10/framework/spring/2022-05-10_Spring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/10/framework/spring/2022-05-10_Spring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">1.背景</h1><p>在 Enterprise Java Beans (EJB) 出现之前，Java 开发人员需要使用JavaBeans 来创建 Web 应用程序。尽管 JavaBeans 有助于开发用户界面 (UI)组件，但它们无法提供开发健壮且安全的企业应用程序所需的服务，例如事务管理和安全性。EJB的出现被视为这个问题的解决方案 EJB 扩展了 Java 组件，例如 Web和企业组件，并提供有助于企业应用程序开发的服务。然而，使用 EJB开发企业应用程序并不容易，因为开发人员需要执行各种任务，例如创建 Home 和Remote 接口以及实现生命周期回调方法，这导致为 EJB提供代码的复杂性由于这种复杂性，</p><h1 id="spring框架">2. Spring框架</h1><h2 id="介绍">2.1 介绍</h2><p><code>Spring 框架（通常称为 Spring）的出现是为了解决所有这些复杂问题</code>。该框架使用各种新技术，例如面向方面的编程(AOP)、Plain Old Java Object (POJO) 和依赖注入 (DI)，开发企业应用程序，从而消除使用 EJB开发企业应用程序时涉及的复杂性<strong>，Spring是一个开源轻量级框架，它允许 Java EE开发人员构建简单、可靠和可扩展的企业应用程序。该框架主要侧重于提供各种方式来帮助我们管理我们的业务对象。与经典的Java 框架和应用程序编程接口 (API)（例如 Java 数据库连接(JDBC)、JavaServer Pages (JSP) 和 Java Servlet）相比，它使 Web应用程序的开发更加容易。</strong></p><p>Spring框架可以看成是子框架的集合，也叫层，比如Spring AOP。Spring对象关系映射（Spring ORM）。Spring Web Flow 和 Spring WebMVC。它是用于开发企业应用程序的轻量级应用程序框架。在构建 Web应用程序时，我们可以单独使用这些模块中的任何一个。这些模块也可以组合在一起以在Web 应用程序中提供更好的功能。由于依赖注入，Spring框架是松散耦合的。</p><blockquote><p>Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《<ahref="https://item.jd.com/68619611892.html">Expert One-on-One J2EEDesign andDevelopment</a>》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。</p></blockquote><h2 id="spring框架的演变">2.2 Spring框架的演变</h2><p>Spring Framework 于 2004 年首次发布，之后进行了重大的重大修订，如Spring 2.0 提供了 XML 命名空间和 AspectJ 支持，Spring 2.5提供了注解驱动的配置，Spring 3.0 提供了基于 Java 的@Configuration模型。spring 框架的最新版本是 4.0。它发布时支持 Java 8 和 Java EE 7技术。尽管我们仍然可以将 Spring 与旧版本的 java一起使用，但最低要求仅限于 Java SE 6。Spring 4.0 还支持 Java EE 7技术，例如 java 消息服务 (JMS) 2.0、java 持久性 API (JPA) 2.1、 Bean验证 1.1、servlet 3.1 和 JCache，如今spring已经来到了spring5.0。</p><h1 id="spring框架架构">3. Spring框架架构</h1><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/Spring-Framework-Architecture-1677156614942-1.png" /></p><p>Spring 框架由七个模块组成，如上图所示。这些模块是 <strong>SpringCore、Spring AOP、Spring Web MVC、Spring DAO、Spring ORM、Springcontext</strong> 和 <strong>Spring Webflow</strong>。这些模块提供了不同的平台来开发不同的企业应用程序；例如，你可以使用Spring Web MVC 模块来开发基于 MVC 的应用程序。</p><h2 id="spring-框架模块">3.1 Spring 框架模块</h2><ul><li><p><strong>Spring Core：</strong> SpringCore模块是Spring框架的核心组件，提供了IoC容器，Spring容器有两种实现方式，分别是bean工厂和应用上下文。Bean工厂是使用 org.springframework.beans.factory.BeanFactory接口定义的，充当 bean 的容器。Bean工厂容器允许我们将依赖项的配置和规范与程序逻辑分离。在 Spring框架中，Bean 工厂充当中央 IoC容器，负责实例化应用程序对象。它还配置和组装这些对象之间的依赖关系。BeanFactory接口有许多实现。XmlBeanFactory 类是 BeanFactory接口最常见的实现。</p></li><li><p><strong>Spring AOP ：</strong>与将应用程序分解为对象层次结构的面向对象编程 (OOP) 类似，AOP将程序分解为方面或关注点。Spring AOP 模块允许我们在 Spring AOP 中的Spring 应用程序中实现关注点或方面，这些方面是常规的 Spring bean 或使用<span class="citation" data-cites="Aspect">@Aspect</span>注释注释的常规类。这些方面有助于应用程序的事务管理和日志记录以及故障监控。例如，在银行操作中需要事务管理，例如将金额从一个帐户转移到另一个账户，Spring AOP 模块提供了一个可以应用于事务 API 的事务管理抽象层。</p></li><li><p><strong>Spring ORM</strong> ：</p><p>Spring ORM 模块用于从应用程序中的数据库访问数据。它提供用于使用JDO、Hibernate 和 iBatis 操作数据库的 API。Spring ORM 支持DAO，它提供了一种便捷的方式来构建以下基于 DAO 的 ORM 解决方案：</p><ul><li>简单的声明式事务管理</li><li>透明的异常处理</li><li>线程安全的轻量级模板类</li><li>DAO 支持类</li><li>资源管理</li></ul></li><li><p><strong>Spring Web MVC ：</strong> Spring 的 Web MVC模块实现了用于创建 Web 应用程序的 MVC 架构。它将 Web应用程序的模型和视图组件的代码分开。在 Spring MVC中，当从浏览器生成请求时，它首先转到 DispatcherServlet类（前端控制器），该类使用一组处理程序映射将请求分派给控制器（SimpleFormController类或 AbstractWizardformController类）。控制器提取并处理请求中嵌入的信息，并将结果以模型对象的形式发送给DispatcherServlet 类。最后，DispatcherServlet 类使用 ViewResolver类将结果发送到视图，视图将这些结果显示给用户。</p></li><li><p><strong>Spring Web Flow</strong> ：</p><p>Spring Web Flow 模块是 Spring Web MVC 模块的扩展。Spring Web MVC框架提供了表单控制器，如SimpleFormController类和AbstractWizardFormController 类，以实现预定义的工作流。Spring WebFlow 有助于定义管理 Web 应用程序不同页面之间工作流的 XML 文件或 Java类。Spring Web Flow是单独发布的，可以通过http://www.springframework.org网站下载。</p><p>以下是 Spring Web Flow 的优点：</p><ul><li>通过在 XML 文件中定义 Web 流，可以清楚地提供应用程序不同 UI之间的流。</li><li>Web流定义可帮助我们虚拟地将应用程序拆分为不同的模块，并在多种情况下重用这些模块。</li></ul></li><li><p><strong>Spring Web DAO ：</strong> Spring 框架中的 DAO包通过使用数据访问技术（如 JDBC、Hibernate 或 JDO）提供 DAO支持。该模块通过消除提供繁琐的 JDBC 编码的需要引入了 JDBC抽象层。它还提供编程式和声明式事务管理类。Spring DAO 包支持异构 Java数据库连接和 O/R 映射，这有助于 Spring使用多种数据访问技术。为了方便快捷地访问数据库资源，Spring框架提供了抽象的DAO基类。Spring框架支持的每种数据访问技术都有多种实现。例如，在 JDBC 中，JdbcDaoSupport类及其方法用于访问 DataSource 实例和预配置的 JdbcTemplate实例。</p></li><li><p><strong>Spring Context ：</strong> Spring Context基于核心模块。也就是我们常说的<code>ApplicationContext</code>，org.springframework.context.ApplicationContext是BeanFactory的一个接口。该模块的特性源自org.springframework.beans 包，还支持国际化(I18N)、验证、事件传播和资源加载等功能。Application 上下文实现MessageSource 接口并向应用程序提供消息传递功能。</p></li></ul><h1 id="spring组件">4.Spring组件</h1><p>Spring Framework 相关组件：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/spring-framework-introduce-8.png" /></p><h2 id="core-containerspring的核心容器">4.1 CoreContainer（Spring的核心容器）</h2><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core核心模块、Context 上下文模块和 SpEL表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web等上层的功能。具体介绍如下。</p><ul><li><p><strong>Beans模块</strong>：提供了框架的基础部分，包括控制反转[IOC]和依赖注入[DI]。</p></li><li><p><strong>Core 核心模块</strong>：封装了 Spring框架的底层部分，包括资源访问、类型转换及一些常用工具类。</p></li><li><p><strong>Context 上下文模块</strong>：建立在 Core 和 Beans模块的基础之上，集成 Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等。ApplicationContext接口是上下文模块的焦点。</p></li><li><p><strong>SpEL模块</strong>：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p></li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130162802973.png" /></p><h2 id="data-accessintegration数据访问集成">4.2 DataAccess/Integration（数据访问／集成）</h2><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions模块，具体介绍如下。</p><ul><li><strong>JDBC 模块</strong>：提供了一个 JDBC的样例模板，使用这些模板能消除传统冗长的 JDBC编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li><li><strong>ORM 模块</strong>：提供与流行的“对象-关系”映射框架无缝集成的API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring事务管理，无需额外控制事务。</li><li><strong>OXM 模块</strong>：提供了一个支持 Object /XML映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li><li><strong>JMS 模块</strong>：指 Java 消息服务，提供一套“消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li><li><strong>Transactions事务模块</strong>：支持编程和声明式事务管理。</li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130162935159.png" /></p><h2 id="web模块">4.3 Web模块</h2><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Webflux组件，具体介绍如下。</p><ul><li><strong>Web 模块</strong>：提供了基本的 Web开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC容器初始化以及 Web 应用上下文。</li><li><strong>Servlet 模块</strong>：提供了一个 Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP 标签，完全无缝与 Spring 其他技术协作。</li><li><strong>WebSocket模块</strong>：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建WebSocket Server，从而实现双向通讯。</li><li><strong>Webflux 模块</strong>： Spring WebFlux 是 Spring Framework5.x中引入的新的响应式web框架。与Spring MVC不同，它不需要ServletAPI，是完全异步且非阻塞的，并且通过Reactor项目实现了ReactiveStreams规范。Spring WebFlux用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</li></ul><p>此外Spring4.x中还有Portlet 模块，在Spring 5.x中已经移除</p><ul><li><strong>Portlet 模块</strong>：提供了在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。</li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130163141867.png" /></p><h2 id="aopaspectsinstrumentation和messaging">4.4AOP、Aspects、Instrumentation和Messaging</h2><p>在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p><ul><li><strong>AOP模块</strong>：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li><li><strong>Aspects 模块</strong>：提供与 AspectJ的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li><strong>Instrumentation模块</strong>：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li><strong>messaging 模块</strong>：Spring 4.0以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li><li><strong>jcl 模块</strong>： Spring5.x中新增了日志框架集成的模块。</li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130163330973.png" /></p><h2 id="test模块">4.5 Test模块</h2><p>Test 模块：Spring 支持 Junit 和 TestNG测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web框架时，模拟 Http 请求的功能。</p><p>包含Mock Objects, TestContext Framework, Spring MVC Test,WebTestClient。</p><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130163426380.png" /></p><blockquote><p>这也印证了前面所说的观点：Spring框架是松散耦合的，可以看成是子框架的集合</p></blockquote><h1 id="为什么要使用spring">5.为什么要使用Spring</h1><p>最重要的体现在它能做什么，这是Spring的核心所在:</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/spring-framework-introduce-0.png" /></p><p>官方对此专门对此做了详细介绍，感兴趣可以看下</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/spring-framework-introduce-01.png" /></p><h1 id="如何学习spring">6.如何学习spring?</h1><p>非常负责任的告诉你，最好最全的资料在Spring的官网，Spring能成为最主要的企业开发框架，文档和生态体系也做的很好，在学习Spring时，一定要把它当做生态体系，而是不是一个简单的开发框架。如下是Spring相关地址：</p><ul><li><p>Spring官方网站：<ahref="http://www.springframework.org/">http://www.springframework.org</a></p></li><li><p>Spring 官方各个版本文档：<ahref="https://docs.spring.io/spring-framework/docs/">https://docs.spring.io/spring-framework/docs/</a></p></li><li><p>Github地址：<ahref="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p></li></ul><h1 id="read-more">7.Read more</h1><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-introduce.html</p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SM.MS、GitHub、OSS搭建图床</title>
    <link href="/2022/05/05/build_blog/2022-05-05_%E4%BD%BF%E7%94%A8SM.MS%E3%80%81GitHub%E3%80%81OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2022/05/05/build_blog/2022-05-05_%E4%BD%BF%E7%94%A8SM.MS%E3%80%81GitHub%E3%80%81OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Markdown写文章一定绕不开一个问题：图片，我们插入的Blog的图片都是指向的是本地的路径。如果改变了本地图片存储的位置，MarkDown所引用的图片就无法显示，因此我们需要一个图床来存放我们的图片。</p><p>常用的图床有<code>SM.MS</code>、<code>OSS云服务</code>、<code>七牛云</code>、<code>GitHub</code>等等。</p><h1 id="使用sm.mspicgo搭建免费图床">1.使用SM.MS、PicGo搭建免费图床</h1><p><code>SM.MS</code>个人有免费的5g容量。对于我们写Blog是够用的。</p><h2 id="注册sm.ms图床">1.注册SM.MS图床</h2><p>我们访问<ahref="https://sm.ms/">SM.MS</a>注册自己的账户，就可以使用图床了。整体页面如下：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.25.01.jpg" /></p><h2 id="配置图床">2.配置图床</h2><p>我们希望在写MarkDown的时候，插入图片到MarkDown的时候，就自动将图片上传到图床，不用我们自己手动将图片上传到图床后，再手动插入图片链接。因此我们可以使用<ahref="https://github.com/PicGo/Awesome-PicGo">PicGo</a>，一个用于快速上传图片并获取图片URL 链接的工具。</p><p><strong>配置API Token</strong></p><p>在<code>SM.MS</code>网址左侧，点击<code>API Token</code>，复制Token到下图位置。PicGo就可以将图片上传到我们的图床上。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.25.26.jpg" /></p><p><strong>MarkDown开启图片自动上传</strong></p><p>此时我们可以将图片拖拽到<code>PicGo</code>图标里获取到<code>SM.MS</code>返回的图片链接，然后再复制到我们的文件里，这是比较麻烦的。因此我们需要在MarkDown编辑工具里开启选项。我使用的<ahref="https://www.typora.net/">Typora</a>，因此在设置中找到<code>图像</code>，将规则设置为<code>上传图片</code>，由于我使用的是<code>PicGo</code>，因此上传服务选择的是<code>PicGo.app</code>。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.25.43.jpg" /></p><h1id="使用githubjsdelivrpicgo搭建免费图床">2.使用Github、jsdelivr、PicGo搭建免费图床</h1><h2 id="创建图床工程">1.创建图床工程</h2><p>新建一个project，自定义名称即可。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.09.29.jpg" /></p><h2 id="配置personal-access-tokens">2.配置Personal access tokens</h2><p>用户栏目下面的<code>Setting</code>。拉到页面最下方，点击<code>&lt;&gt; Developer settings</code> 然后再点击<code>Personal access tokes</code>，在<code>Select scopes</code>选项中勾选<strong>repo</strong>，生成accesstoken。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.09.54.jpg" /></p><blockquote><p>注意：这个token只显示一次，所以一定要自己保管好</p></blockquote><h2 id="picgo配置github">3.PicGo配置GitHub</h2><p>由于GitHub在国外，导致网速会比较慢，因此夹在图片这种大文件会比较慢。我们的<ahref="https://www.jsdelivr.com/">jsdelivr</a>便出现了，jsDelivr是一个免费开源的 CDN 解决方案。包含 JavaScript 库、jQuery 插件、CSS框架、字体等等 Web 上常用的静态资源。</p><p>重要的是jsDelivr在中国大陆也拥有超过数百个节点，因为jsDelivr拥有正规的ICP备案，解决了中国大陆的访问速度优化，实现真正的全球极速低延迟体验。</p><p>jsDelivr是免费的、不限制带宽的，可以加速NPM、Github内的文件。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.44.57.jpg" /></p><p>点击GitHub栏，复制第一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://cdn.jsdelivr.net/gh/user/repo@version/file<br></code></pre></td></tr></table></figure><p>在PicGo中如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">仓库名：username/project</span><br><span class="hljs-attr">分支名：默认main</span><br><span class="hljs-attr">Token：复制的Personal</span> <span class="hljs-string">access token</span><br><span class="hljs-attr">存储路径：指定文件夹，也可以不指定，就在工程当前目录下</span><br><span class="hljs-attr">自定义域名：https</span>:<span class="hljs-string">//cdn.jsdelivr.net/gh/user/repo@version</span><br><span class="hljs-attr">--user</span>:<span class="hljs-string">username</span><br><span class="hljs-attr">--repo</span>:<span class="hljs-string">your project</span><br><span class="hljs-attr">--version</span>:<span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>整体配置界面如下：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.10.31.jpg" /></p><h2 id="上传图片">4.上传图片</h2><p>开启Markdown自动上传图片功能后，只要往Markdown中复制图片进去，则PicGo会自动把我们的图片上传到GitHub上。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.11.09.jpg" /></p><blockquote><p>图片的链接地址为：</p><p>https://cdn.jsdelivr.net/gh/username/project@version/路径(可选)/your_photo</p></blockquote><h1 id="使用aliyun-osspicgo搭建图床">3.使用AliyunOSS、PicGo搭建图床</h1><p>由于Github仓库有限制(不能大于1G且单个文件不能大于100M)，如果我们的文件图片过大，则加载图片还是会很慢，如果觉得GitHub速度还是不够快，我们则可以使用服务商的OSS服务。OSS服务商有多个，本文使用的是AliyunOSS。</p><h2 id="购买oss服务">1.购买OSS服务</h2><ul><li><p>开通<ahref="https://www.aliyun.com/product/oss/">阿里云OSS服务</a></p></li><li><p>在<ahref="https://common-buy.aliyun.com/?spm=5176.8465980.0.0.4e701450E6303q&amp;commodityCode=ossbag&amp;request=%7B%22region%22%3A%22china-common%22%7D#/buy">阿里云OSS</a>选择购买相应的存储OSS服务。</p></li></ul><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_18.09.51.jpg" /></p><h2 id="创建bucket">2.创建Bucket</h2><p>开通OSS且购买OSS服务之后，我们会有一个OSS的控制台界面，点击<strong>创建Bucket</strong>，出现如下界面：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_21.57.33.jpg" /></p><p>关于流量费用的介绍，可以访问官方的帮助页面。通常选择「<strong>按量计费</strong>」。</p><p><strong>流量费用的多少取决于你使用阿里云图床的程度</strong>。一般来说，10元钱能管几个月。</p><p>为了便于理解「存储空间费用」和「流量费用」，可以简单<strong>将它们比作手机套餐的<code>月租</code>和<code>流量</code></strong>。如果你天天刷剧把4G流量用完了，仅仅交月租还不够，超标的流量也要掏钱的。</p><h2 id="添加accesskey">3. 添加AccessKey</h2><p>鼠标悬停头像，出现如下页面。选择<code>AccessKey管理</code>，点击创建，即可创建AccessKey。我选择的是直接使用。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_22.02.06.jpg" /></p><blockquote><p>如果选择的是添加子账户，则新建一个子账户后再获取AccessKet，注意到是需要给子账户添加OSS服务权限</p></blockquote><h2 id="配置picgo">4.配置PicGo</h2><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_22.08.42.jpg" /></p><p>其中：</p><ul><li><code>设定KeyId</code>和<code>设定KeySecret</code>处填写前面记录的<strong>AccessKeyID</strong>和<strong>AccessKey Secret</strong>。</li><li><code>设定存储空间名</code>处填写创建的Bucket的名字。</li><li><code>确定存储区域</code>也是在创建Bucket时设定的。如果忘记了，可在阿里云后台的Bucket概览界面查看，比如我的是<strong>oss-cn-beijing</strong>。见下图。</li></ul><table><thead><tr class="header"><th style="text-align: left;">Endpoint（地域节点）</th><th style="text-align: left;">Bucket 域名</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">oss-cn-beijing.aliyuncs.com</td><td style="text-align: left;">~.oss-cn-beijing.aliyuncs.com</td></tr></tbody></table><ul><li><code>指定存储路径</code>可填写为<strong>img/</strong>。</li></ul><h2 id="上传图片-1">5.上传图片</h2><p>同样，通过typora设置自动上传后，我们就可以直接在Markdown中插入图片。PicGo会自动将图片上传到OSS上，速度极快，所以花钱才是硬道理啊，:joy::joy::joy:。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_22.34.52.jpg"alt="iShot_2022-05-05_22.34.52" /><figcaption aria-hidden="true">iShot_2022-05-05_22.34.52</figcaption></figure><p>阿里云官网: <em>https://www.aliyun.com</em></p><blockquote><p>由于Gitee现在在慢慢增加防盗链的功能，建立在Gitee上的图床以后就不能再使用了。如果Gitee上的图片还能再外链，需要移动Markdown文件图片到阿里云OSS图床，可以在PicGo中增加插件pic-migrater。如果Gitee上的图片已经不能再外链，则现在没有具体的办法。迁移Gitee图床到OSS的具体操作。网上有很多的文章，此处不再详述，有需要的小伙伴可以去尝试一下。</p></blockquote><h1 id="free-image-resource">4. Free Image Resource</h1><p>:lollipop:: <a href="https://barnimages.com/">Beautiful Free Photosfor Everyone | Barnimages</a></p><p>:lollipop:: <a href="https://unsplash.com/">Beautiful Free Images&amp; Pictures | Unsplash</a></p><p>:lollipop:: <a href="https://pikwizard.com/">Free Commercial StockPhotos &amp; Royalty Free Images | PikWizard</a></p><p>:lollipop:: <a href="https://www.rawpixel.com/">Free Stock Photos,PNGs, Templates &amp; Mockups | rawpixel</a></p><p>:lollipop:: <ahref="https://www.splitshire.com/best-new-free-stock-photos/">Best newfree stock photos - SplitShire</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac使用Hexo、GitHub Pages搭建博客</title>
    <link href="/2022/05/03/build_blog/2022-05-03_Mac%E4%BD%BF%E7%94%A8Hexo%E3%80%81GitHub-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/05/03/build_blog/2022-05-03_Mac%E4%BD%BF%E7%94%A8Hexo%E3%80%81GitHub-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>该篇文章默认用户已经掌握Git、GitHub、Markdown相关知识，故不赘述。</p><p>了解Markdown的使用，可访问<a href="https://markdown.com.cn/">Markdown官方教程</a>。</p><h1 id="安装前提">1.安装前提</h1><p>在安装前，需要以下应用程序作为支持。如果没有安装以下应用程序则需要安装。</p><ul><li><a href="https://nodejs.org/en/">Node.js</a></li><li><a href="https://git-scm.com/">Git</a></li></ul><p>查看应用程序是否安装成功，显示出版本信息即为安装成功。</p><p>查看Node.js的版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br></code></pre></td></tr></table></figure><p>查看Git的版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git version<br></code></pre></td></tr></table></figure><h1 id="配置github-pages">2.配置GitHub Pages</h1><p>使用GitHub Pages前，应注意以下两点：</p><ul><li>GitHubPages使用HTTP协议，而不是HTTPS，请不要使用它传输敏感信息，比如密码或者银行账号。</li><li>即使你的仓库是私有的，GitHubPages也是公开在互联网中的，所以，如果您的仓库中具有敏感数据，请在发布前移除之。</li></ul><h2 id="基本页面的生成">1. 基本页面的生成</h2><p>创建一个新的 Repository，进入页面后，在 Repository name的位置填写域名，格式是<code>username.github.io</code>。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.19.01.jpg" /></p><h2 id="配置pages">2. 配置Pages</h2><p>创建成功之后，点击右上角的 Settings，找到 GitHub Pages 选项，选择一个GitHub 官方提供的主题，随意选择一个主题Cayman，来看看他的效果是什么样的。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.20.40.jpg" /></p><p>选择完毕之后 GitHub Pages就会自动生成好网站，在浏览器里输入你的项目名称，比如输入一个本文搭建的<ahref="https://nanchengjiumeng123.github.io/">nanchengjiumeng123.gitHub.io</a>，就可以看到刚刚选择的主题的个人网站的页面了。因此利用GitHubPages搭建的网站就可以访问了。</p><h1 id="配置hexo">3. 配置Hexo</h1><p><strong>hexo</strong>是一个快速，简洁且高效的博客框架精美的博客。常见的主题有<ahref="https://jekyllrb.com/">Jekyll</a>、<ahref="https://hexo.io/zh-cn/">Hexo</a>等等。本文使用Hexo为GitHubPages配置主题。</p><h2 id="安装hexo">1.安装Hexo</h2><p>安装好Node.js之后，我们便可以使用<code>npm</code>命令。npm是node.js的包管理工具，用它来安装hexo。也可以使用brew来安装。</p><p>检查<ahref="https://link.segmentfault.com/?enc=ipg%2FvdF0TXBCuGZYSFrRYA%3D%3D.lxfJsSC4Lt8VxYtzC%2Bb1RfrvTELGXTWyrhKkqKSVUIM%3D">npm</a>是否安装成功:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">npm -v<br></code></pre></td></tr></table></figure><p>输入命令安装Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h2 id="初始化blog">2.初始化Blog</h2><p>安装完成后，我们在一个指定位置在创建一个blog文件夹，在该文件夹下初始化我们的博客。文件路径取自定义的文件路径，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /Users/wangwang/Desktop/blog <br></code></pre></td></tr></table></figure><p>在该文件件目录下执行博客初始化操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 会下载一些node.js的依赖文件</span><br>hexo init<br></code></pre></td></tr></table></figure><p>初始化成功后，在blog目录下执行预览操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s <br></code></pre></td></tr></table></figure><p>当看到如下输出就可以预览我们创建的博客了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>预览效果：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.20.55.jpg" /></p><h2 id="常用hexo常用命令">3.常用hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;博客名称&quot;</span>  =&gt; hexo new <span class="hljs-string">&quot;博客名称&quot;</span>   <span class="hljs-comment">#这两个都是创建新文章，前者是简写模式</span><br>hexo p  =&gt; hexo publish<br>hexo g  =&gt; hexo generate  <span class="hljs-comment">#生成静态网页</span><br>hexo s  =&gt; hexo server  <span class="hljs-comment">#启动服务预览</span><br>hexo d  =&gt; hexo deploy  <span class="hljs-comment">#部署  </span><br><br>hexo server   <span class="hljs-comment">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br>hexo server -s   <span class="hljs-comment">#静态模式</span><br>hexo server -p 5000   <span class="hljs-comment">#更改端口</span><br>hexo server -i 192.168.1.1   <span class="hljs-comment">#自定义IP</span><br>hexo clean   <span class="hljs-comment">#清除缓存，网页正常情况下可以忽略此条命令</span><br></code></pre></td></tr></table></figure><h2 id="相关主题资源">4.相关主题资源</h2><ul><li><p><a href="http://jekyllthemes.org/">jekyllthemes</a></p></li><li><p><ahref="https://jekyll-themes.com/free/">jekyll-themes</a></p></li><li><p><a href="https://hexo.io/themes/">hexo.io-themes</a></p></li></ul><h1 id="配置ssh-key">4.配置SSH Key</h1><p>在命令行输入配置用户名和账号的命令，其中 <code>username</code>是你的用户名，<code>email@gmail.com</code>是你github的登录邮箱。自行替换相应字段，比如邮箱等等。如果已经配置过，该步骤可以忽略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email@gmail.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后通过终端命令生成SSH Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;@gmail.com&quot;</span><br></code></pre></td></tr></table></figure><p>如果已经创建过会出现 <code>Overwrite (y/n)? n</code>提示可以输入<code>n</code>，如果没有创建过会要求我们输入密码，然后一路回车下去就行，执行完成后会在<code>~/.ssh/id_rsa.pub</code>目录下生成需要使用的 key。</p><p>可以使用命令行输出key并复制，或者找到这个文件并打开它，复制里面的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>登录github账号 找到<code>Setting</code>，<strong>注意不是项目的<code>Setting</code>，是用户栏目下面的<code>Setting</code></strong>。先点击<code>SSH and GPG keys</code> 然后再点击<code>New SSH key</code>进入到配置 SSH Key的页面，然后输入复制好的key的内容。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.21.31.jpg" /></p><p>测试是否修改成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果出现<code>Hi xxxx! You've successfully authenticated...</code>则表示配置成功。</p><h1 id="发布">5. 发布</h1><p>到此处我们已经配置好了Hexo与GitHubpages，由于hexo安装好还未配置主题。因此我们可以使用Hexo定义主题，本文选用的是<code>Fliud</code>主题，如果想使用其他主题则需要自己去获取相关主题资源。</p><p>如何安装该主题已经在<ahref="https://hexo.fluid-dev.com/docs/start/">Hexo Fliud用户手册</a>里讲的十分透彻。需要注意以下几点，这是我走的弯路。</p><ul><li><p>复制的<code>_config.fluid.yml</code>文件是文件夹<code>node_module</code>下<code>hexo-theme-fluid</code>的<code>_config.yml</code>文件。不是FluidGitHub上工程的<code>_config.fluid.yml</code></p></li><li><p>如果没有<code>node_module</code>则先跟着文档安装Fuild主题后，依次执行，则会出现该文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hexo clean<br>Hexo g<br></code></pre></td></tr></table></figure></li></ul><h2 id="生成文件及本地调试">1.生成文件及本地调试</h2><p>初始化后执行 <code>hexo generate</code> 或 <code>hexo g</code>可生成静态文件（<code>public</code>文件夹）与缓存文件（<code>data.json</code>）。</p><p>然后我们执行 <code>hexo server</code> 或 <code>hexo s</code>就可以启动本地服务器，访问网址 <code>http://localhost:4000/</code>就可以查看文章效果了。</p><h2 id="发布文件">2.发布文件</h2><p>Hexo发布文件到GitHub需要安装<code>deployer</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改配置文件 <code>_config.yml</code>，修改<code>deploy</code>部分为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>然后就可以把博客push到对应的<code>username</code>的GitHub上，在命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#清空静态文件与缓存文件</span><br>hexo clean<br><span class="hljs-comment">#生成我们想要的博客文件</span><br>hexo g<br><span class="hljs-comment">#将本地的博客文件push到github</span><br>hexo d<br></code></pre></td></tr></table></figure><p><code>hexo d</code>执行成功后，就可以查看我们的Blog了，可以发现我们的Blog主题已经改变为<code>Fluid</code>主题样式，可以根据文档自定义自己的主题样式。</p><p><strong>导航</strong> ：</p><p>:lollipop:: <a href="https://hexo.fluid-dev.com/docs/start/">FluidStart</a> :lollipop:: <ahref="https://hexo.fluid-dev.com">Fluid主题界面</a></p><h1 id="自定义域名">6. 自定义域名</h1><p>此时，我们已经完成一个Blog的基本功能，每次写了新的文件即可通过hexo相关命令发布到GitHubPages上。过几分后即可查看我们新发布的文章。但是Blog的网址为<code>username.github.io</code>难免不太好看，我们因此可以使用自定义域名。</p><h2 id="获取域名">1.获取域名</h2><p>使用<ahref="https://wanwang.aliyun.com/domain">阿里云域名</a>注册一个域名，现在购买域名需要实名认证，因此需要先实名认证后再购买域名。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.26.02.jpg" /></p><h2 id="配置dns">2.配置DNS</h2><p>首先获得自己的Github Page的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping username.github.io<br></code></pre></td></tr></table></figure><p>也可以直接使用下面的IP地址</p><ul><li>185.199.108.153</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul><p>然后添加记录，有多少个IP地址就添加多少条记录。可以以下图所示作为参考设置：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.21.56.jpg" /></p><h2 id="github-pages绑定域名">3.GitHub Pages绑定域名</h2><p>在GitHubPages如图配置里，在<code>Custon domain</code>写上自定义域名。出现<code>Your site is published at ...</code>在表明配置成功。在浏览器中填入自定义域名即可访问自己的Blog。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.19.01.jpg" /></p><p><strong>注：</strong></p><p>如果在发布之后，GitHubPages上自定义的域名<code>Custom domain</code>被还原。可以在Blog的<code>source</code>目录新建一个名为<code>CNAME</code>的文件，将自己的购买的域名填入进去即可。</p><h1 id="cdn加速">7. CDN加速</h1><p>由于GitHubPages的服务器在国外，国内访问会比较慢。因此可以配置CDN加速。常见的CDN加速有很多，我们选择<ahref="https://www.cloudflare.com/">Cloudflare</a>作为CDN加速，它有免费的加速版本，但是足够我们写Blog的需求了。俗话说：<code>可以不要，但不可以没有</code>，白嫖的它不香吗。</p><h2 id="添加站点">1. 添加站点</h2><p>首先访问选择<ahref="https://www.cloudflare.com/">Cloudflare</a>注册一个你自己的账户，然后添加自己的站点，我们将自己购买的域名作为自己的站点。提交之后会自动扫描域名对应的解析记录</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.22.20.jpg" /></p><h2 id="修改运营商dns">2.修改运营商DNS</h2><p>复制Cloudflare的DNS，通过域名的运营商修改对应的 DNS记录，由于我是在阿里云购买的域名，因此修改阿里云默认的DNS为</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.24.25.jpg" /></p><p>登陆自己的Blog，如果如下则表示配置成功。<code>cloudflare</code>不一定一直会提供免费版的，如果以后不再支持免费版，只需要把DNS 的解析记录再还原回去就行了。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.24.45.jpg" /></p><h1 id="hexo拓展">8.Hexo拓展</h1><p>Hexo默认是采用<code>hexo-renderer-marked</code>渲染器将markdown渲染成HTML，这个渲染器不支持插件扩展，因此不能支持表情；还有一个支持插件扩展的是<code>hexo-renderer-markdown-it</code>，所以我们可以使用这个渲染引擎来支持emoji表情。</p><h2 id="更换渲染器">1.更换渲染器</h2><p>进入blog跟目录，执行如下命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm un hexo-renderer-marked --save<br>npm i hexo-renderer-markdown-it --save<br></code></pre></td></tr></table></figure></p><h2 id="安装emoji插件">2.安装emoji插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install markdown-it-emoji --save<br></code></pre></td></tr></table></figure><h2 id="编辑站点配置文件">3.编辑站点配置文件</h2><p>就是编辑根目录的_config.yml文件，添加如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Markdown-it config</span><br><span class="hljs-comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">render:</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment"># 是否对HTML标签进行解析，false时HTML将按照原样输出</span><br>    <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment"># 是否需要满足严格的XHTML格式，换行为&lt;br /&gt;</span><br>    <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">quotes:</span> <span class="hljs-string">&#x27;“”‘’&#x27;</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span>  <span class="hljs-comment"># add emoji</span><br>  <span class="hljs-attr">anchors:</span><br>    <span class="hljs-comment"># Minimum level for ID creation. (Ex. h2 to h6)</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-number">2</span><br>    <span class="hljs-comment"># A suffix that is prepended to the number given if the ID is repeated.</span><br>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">&#x27;v&#x27;</span><br>    <span class="hljs-comment"># If `true`, creates an anchor tag with a permalink besides the heading.</span><br>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># Class used for the permalink anchor tag.</span><br>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">header-anchor</span><br>    <span class="hljs-comment"># The symbol used to make the permalink</span><br>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">¶</span><br></code></pre></td></tr></table></figure><h1 id="总结">9.总结</h1><p>到此，我们的一个完整的Blog就搭建成功了。以上过程都是自己全部一步一步做过来的。因此记录下来。供有想自己搭建独立博客的人做一个参考。当然，此时的博客在百度和谷歌都是搜索不到的。需要配置站点地图。我只配置的GooGle搜索。这些都相对简单因此不必再赘述，有想法的人可以搜索相关知识即可。</p><p>:lollipop:: <ahref="https://search.google.com/search-console">谷歌收录Google SearchConsole</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
