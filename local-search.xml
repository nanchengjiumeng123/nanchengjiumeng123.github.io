<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跳跃表-zskipList</title>
    <link href="/2024/02/20/framework/redis/2024-02-20_%E8%B7%B3%E8%A1%A8-zskipList/"/>
    <url>/2024/02/20/framework/redis/2024-02-20_%E8%B7%B3%E8%A1%A8-zskipList/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃表概述">1.跳跃表概述</h1><p>跳跃表（<ahref="http://en.wikipedia.org/wiki/Skip_list">skiplist</a>）是一种随机化的数据，由 William Pugh 在论文<ahref="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf">《Skiplists: a probabilistic alternative to balanced trees》</a>中提出，跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 ——查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说，跳跃表的实现要简单直观得多。</p><p>跳表（skip list）对表的是平衡树（AVL Tree）和 二分查找，是一种插入/删除/搜索 都是 <em>O</em>(<em>l<strong>o</strong>gn</em>)的数据结构。</p><p>以下是个典型的跳跃表例子（图片来自<ahref="http://en.wikipedia.org/wiki/File:Skip_list.svg">维基百科</a>）：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/skiplist.png" /></p><p>从图中可以看到， 跳跃表主要由以下部分构成：</p><ul><li>表头（head）：负责维护跳跃表的节点指针。</li><li>跳跃表节点：保存着元素值，以及多个层。</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li><li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li></ul><h1 id="如何给有序链表加速">2.如何给有序链表加速</h1><p>一开始就讲跳表肯定是晦涩难懂的，我们已经了解了跳表的基础定义，我们先了解一下有序链表。看看有序链表是如何“加速”的。</p><blockquote><p>有序链表是所有元素以递增或递减方式有序排列的数据结构，其中每个节点都指向下个节点的next指针，最后一个节点的next指针指向NULL。</p></blockquote><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317165802204.png" /></p><p>如上，我们有一个单向有序链表，如果要查询31的元素，需要从第一个元素开始依次向后查询、比较才可以找到，找到顺序为1-&gt;8-&gt;10-&gt;11-&gt;20-&gt;26-&gt;31，共6次比较，时间复杂度为<em>O(N)。有序链表的插入和删除操作都需要先找到合适的位置在修改next指针，修改操作基本不耗费时间，所以插入、删除、修改有序链表的耗时主要在查找元素上。</em></p><p><font size=4><strong>如何进行简单优化？可以让它的查询时间复杂度变低，也就是加速它的查询</strong>。</font></p><blockquote><p>一般来说这种加速的方式的话，就类似于星际穿越里面这有点玄学，但是你一定要记住一个概念就行了，一维的数据结构要加速的话，经常采用的方式就是升维也就是说变成二维。为什么要多一层维度，因为你多了一个维度之后，就会有多一级的信息在里面，这样多一级的信息就可以帮助你可以很快地得到一维里面你必须挨个走才能走到的那些元素</p></blockquote><p><font size=4><strong>添加第一级索引</strong></font></p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317172225269.png" /></p><p>具体我们来看上图，在原始链表的情况下，我们再增加一个维度，也就是在上面再增加一层索引，我们叫做第一级索引，那么第一级索引的话就不是指向它元素的next 元素了，而是指向它的 next next ，也就是说你可以理解为 next + 1就行了，所以第一级索引的话就是第一个元素，马上第三个元素、第五个元素、第七个元素。</p><ul><li><p>这里你就会发现如果你要找26的话，我们怎么办？我们这么查找，先查找第一级索引看有没有110 26 ，如果有那就说明 26存在这个链表里面是存在的，说明我们查询到了。</p></li><li><p>我们再看要查另一个元素，比如说31，我们怎么走？还是先找第一级，31是大于 1 的，所以后继往后到达 10索引的值，31 是大于 10 的，继续往后到了 10 ，31 也大 26的，再继续往后发现 60 大于 31 了。说明 31 是存在于 26 和 60这两个索引之间的元素里面的，那么这个时候从第一级元素向下走到原始的链表了，从对应的位置挨个找就会发现31 找到了，说明 31 也是存在的。</p></li></ul><p><font size=4><strong>添加第二级索引</strong></font></p><p>那么有的朋友可能就会想了，你加一级索引的话，每次相当于步伐加 2了，但是它的速度的话也就是比原来稍微快了一点，能不能更快呢？</p><p>同理可得，在第一级索引的基础上，我们把它当作是一个原始链表一样，往上再加一级索引，也就是说每次针对第一级索引走两步。那么它相等于原始链表相当于每次就走了四步。对不对，就乘于2，那这样的话，速度就更加高效了。</p><ul><li>比如我举个例子要查31，先找 1，31 比 1要大，再找 26 ，这时候你会发现31 也是比 26 大的，所以 26这里的话就必须向下再走一级索引了，走到第一级索引的 26 来，再类似于之前26 和 60 之间，然后再走到下一层， 这样一直走下来找到31。</li></ul><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317172847010.png" /></p><p><font size=4><strong>添加多级索引</strong></font></p><p>以此类推，增加多级索引</p><p>假设有五级索引的这么一个原始链表，那么我们要查一个元素，比如说要查 62元素或者中间元素，就类似于下图，一级一级一级一级走下来，最后的话就可以查到我们需要的62这个元素。当然的话你最后查到原始链表，你会发现比如说是我们要查63或者61，原始链表里面没有，我们就说元素不存在，在我们这个有序的链表里面，也就是说在跳表里面查不到这么一个元素。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317175020869.png" /></p><p><em>如果我们将有序链表的部分节点分层，每一层都是一个有序链表。在查找时优先从最高层开始向后查找，当到达某节点时，如果next节点值大于要查找的值或next指针指向NULL，则从当前节点下降一成继续向后查找，这样是否可以提升查询效率呢？</em></p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317175241953.png" /></p><p>使用分层有序链表，比如我们查找值为31的节点时，查找步骤如下：</p><ol type="1"><li>从最高层第2层开始查找，1节点比31值要小，继续向后比较。</li><li>10节点比31节点要小，继续向后比较，这时会发现第2层10节点的next指针是指向NULL，所以在10节点就开始需要下降一层到第1层并继续向后查找节点进行比较。</li><li>在下降到第1层中，10节点的值比31要小，继续向后比较，第1层10节点的next指针指向26，26比31要小，继续向后比较，第1层26节点的next指针指向60，60比31要大，需要下降一层继续向后比较。</li><li>最后下降到了第0层，第0层的26节点的next指针指向31，31为我们要找的节点，节点被找到。</li></ol><h1 id="redis跳跃表">3.redis跳跃表</h1><p>为了满足自身的功能需要， Redis 基于 William Pugh论文中描述的跳跃表进行了以下修改：</p><ol type="1"><li>允许重复的 <code>score</code> 值：多个不同的 <code>member</code> 的<code>score</code> 值可以相同。</li><li>进行对比操作时，不仅要检查 <code>score</code> 值，还要检查<code>member</code> ：当 <code>score</code> 值可以重复时，单靠<code>score</code> 值无法判断一个元素的身份，所以需要连<code>member</code> 域都一并检查才行。</li><li>每个节点都带有一个高度为 1层的后退指针，用于从表尾方向向表头方向迭代：当执行 <ahref="http://redis.readthedocs.org/en/latest/sorted_set/zrevrange.html#zrevrange">ZREVRANGE</a>或 <ahref="http://redis.readthedocs.org/en/latest/sorted_set/zrevrangebyscore.html#zrevrangebyscore">ZREVRANGEBYSCORE</a>这类以逆序处理有序集的命令时，就会用到这个属性。</li></ol><h2 id="zskiplist">3.1 zskiplist</h2><p>这个修改版的跳跃表由 <code>redis.h/zskiplist</code> 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 跳跃表链表结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br><br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br><br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br><br>&#125; zskiplis<br></code></pre></td></tr></table></figure><p>该结构体属性如下：</p><ul><li>header：指向跳跃表头节点。头节点时跳跃表的特殊节点，他的level是固定数组元素个数为32个，头节点不存储任何score和obj，level也不计入跳跃表的高度，头节点在初始化时，score值为0，ele值为NULL，32个元素的forward值都指向NULL，span为0.</li><li>tail：指向跳跃表尾节点。</li><li>length：跳跃表长度，表示第0层除头节点以外的所有节点总数。</li><li>level：跳跃表高度，除头节点外，其他节点层数最高的即为跳跃表高度。</li></ul><p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到。</p><h2 id="zskiplistnode">3.2 zskiplistNode</h2><p>跳跃表的节点由 <code>redis.h/zskiplistNode</code> 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br><br>    <span class="hljs-comment">// member 对象</span><br>    robj *obj;<br><br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br><br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br><br>        <span class="hljs-comment">// 这个层跨越的节点数量</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br><br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><ul><li>score：是一个double类型的浮点数，用户存储有序链表节点的分值，跳跃表中的所有节点都按分值从小到大来排序。</li><li>obj：为节点的成员对象，指向一个字符串对象，而字符串对象则保存着一个SDS值。</li><li>backward：后退指针，用于从从表尾向表头遍历跳跃表访问节点时使用。指向跳跃表当前节点的最底层节点的前一个节点，头节点和第一个节点的backward指向NULL。</li><li>层(level)：为动态柔性数组，数组可以包含多个元素，每个元素都包含一个指向其他节点的指针。每个节点层高不同对应的数组大小也不同，每次创建一个新跳跃表节点的时候，根据幂次定律(power law，值越大出现的概率越小）随机生成一个1～32的值，一般来说，层的数量越多，访问其他节点的速度就越快。</li></ul><p>这level数组中的每项元素包含以下两个元素：</p><ul><li>forward：指向本层下一个节点，每个层都有一个指向表尾方向的前进指针(level[i]-&gt;forward属性），用于从表头向表尾方向访问节点，尾节点的forward指向NULL。</li><li>span：层的跨度 (level[i]-&gt;span属性）用于记录两个节点之间的距离，即forward指向的节点于本节点之间的元素个数，span值越大，说明跳过的节点个数越多。</li></ul><p>以下是操作这两个数据结构的 API ，API 的用途与相应的算法复杂度：</p><table><thead><tr class="header"><th style="text-align: left;">函数</th><th style="text-align: left;">作用</th><th style="text-align: left;">复杂度</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>zslCreateNode</code></td><td style="text-align: left;">创建并返回一个新的跳跃表节点</td><td style="text-align: left;">最坏 O(1)</td></tr><tr class="even"><td style="text-align: left;"><code>zslFreeNode</code></td><td style="text-align: left;">释放给定的跳跃表节点</td><td style="text-align: left;">最坏 O(1)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslCreate</code></td><td style="text-align: left;">创建并初始化一个新的跳跃表</td><td style="text-align: left;">最坏 O(1)</td></tr><tr class="even"><td style="text-align: left;"><code>zslFree</code></td><td style="text-align: left;">释放给定的跳跃表</td><td style="text-align: left;">最坏 O(N)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslInsert</code></td><td style="text-align: left;">将一个包含给定 <code>score</code> 和<code>member</code> 的新节点添加到跳跃表中</td><td style="text-align: left;">最坏 O(N)平均 O(logN)</td></tr><tr class="even"><td style="text-align: left;"><code>zslDeleteNode</code></td><td style="text-align: left;">删除给定的跳跃表节点</td><td style="text-align: left;">最坏 O(N)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslDelete</code></td><td style="text-align: left;">删除匹配给定 <code>member</code> 和<code>score</code> 的元素</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="even"><td style="text-align: left;"><code>zslFirstInRange</code></td><td style="text-align: left;">找到跳跃表中第一个符合给定范围的元素</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslLastInRange</code></td><tdstyle="text-align: left;">找到跳跃表中最后一个符合给定范围的元素</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="even"><td style="text-align: left;"><code>zslDeleteRangeByScore</code></td><td style="text-align: left;">删除 <code>score</code>值在给定范围内的所有节点</td><td style="text-align: left;">最坏 O(N^2)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslDeleteRangeByRank</code></td><td style="text-align: left;">删除给定排序范围内的所有节点</td><td style="text-align: left;">最坏 O(N^2)</td></tr><tr class="even"><td style="text-align: left;"><code>zslGetRank</code></td><td style="text-align: left;">返回目标元素在有序集中的排位</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr><tr class="odd"><td style="text-align: left;"><code>zslGetElementByRank</code></td><td style="text-align: left;">根据给定排位，返回该排位上的元素节点</td><td style="text-align: left;">最坏 O(N) 平均 O(logN)</td></tr></tbody></table><blockquote><p><strong>Redis 跳跃表默认允许最大的层数是 32</strong>，被源码中ZSKIPLIST_MAXLEVEL 定义。</p></blockquote><h2 id="redis跳跃表实现">3.3 redis跳跃表实现</h2><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和<code>redis.h/zskiplist</code> 两个结构定义， 其中<code>zskiplistNode</code> 结构用于表示跳跃表节点， 而<code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息，比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211111126.png" /></p><p>上图展示了一个跳跃表示zskiplist 结构，该结构包含以下属性：</p><ul><li><code>header</code> ：指向跳跃表的表头节点。</li><li><code>tail</code> ：指向跳跃表的表尾节点。</li><li><code>level</code>：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li><code>length</code>：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p>位于 <code>zskiplist</code> 结构右方的是四个<code>zskiplistNode</code> 结构， 该结构包含以下属性：</p><ul><li>层（level）：节点中用 <code>L1</code> 、 <code>L2</code> 、<code>L3</code> 等字样标记节点的各个层， <code>L1</code> 代表第一层，<code>L2</code>代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退（backward）指针：节点中用 <code>BW</code>字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和<code>3.0</code>是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和<code>o3</code> 是节点所保存的成员对象。</li></ul><h4 id="层">层</h4><p>跳跃表节点的 level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<ahref="https://link.juejin.cn?target=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPower_law">powerlaw</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和<code>32</code> 之间的值作为 <code>level</code> 数组的大小，这个大小就是层的“高度”。</p><p>下图分别展示了三个高度为 <code>1</code> 层、 <code>3</code> 层和<code>5</code> 层的节点， 因为 C 语言的数组索引总是从 <code>0</code>开始的， 所以节点的第一层是 <code>level[0]</code> ， 而第二层是<code>level[1]</code> ， 以此类推。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211216113.png" /></p><h4 id="前进指针">前进指针</h4><p>每个层都有一个指向表尾方向的前进指针（<code>level[i].forward</code>属性）， 用于从表头向表尾方向访问节点。</p><p>上图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：</p><ol type="1"><li>迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</li><li>在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</li><li>在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</li><li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个<code>NULL</code> ， 程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</li></ol><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211242486.png" /></p><h4 id="跨度">跨度</h4><p>层的跨度（<code>level[i].span</code>属性）用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大， 它们相距得就越远。</li><li>指向 <code>NULL</code> 的所有前进指针的跨度都为 <code>0</code> ，因为它们没有连向任何节点。</li></ul><p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 ——遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子， 如下用虚线标记了在跳跃表中查找分值为 <code>3.0</code> 、成员对象为 <code>o3</code> 的节点时， 沿途经历的层：查找的过程只经过了一个层， 并且层的跨度为 <code>3</code> ，所以目标节点在跳跃表中的排位为 <code>3</code> 。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211322796.png" /></p><p>再举个例子， 如下用虚线标记了在跳跃表中查找分值为 <code>2.0</code> 、成员对象为 <code>o2</code> 的节点时， 沿途经历的层：在查找节点的过程中， 程序经过了两个跨度为 <code>1</code> 的节点，因此可以计算出， 目标节点在跳跃表中的排位为 2 。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211430979.png" /></p><h4 id="后退指针">后退指针</h4><p>节点的后退指针（<code>backward</code>属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211445751.png" /></p><p>上图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的 <code>tail</code> 指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 <code>NULL</code>的后退指针， 于是访问结束。</p><h4 id="分值和成员">分值和成员</h4><ul><li>节点的分值（<code>score</code> 属性）是一个 <code>double</code>类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</li><li>节点的成员对象（<code>obj</code> 属性）是一个指针，它指向一个字符串对象， 而字符串对象则保存着一个 SDS（简单动态字符串）值。</li></ul><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p>举个例子， 在下图所示的跳跃表中， 三个跳跃表节点都保存了相同的分值<code>10086.0</code> ， 但保存成员对象 <code>o1</code>的节点却排在保存成员对象 <code>o2</code> 和 <code>o3</code> 的节点之前，而保存成员对象 <code>o2</code> 的节点又排在保存成员对象 <code>o3</code>的节点之前， 由此可见， <code>o1</code> 、 <code>o2</code> 、<code>o3</code> 三个成员对象在字典中的排序为<code>o1 &lt;= o2 &lt;= o3</code> 。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211458874.png" /></p><h3 id="跳跃表">跳跃表</h3><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如下图 所示：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211508748.png" /></p><p>但通过使用一个 <code>zskiplist</code> 结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息，如下所示：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/redis/image-20240317211528404.png" /></p><h1 id="问题">4. 问题</h1><p>为啥 redis 使用跳表(skiplist)而不是使用 red-black？</p><ol type="1"><li>skiplist的复杂度和红黑树一样，而且实现起来更简单。</li><li>在并发环境下skiplist有另外一个优势，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。</li></ol><p>附：开发者说的为什么选用skiplist <ahref="https://link.juejin.cn/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D1171423">TheSkip list</a></p><blockquote><p>There are a few reasons:</p><p>They are not very memory intensive. It's up to you basically.Changing parameters about the probability of a node to have a givennumber of levels will make then less memory intensive than btrees. Asorted set is often target of many ZRANGE or ZREVRANGE operations, thatis, traversing the skip list as a linked list. With this operation thecache locality of skip lists is at least as good as with other kind ofbalanced trees. They are simpler to implement, debug, and so forth. Forinstance thanks to the skip list simplicity I received a patch (alreadyin Redis master) with augmented skip lists implementing ZRANK inO(log(N)). It required little changes to the code. About the Append Onlydurability &amp; speed, I don't think it is a good idea to optimizeRedis at cost of more code and more complexity for a use case that IMHOshould be rare for the Redis target (fsync() at every command). Almostno one is using this feature even with ACID SQL databases, as theperformance hint is big anyway.</p><p>About threads: our experience shows that Redis is mostly I/O bound.I'm using threads to serve things from Virtual Memory. The long termsolution to exploit all the cores, assuming your link is so fast thatyou can saturate a single core, is running multiple instances of Redis(no locks, almost fully scalable linearly with number of cores), andusing the "Redis Cluster" solution that I plan to develop in thefuture.</p></blockquote><h1 id="总结">5. 总结</h1><ul><li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis中没有其他应用。</li><li>Redis 的跳跃表实现由 <code>zskiplist</code> 和<code>zskiplistNode</code> 两个结构组成， 其中 <code>zskiplist</code>用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而<code>zskiplistNode</code> 则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code>之间的随机数。</li><li>在同一个跳跃表中， 多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序， 当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h1 id="read-more">6.Read more</h1><p>:lollipop::http://redisbook.com/preview/skiplist/datastruct.html</p><p>:lollipop::https://juejin.cn/post/689302628126206591496</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zskipList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2023/01/30/java_se/2022-05-13_%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/01/30/java_se/2022-05-13_%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常">1.异常</h1><p><strong>Java中的异常处理</strong>是处理运行时错误以保持应用程序正常流程的有效手段之一。Java异常处理是一种处理运行时错误的机制，如ClassNotFoundException、IOException、SQLException、RemoteException等。</p><p><strong>异常</strong>是不需要的或意外的事件，它发生在程序执行期间，即在运行时，它会扰乱程序指令的正常流程。程序可以捕获和处理异常。当方法中发生异常时，它会创建一个对象。该对象称为异常对象。它包含有关异常的信息，例如异常的名称和描述以及发生异常时程序的状态。</p><blockquote><p><strong>错误</strong>表示不可恢复的情况，例如 Java 虚拟机 (JVM)内存耗尽、内存泄漏、堆栈溢出错误、库不兼容、无限递归等。错误通常是程序员无法控制的，我们不应该试图去处理错误。</p></blockquote><p>讨论最重要的部分，即<strong>Error 和 Exception之间的区别</strong>，如下所示：</p><ul><li><strong>错误：</strong>错误表示一个合理的应用程序不应尝试捕获的严重问题。</li><li><strong>异常：</strong>异常表示合理的应用程序可能会尝试捕获的情况。</li></ul><h2 id="出现异常的主要原因">1.1 出现异常的主要原因</h2><ul><li>无效的用户输入</li><li>设备故障</li><li>失去网络连接</li><li>物理限制（磁盘内存不足）</li><li>代码错误</li><li>打开一个不可用的文件</li></ul><h2 id="异常层次结构">1.2 异常层次结构</h2><p>所有异常和错误类型都是 Throwable类的子类，<strong>Throwable</strong>是层次结构的基类。一类由<strong>Exception</strong>领导。此类用于用户程序应捕获的异常情况。NullPointerException是此类异常的一个示例。</p><p>Java 运行时系统 ( <ahref="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">JVM</a>) 使用另一个类别<strong>Error</strong>来指示与运行时环境本身 (JRE)相关的错误。StackOverflowError 是此类错误的一个示例。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/throwable/Exception-in-java1.png"alt="Java 中的异常层次结构" /><figcaption aria-hidden="true">Java 中的异常层次结构</figcaption></figure><p>由于<strong>Error</strong>通常是程序员无法控制的，所以我们不应该试图去处理错误，我们只针对<strong>Exception</strong>这类处理即可。</p><h2 id="异常类型">1.3 异常类型</h2><p>Java 定义了几种与其各种类库相关的异常类型。Java还允许用户定义自己的异常。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/throwable/Group21-660x330.jpg"alt="异常类型" /><figcaption aria-hidden="true">异常类型</figcaption></figure><p><strong>异常可以按两种方式分类：</strong></p><ol type="1"><li><strong>内置异常</strong><ul><li>检查异常</li><li>未经检查的异常</li></ul></li><li><strong>用户定义的异常</strong></li></ol><p>让我们讨论上面定义的列出的异常，如下所示：</p><h2 id="内置异常"><strong>1.4 内置异常</strong></h2><p>内置异常是 Java 库中可用的异常。这些异常适用于解释某些错误情况。</p><ul><li><strong>检查异常：</strong>已检查异常称为编译时异常，因为这些异常是在编译时由编译器检查的。</li><li><strong>未检查异常：</strong>未检查异常与检查异常正好相反。编译器不会在编译时检查这些异常。简单来说，如果一个程序抛出一个uncheckedexception，即使我们没有处理或声明它，程序也不会给出编译错误。</li></ul><blockquote><p>未检查异常属于运行时异常，都继承RuntimeException。这些异常只有在运行的时候才能确定是否抛出异常。编译时不由编译器检查。</p></blockquote><h3 id="检查异常">1.4.1 检查异常</h3><p>这些是在编译时检查的异常。如果方法中的某些代码抛出已检查的异常，则该方法必须处理该异常，或者必须使用<ahref="https://www.geeksforgeeks.org/throw-throws-java/"><em>throws</em>关键字</a>指定该异常。在检查异常中，有两种类型：完全检查异常和部分检查异常。一个完全检查的异常是一个检查异常，它的所有子类也被检查，像IOException，InterruptedException。部分检查异常是一种检查异常，其中某些子类未检查，如Exception。</p><p>例如，考虑下面的 Java程序，它打开位于“C:.txt”位置的文件并打印它的前三行。该程序无法编译，因为函数main() 使用 FileReader() 并且 FileReader()抛出已检查的异常<em>FileNotFoundException</em>。它还使用 readLine() 和close() 方法，这些方法也抛出已检查的异常<em>IOException</em>。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">FileReader</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;C:\\test\\a.txt&quot;</span>);<br>      <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">fileInput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(file);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; counter &lt; <span class="hljs-number">3</span>; counter++)<br>          System.out.println(fileInput.readLine());<br>      fileInput.close();<br>  &#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">D:\workspace\project\IdeaProjects\demo\src\main\java\com\example\demo\aaa\DDD.java:<span class="hljs-number">58</span>:<span class="hljs-number">27</span><br>java: 未报告的异常错误java.io.FileNotFoundException; 必须对其进行捕获或声明以便抛出<br></code></pre></td></tr></table></figure><p>程序是无法运行的，因为我们必须手动处理这些检查异常，要修复上述程序，我们要么需要使用throws 指定异常列表，要么需要使用 try-catch块。即可使上述程序无编译错误。</p><h3 id="非检查异常运行时异常">1.4.2 非检查异常（运行时异常）</h3><p>这些是编译时不检查的异常。在 C++中，所有异常都是未经检查的，因此编译器不会强制处理或指定异常。由程序员来文明，并指定或捕获异常。在Java中，<em>Error</em>和<em>RuntimeException</em>类下的异常是非检查的异常，throwable下的所有其他异常都是检查异常。</p><p>以下 Java程序。它编译得很好，但在运行时会抛出<em>ArithmeticException</em>。编译器允许它编译，因为<em>ArithmeticException</em>是一个非检查的异常。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> y / x;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p>简而言之，<strong><em>非检查的异常是不需要在 throws子句中捕获或声明的运行时异常</em></strong>。这些异常通常是由编程错误引起的，例如试图越界访问数组中的索引或试图除以零。</p><p>非检查的异常包括 RuntimeException 类的所有子类，以及 Error类及其子类。</p><h2 id="用户自定义异常">1.5 用户自定义异常</h2><p>异常是程序执行期间发生的问题（运行时错误）。当发生异常时，程序会突然终止，并且不会执行生成异常行之后的代码。</p><p>有时，Java中内置的异常并不能描述某种情况。在这种情况下，用户还可以创建异常，称为“用户定义的异常”，并使用“throw”关键字抛出该异常。</p><h3 id="为什么要使用自定义异常">为什么要使用自定义异常？</h3><ul><li>捕获并提供对现有 Java 异常子集的特定处理。</li><li>业务逻辑异常：这些是与业务逻辑和工作流相关的异常。这对于应用程序用户或开发人员了解确切的问题很有用。</li></ul><p>为了创建自定义异常，我们需要扩展属于<strong>java.lang 包的 Exception类。</strong></p><p>例如，下面代码中的 MyException 扩展了 Exception 类。</p><p>自定义异常只需要继承RuntimeException即可。下列为一个简单的自定义异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String errorCode;<br>    <span class="hljs-keyword">private</span> String errorMsg;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String errorCode, String errorMsg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.errorCode = errorCode;<br>        <span class="hljs-built_in">this</span>.errorMsg = errorMsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>    ... ...<br>    <span class="hljs-comment">//逻辑失败处理</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;your errorCode&quot;</span>,<span class="hljs-string">&quot;your errorMsg&quot;</span>);<br>    <br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="打印异常的方法">1.6 打印异常的方法</h2><h3 id="printstacktrace">1.6.1 <strong>printStackTrace()</strong></h3><ul><li><code>printStackTrace()</code>–该方法打印异常信息，格式为异常名称：<strong>异常描述，堆栈</strong></li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span>&#123;<br>         System.out.println(a/b);<br>     &#125; <span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>         e.printStackTrace();<br>     &#125; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><h3 id="tostring">1.6.2 <strong>toString()</strong></h3><ul><li><code>toString()</code> –该方法以异常名称：<strong>异常描述的格式打印异常信息</strong>。</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span>&#123;<br>         System.out.println(a/b);<br>     &#125; <span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>          System.out.println(e.toString());<br>     &#125; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure><h3 id="getmessage">1.6.3 <strong>getMessage()</strong></h3><ul><li><code>getMessage()</code> -该方法只打印异常的<strong>描述</strong>。</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span>&#123;<br>         System.out.println(a/b);<br>     &#125; <span class="hljs-keyword">catch</span>(ArithmeticException e)&#123;<br>           System.out.println(e.getMessage());<br>     &#125; <br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/ by zero<br></code></pre></td></tr></table></figure><h3 id="不处理异常">1.6.4 不处理异常</h3><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br>     <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>     System.out.println(a/b);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>则为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><h1 id="jvm-是如何处理异常的">2.JVM 是如何处理异常的？</h1><p><strong>默认异常处理：</strong>无论何时在方法内部，如果发生异常，该方法都会创建一个称为异常对象的对象，并将其交给运行时系统(JVM)。</p><p>异常对象包含<strong>异常的名称和描述以及发生异常的程序的当前状态</strong>。创建异常对象并在运行时系统中处理它称为抛出异常。可能有一个已调用的方法列表，以到达发生异常的方法。这个有序的方法列表称为<strong>CallStack</strong>。现在将发生以下过程。</p><ul><li>运行时系统搜索调用堆栈以找到包含可以处理发生的异常的代码块的方法。代码块称为<strong>Exceptionhandler（异常处理程序</strong>）。</li><li>运行时系统从发生异常的方法开始搜索，并按照调用方法的相反顺序遍历调用堆栈。</li><li>如果找到合适的处理程序，则将发生的异常传递给它。合适的处理程序意味着抛出的异常对象的类型与它可以处理的异常对象的类型相匹配。</li><li>如果运行时系统搜索调用堆栈上的所有方法，但找不到合适的处理程序，则运行时系统将Exception Object移交给<strong>默认的异常处理程序</strong>，它是运行时系统的一部分。该处理程序以下列格式打印异常信息并<strong>异常</strong>终止程序。</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Exception <span class="hljs-keyword">in</span> <span class="hljs-keyword">thread</span> <span class="hljs-string">&quot;xxx&quot;</span> Name of Exception : Description<br><span class="hljs-params">...</span> <span class="hljs-params">...</span><span class="hljs-params">...</span> ..  <span class="hljs-comment">// Call Stack</span><br></code></pre></td></tr></table></figure><p>还记得上面，如果没有处理异常打印，它会默认打印：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zero<br>at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.aaa</span><span class="hljs-selector-class">.DDD</span><span class="hljs-selector-class">.main</span>(DDD<span class="hljs-selector-class">.java</span>:<span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><p><strong>调用堆栈的流程</strong></p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/java_se/throwable/call-stack.png"alt="调用堆栈" /><figcaption aria-hidden="true">调用堆栈</figcaption></figure><h1 id="try-catch异常处理">3.try-catch异常处理</h1><p>针对于程序中异常的处理方式，一般有2种：</p><ul><li>手动抛出异常：<code>throw new MyException("your errorCode", "your errorMsg")</code></li><li>通过try-cathc-finally处理</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">4</span>];<br>     System.out.println(<span class="hljs-string">&quot;Hi, I want to execute&quot;</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="hljs-number">4</span><br>at com.example.demo.aaa.DDD.main(DDD.java:<span class="hljs-number">59</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，一个数组被定义为大小，即你只能访问索引 0 到 3的元素。但是你试图访问索引 4处的元素（错误地）这就是它抛出异常的原因。<strong>在这种情况下，JVM异常</strong>终止程序。语句System.out.println("Hi,I want to execute"); 永远不会执行。要执行它，我们必须使用 try-catch处理异常。因此，为了继续程序的正常流程，我们需要一个 try-catch子句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// block of code to monitor for errors</span><br>    <span class="hljs-comment">// the code you think can raise an exception</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 exOb) &#123;<br>    <span class="hljs-comment">// exception handler for ExceptionType1</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 exOb) &#123;<br>    <span class="hljs-comment">// exception handler for ExceptionType2</span><br>&#125;<br><span class="hljs-comment">// optional</span><br><span class="hljs-keyword">finally</span> &#123;  <span class="hljs-comment">// block of code to be executed after try block ends </span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下要点：</p><ul><li><p>在一个方法中，可以有多个可能引发异常的语句，因此将所有这些语句放在它们自己的<strong>try块中，并在它们自己的catch</strong>块中为每个语句提供一个单独的异常处理程序。</p></li><li><p>如果<strong>try</strong>块中发生异常，则该异常由与其关联的异常处理程序处理。要关联异常处理程序，我们必须在它之后放置一个<strong>catch</strong>块。可以有多个异常处理程序。每个<strong>catch</strong>块都是一个异常处理程序，用于处理由其参数指示的类型的异常。参数ExceptionType声明它可以处理的异常类型，并且必须是从<strong>Throwable</strong>类继承的类的名称。</p></li><li><p>对于每个 try 块，可以有零个或多个 catch块，但<strong>只有一个</strong>final 块。</p><blockquote><p>finally 块是可选的。无论 try块中是否发生异常，它总是被执行。如果发生异常，那么它将在<strong>try 和catch 块之后执行。</strong>而如果没有发生异常，那么就会在<strong>try</strong>块之后执行。java中的finally块用于放置重要代码，例如清理代码，例如关闭文件或关闭连接。</p></blockquote></li></ul><h1 id="常见的异常">4.常见的异常</h1><ol type="1"><li><strong>ArithmeticException：</strong>当算术运算出现异常情况时抛出。</li><li><strong>ArrayIndexOutOfBoundsException：</strong>抛出它表示已使用非法索引访问数组。索引为负数或大于或等于数组的大小。</li><li><strong>ClassNotFoundException：</strong>当我们尝试访问未找到其定义的类时引发此异常</li><li><strong>FileNotFoundException：</strong>当文件不可访问或无法打开时会引发此异常。</li><li><strong>IOException：</strong> 当输入输出操作失败或中断时抛出</li><li><strong>InterruptedException：</strong>当一个线程正在等待、休眠或做一些处理，被中断时抛出。</li><li><strong>NoSuchFieldException：</strong>当类不包含指定的字段（或变量）时抛出</li><li><strong>NoSuchMethodException：</strong>访问未找到的方法时抛出。</li><li><strong>NullPointerException：</strong>引用空对象的成员时引发此异常。Null 代表什么都没有</li><li><strong>NumberFormatException：</strong>当方法无法将字符串转换为数字格式时会引发此异常。</li><li><strong>RuntimeException：</strong> 这表示在运行时发生的异常。</li><li><strong>StringIndexOutOfBoundsException：</strong> 它由 String类方法抛出，指示索引为负数或大于字符串的大小</li><li><strong>IllegalArgumentException：</strong>当该方法接收到不完全符合给定关系或条件的参数时，此异常将抛出错误或错误语句。它属于未经检查的异常。</li><li><strong>IllegalStateException：</strong>当应用程序中的特定操作未访问该方法时，此异常将抛出错误或错误消息。它属于未经检查的异常。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>path与classpath</title>
    <link href="/2023/01/28/java_se/2022-05-12_path%E4%B8%8Eclasspath/"/>
    <url>/2023/01/28/java_se/2022-05-12_path%E4%B8%8Eclasspath/</url>
    
    <content type="html"><![CDATA[<h1 id="path与classpath">1.path与classpath</h1><h2 id="作用简介">1.1 作用简介</h2><p>安装完JDK(Java DevelopmentKit，Java开发套件)之后，可以在安装目录下找到两个子目录(bin目录和lib目录)。bin目录中包含着Java编译器等可执行文件。</p><p><strong>PATH 环境变量是由分号(;)分隔的一系列目录。Windows 在 PATH目录中按照从左到右的顺序查找程序</strong>。对于路径中的JDK，一次应该只有一个 bin 目录(第一个目录后面的目录将被忽略)，因此如果已经存在一个 bin 目录，则可以更新该特定条目。</p><p>下面是 PATH 环境变量的一个示例:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Java</span>\<span class="hljs-variable">jdk1</span><span class="hljs-number">.8</span><span class="hljs-number">.0</span><span class="hljs-type">_</span><span class="hljs-number">111</span>\<span class="hljs-variable">bin</span><span class="hljs-operator">;</span><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-variable">System32</span>\<span class="hljs-operator">;</span><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-operator">;</span><span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-variable">System32</span>\<span class="hljs-variable">Wbem</span><br></code></pre></td></tr></table></figure><p>如果不设置 PATH变量，则需要在每次运行可执行文件时指定它的完整路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_111</span>\bin\javac MyClass.java<br></code></pre></td></tr></table></figure><p>如果想方便地从任何目录运行可执行文件(javac.exe，java.exe，javadoc.exe，等等)，可以设置 PATH 环境变量，而不必键入命令的完整路径。</p><p>将<code>%JAVA_HOME%/bin/</code>，添加到环境变量PATH中。再执行java命令时(无论在哪个目录下执行)，系统就会从左到右搜索(<strong><em>这里的顺序很重要，可以利用这个特性覆盖掉某个旧版本的jdk</em></strong>)，环境变量PATH中执行的目录，直到找到对应的可执行文件并执行(找到之后，后面的目录都会被忽略掉)。如果找不到，提示该命令不存在。因此配置了PATH变量后，可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac MyClass.java<br></code></pre></td></tr></table></figure><p>而不必键入命令的完整路径。</p><h1 id="classpath">2.classpath</h1><p>和PATH变量不同，CLASSPATH环境变量的作用是指定Java类所在的目录，告诉应用程序(包括JDK 工具)在哪里查找用户类的一种方法。简单的来说：<strong>Classpath是一个环境变量，应用程序 ClassLoader 或系统使用它来定位和加载存储在.class 文件中的已编译 Java 字节码。</strong></p><h1 id="总结">3.总结</h1><p>PATH 和 CLASSPATH 之间的主要区别在于 PATH 是一个环境变量，用于定位JDK 二进制文件，例如用于运行 java 程序和编译 java源文件的“java”或“javac”命令。</p><p>对于CLASSPATH ，系统或应用程序类加载器使用环境变量 CLASSPATH来定位和加载存储在 .class 文件中的编译 Java 字节码。<ahref="http://javarevisited.blogspot.sg/2011/06/noclassdeffounderror-exception-in.html">java.lang.NoClassDefFoundError</a>和<ahref="http://javarevisited.blogspot.sg/2011/08/classnotfoundexception-in-java-example.html">java.lang.ClassNotFoundException</a>等错误的最常见原因是Java 中的 CLASSPATH 不正确或配置错误。</p><p>其实在上面我们使用的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac MyClass.java<br></code></pre></td></tr></table></figure><p>实际上是在运行 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Classpath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java<br></code></pre></td></tr></table></figure><p>javac就是对上述命令的封装。</p><p>在JDK1.5以后，classpath并不是必须配置了，在JDK1.5之前，是没有办法在当前目录下加载类的（找不到JDK目录下lib文件夹中的.jar文件），所以我们需要通过配置classpath，但JDK1.5之后，JRE能自动搜索目录下类文件，并且加载dt.jar和tool.jar的类。<strong>所以JDK1.5以后，我们只需要配置Java_Home以及path即可！</strong></p><h1 id="read-more">4.Read more</h1><p>:lollipop::https://stackoverflow.com/questions/33062443/what-is-the-difference-between-path-and-classpath-in-java</p><p>:lollipop::https://docs.oracle.com/javase/tutorial/essential/environment/paths.html</p>]]></content>
    
    
    <categories>
      
      <category>Java-SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx介绍，安装</title>
    <link href="/2022/11/12/operations/nginx/2022-11-12_Nginx/"/>
    <url>/2022/11/12/operations/nginx/2022-11-12_Nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="基本介绍">1.基本介绍</h2><ul><li><p><code>Nginx</code> 是一个高性能的 <code>HTTP</code> 和反向代理<code>web</code> 服务器，同时也提供了 <code>IMAP/POP3/SMTP</code>服务。</p></li><li><p><code>Nginx</code> 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的<code>Rambler.ru</code> 站点开发的，第一个公开版本 <code>0.1.0</code>发布于 <code>2004</code> 年 <code>10</code> 月 <code>4</code>日。</p></li><li><p><code>Nginx</code> 特点是占有内存少，并发能力强。</p></li></ul><p>事实上 <code>nginx</code>的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了<code>Nginx</code> ，我们的项目架构可能是这样：</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/15-1.png"alt="15-1" /><figcaption aria-hidden="true">15-1</figcaption></figure><p>在这样的架构中 ， <code>Nginx</code>所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达<code>Nginx</code> 上，再由 <code>Nginx</code>根据提前配置好的转发规则，将客户端发来的请求转发到某一个<code>Tomcat</code> 上去。</p><blockquote><p>Nginx 是一款轻量级的 HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO性能，时常用于服务端的<strong>反向代理</strong>和<strong>负载均衡</strong>。</p></blockquote><p>那么这里涉及到两个概念：负载均衡服务器、反向代理服务器。</p><h2 id="负载均衡服务器">2.负载均衡服务器</h2><p>负载均衡（LoadBalance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个<strong>中间服务器</strong>，再让这个中间服务器在服务器集群中通过负载均衡算法选择一个服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。</p><p>负载均衡策略很多，也有很多层，对于一些大型网站基本上从<code>DNS</code>就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 <code>F5</code>和 <code>Nginx</code> （目前 <code>Nginx</code> 已经被 <code>F5</code>收购），早些年，也可以使用 <code>Apache</code>来做负载均衡，但是效率不如 <code>Nginx</code> ，所以现在主流方案是<code>Nginx</code> 。</p><h3 id="load-balancing-methods">2.1 Load Balancing Methods</h3><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/nginx-server.png"alt="nginx-server" /><figcaption aria-hidden="true">nginx-server</figcaption></figure><p>开源Nginx 支持四种负载平衡方法，NginxPlus还增加了两种方法。所以在Nginx上设置负载平衡时，有五种主要方法。前四个在开源Nginx 和NginxPlus中都可用，而最后一个是Nginx Plus功能。</p><blockquote><p><strong>Nginx Plus 相当于付费版本的Nginx</strong>。提供了更多的功能，针对企业需要的一些服务进行了优化。</p><p>有关功能的比较页面，请参考： <ahref="https://www.nginx.com/products/nginx/compare-models">CompareModels - NGINX</a></p></blockquote><h4 id="round-robin-optionally-weighted">2.1.1 Round Robin, optionallyweighted</h4><p>默认的load balancing方法。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> myapp &#123;<br>    <span class="hljs-attribute">server</span> webserver1.example.com;<br>    <span class="hljs-attribute">server</span> webserver2.example.com;<br>    <span class="hljs-attribute">server</span> webserver3.example.com;<br>&#125;<br></code></pre></td></tr></table></figure><p>在请求过来时，按顺序分发请求，第一次来的server1上，第二次打到server2上，第三次打到server3上，第四次又回到server1上，1-2-3，1-2-3,... 的这样循环。</p><p>Round Robin也可以加权重，为每一个服务器指定权重。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> myapp &#123;<br>    <span class="hljs-attribute">server</span> webserver1.example.com weight = <span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">server</span> webserver2.example.com weight = <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">server</span> webserver3.example.com weight = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样配置后，请求会这样打：1-1-2-3，1-1-2-3, ...</p><blockquote><p>weight越大，负载的权重就越大，默认为1。</p></blockquote><h4 id="least-connected-optionally-weighted">2.1.2 Least Connected,optionally weighted</h4><p>这种方法是每次来的请求都会打到当前连接数最少的upstream里的webserver上，比如有3台server，server1，server2都有10个连接，3只有1个连接，如果在接下来的9个请求1和2的10个连接都没有断开，那么这9个请求都会被打到3上。</p><p>例如有三个负载均衡的服务器，第一个进入的请求非常非常短。它的处理速度非常快——也许只需要10毫秒。下一个请求需要很长时间来处理。第三个也很短。第四个，也很短。第五个，很长。不知何故，这种情况一次又一次地发生，服务器2不断受到这些巨大请求的冲击。它们会持续很长时间，而发送到其他服务器的请求非常短。在这种情况下，循环往复是行不通的，因为随着越来越多的连接进入。接近能够处理的最大连接数，服务器处理每个请求的时间会越来越长。</p><h4 id="ip-hash">2.1.3 IP Hash</h4><p>IPHash会将IP地址的前3个8位元相同的请求打到同一台机器上，来简单的保持回话。这种方法有个弊端是有些内网统一出口ip都会被打到同一台机器，不能有效的实现load-balancing。</p><h4 id="generic-hash">2.1.4 Generic Hash</h4><p>GenericHash可以自定义请求的分发，可以根据IP地址和查询变量或者URL或者其他参数，当这些参数都和上次一样时就会将请求打到上次的那台机器</p><h4 id="least-timenginx-plus-optionally-weighted">2.1.5 Least Time(NginxPlus), optionally weighted</h4><p>Least Time只能在Nginx Plus中用，和LeastConnected类似，会将请求打到连接数最少并且响应速度最快（响应时间最短）的机器上。同时，它也可以像Round Robin一样使用权重。</p><h4 id="如何选择该用哪种load-balancing方法">2.1.6如何选择该用哪种load-balancing方法</h4><ul><li><p><strong>RoundRobin</strong>适用于所有的server配置和位置（同一个机房）都一样，所有的请求都是短暂的请求。</p></li><li><p><strong>LeastConnected</strong>适用于所有的server配置和位置都一样，请求处理时间长度会变的会话。</p></li><li><p><strong>IPHash</strong>适用于需要简单的会话保持（根据客户IP地址的前3个八位元决定被用的服务器）。</p></li><li><p><strong>GenericHash</strong>适用于需要简单的会话保持（基于参数组合的哈希决定被用的服务器）。</p></li><li><p><strong>LeastTime</strong>适用于servers在不同的位置且拥有不同的配置，请求会话长度是可变的，可用于健康检查。</p></li></ul><h1 id="代理服务器">3.代理服务器</h1><p>Nginx作为一个反向代理服务器为我们服务，代理分为<strong>正向代理</strong>和<strong>反向代理</strong>。</p><h3 id="正向代理">3.1 正向代理</h3><p>正向代理，意思是一个位于客户端和原始服务器(originserver)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/image-20221124101743281.png" /></p><h3 id="反向代理">3.2 反向代理</h3><p>反向<strong>代理服务器位于用户与目标服务器</strong>之间，但是对于用户而言，反向<strong>代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/operations/nginx/image-20221124102228743.png"alt="image-20221124102228743" /><figcaption aria-hidden="true">image-20221124102228743</figcaption></figure><h4 id="为什么使用反向代理">为什么使用反向代理</h4><ul><li>可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器。</li><li>通过缓存静态资源，加速Web请求。</li><li>实现负载均衡。顺便说下，目前市面上，主流的负载均衡方案，硬件设备有F5，软件方案有四层负载均衡的LVS，七层负载均衡的Nginx、Haproxy等。</li></ul><h1 id="mac安装nginx">4.Mac安装Nginx</h1><p>在安装前，需要以下应用程序作为支持。如果没有安装以下应用程序则需要安装。</p><ul><li><a href="https://github.com/Homebrew">home brew</a></li></ul><p>mac可以通过<code>brew</code>来方便的安装nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew search nginx --查看nginx版本信息<br>brew install nginx --下载nginx<br></code></pre></td></tr></table></figure><p>然后我们通过命令查看nginx安装信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew info nginx ----查看nginx安装信息<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs stata">wangwang@localhost ~ % brew info nginx<br>nginx: stable 1.21.4 (bottled), HEAD<br>HTTP(S) server and reverse proxy, and IMAP/POP3 proxy server<br>https:<span class="hljs-comment">//nginx.org/</span><br>/usr/<span class="hljs-keyword">local</span>/Cellar/nginx/1.21.4 (26 files, 2.2MB) *<br>  Poured from bottle <span class="hljs-keyword">on</span> 2022-01-26 at 11:12:52<br>From: https:<span class="hljs-comment">//github.com/Homebrew/homebrew-core/blob/HEAD/Formula/nginx.rb</span><br>License: BSD-2-Clause<br>==&gt; Dependencies<br>Required: openssl@1.1 ✔, pcre ✔<br>==&gt; Options<br>--HEAD<br>Install HEAD <span class="hljs-keyword">version</span><br>==&gt; Caveats<br>Docroot is: /usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">var</span>/www<br><br>The default port has been <span class="hljs-keyword">set</span> <span class="hljs-keyword">in</span> /usr/<span class="hljs-keyword">local</span>/etc/nginx/nginx.<span class="hljs-keyword">conf</span> to 8080 <span class="hljs-keyword">so</span> that<br>nginx can <span class="hljs-keyword">run</span> without sudo.<br><br>nginx will load all files <span class="hljs-keyword">in</span> /usr/<span class="hljs-keyword">local</span>/etc/nginx/servers/.<br><br>To restart nginx after <span class="hljs-keyword">an</span> upgrade:<br>  brew services restart nginx<br>Or, <span class="hljs-keyword">if</span> you don&#x27;t want/need a background service you can just <span class="hljs-keyword">run</span>:<br>  /usr/<span class="hljs-keyword">local</span>/opt/nginx/bin/nginx -<span class="hljs-keyword">g</span> daemon off;<br>==&gt; Analytics<br>install: 45,814 (30 days), 114,920 (90 days), 455,820 (365 days)<br>install-<span class="hljs-keyword">on</span>-request: 45,784 (30 days), 114,766 (90 days), 455,039 (365 days)<br>build-<span class="hljs-keyword">error</span>: 1 (30 days)<br></code></pre></td></tr></table></figure><p>我们可以看到默认的配置文件<code>nginx.conf</code>位置信息。通过open命令来打开文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">open /usr/local/etc/nginx --nginx.conf文件目录<br></code></pre></td></tr></table></figure><p>成功打开nginx目录，也可以看到nginx.conf的配置文件（后面会用到这个配置文件）。但我们并没有找到nginx被安装到了哪里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">open  /usr/local/Cellar/nginx  --nginx安装目录<br></code></pre></td></tr></table></figure><p>浏览器输入<code>localhost:8080</code>，我们就能看到如下页面，即Nginx安装成功。</p><figure><img src="/Users/wangwang/Desktop/pic/image-20221125095746582.png"alt="image-20221125095746582" /><figcaption aria-hidden="true">image-20221125095746582</figcaption></figure><h1 id="nginx相关命令">5.Nginx相关命令</h1><ul><li>启动命令： nginx</li><li>快速停止命令 nginx -s stop</li><li>平稳退出命令：nginx -s quit</li><li>重新加载配置文件命令：nginx -s reload</li><li>检查配置文件正确性：nginx -t</li><li>查询nginx主进程号：ps -ef | grep nginx</li></ul><h1 id="nginx小试牛刀">6.Nginx小试牛刀</h1><p>通过前面的简介，我们已经对Nginx有了一个初步的认知。现在我们通过Nginx反向代理来访问我们的服务。</p><p>我们新建一个springboot工程，然后引入web依赖，在controller中写一个入口，来测试Nginx代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/getHello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将端口号改为8089：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span> = <span class="hljs-string">8089</span><br></code></pre></td></tr></table></figure><p>Nginx的配置都是在<code>nginx.conf</code>里，我们通过配置该文件来配置我们的代理。找到localtion位置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>          <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8089;<br>       &#125;<br></code></pre></td></tr></table></figure><p>只需要上面的代码，即可。然后启动Nginx。输入<code>http://localhost:8080/hello/getHello</code>，即可看到如下页面。浏览器不直接访问前台的8089(当然，访问nginx前提是你项目能正常访问)，而是访问nignx的8080，效果如下:</p><figure><img src="/Users/wangwang/Desktop/pic/image-20221125111159370.png"alt="image-20221125111159370" /><figcaption aria-hidden="true">image-20221125111159370</figcaption></figure><p>项目配置的是8089，但是通过访问Nginx的8080端口，Nginx通过配置的路由拦截，通过我们配置的参数代理到8089端口，也就是访问了8089端口并返回了数据，用户在整个过程中是无感知的。这也说明了Nginx是通过反向代理来帮助我们去访问资源。</p><blockquote><p>Nginx 只是一个代理，自身并不提供服务。</p></blockquote><h1 id="nginx启动问题记录">7.Nginx启动问题记录</h1><p>在运行Nginx的时候，遇到一个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx启动或者重启失败，报错nginx: [error] open() <span class="hljs-string">&quot;/usr/local/etc/nginx/nginx.pid&quot;</span> failed (2: No such file or directory)<br></code></pre></td></tr></table></figure><p>解决办法：</p><ol type="1"><li>通过<code>open /usr/local/etc/nginx</code>打开<code>nginx.conf</code>的位置</li><li>新建一个<code>logs</code>文件夹</li><li>配置<code>nginx.conf</code>，更改pid，如下：</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><span class="hljs-attribute">pid</span> /usr/local/etc/nginx/logs/nginx.pid;<br></code></pre></td></tr></table></figure><p>启动Nginx的时候，logs文件夹下会生成nginx.pid。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识磁盘</title>
    <link href="/2022/10/13/system/disk/2022-10-13_%E8%AE%A4%E8%AF%86%E7%A3%81%E7%9B%98/"/>
    <url>/2022/10/13/system/disk/2022-10-13_%E8%AE%A4%E8%AF%86%E7%A3%81%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘">1.磁盘</h1><h2 id="前言">1.1 前言</h2><p>计算机的功能主要为：计算、存储和网络。而用于计算的数据以及计算后的结果很大一部分都需要存储起来，以备后续再次使用。向磁盘中存储和读取的过程叫磁盘I/O。磁盘的读取方式和速度会严重影响到整个业务的计算性能。</p><h2 id="认识磁盘">1.2 认识磁盘</h2><p>下面我们简单了解一下磁盘是如何工作的。</p><p>磁盘大概长这个样子：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172152777.png" /></p><p>磁盘主要由<code>磁盘盘片</code>、<code>传动手臂</code>、<code>读写磁头</code>和<code>马达</code>组成。为了存储容量,主轴像穿糖葫芦一样把多个磁盘片组成一个阵列。通过马达驱动主轴转动以及传动手臂移动，使读写磁头在磁盘片上读写数据。大概如下：</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172239121.png" alt="image-20240109172239121" style="zoom:50%;" /></p><h3 id="磁盘盘片platter">磁盘盘片（platter）</h3><p>磁盘盘片是由坚硬金属材料制成的涂以磁性介质的盘片，这些磁性物质用来记录二进制数据，不同容量硬盘的盘片数不等。因为正反两面都可涂上磁性物质，故一个盘片可能会有两个盘面。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。它们从上至下从“0”开始依次编号。</p><h4 id="磁道track">磁道（track）</h4><p>当磁盘旋转时,磁头若保持在一个位置上,则每个磁头都会在磁盘表面划出一个圆形轨迹,这些圆形轨迹就叫做<strong>磁道</strong>。这些磁道用肉眼是根本看不到的,因为它们仅是盘面上以特殊方式磁化了的一些磁化区,磁盘上的信息便是沿着这样的轨道存放的。相邻磁道之间并不是紧挨着的,这是因为磁化单元相隔太近时磁性会相互产生影响,同时也为磁头的读写带来困难。<strong>磁道从外向内从0开始顺序编号</strong>。数据就是写在这些磁道上。如下：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172316704.png" /></p><h4 id="扇区sector">扇区（sector）</h4><p>一个盘面划分为若干内角相同的扇形，这样盘面上的每个磁道就被分为若干段圆弧，<strong>每段圆弧</strong>叫一个<strong>扇区</strong>。</p><p>扇区是磁盘的最小组成单元，每个扇区可存储128×2的N次方（N＝0.1.2.3）字节信息。在DOS中每扇区是128×2的2次方＝512字节。</p><p>为了对扇区进行查找和管理，需要对扇区进行编号，扇区的编号<strong>由外向内</strong>从0磁道开始，起始扇区为1扇区，其后为2扇区、3扇区……，0磁道的扇区编号结束后，1磁道的起始扇区累计编号，直到最后一个磁道的最后一个扇区（n扇区）。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/9me5eyp5tb.png" /></p><p>在老式硬盘中，尽管磁道周长不同，但每个磁道上的扇区数是相等的，越往圆心扇区弧段越短，但其存储密度越高。不过这种方式显然比较浪费空间，因此现代硬盘则改为等密度结构，这意味着外围磁道上的扇区数量要大于内圈的磁道，寻址方式也改为以扇区为单位的线性寻址。为了兼容老式的3D 寻址方式，现代硬盘控制器中都有一个地址翻译器将 3D寻址参数翻译为线性参数。</p><blockquote><p>硬盘在进行扇区编号时与软盘有一些区别，在软盘的一个磁道中，扇区号一次编排，即1、2、3……n扇区。由于硬盘的转速较高，磁头在完成某个扇区数据的读写后，必须将数据传输到微机，这需要一个时间，但是这时硬盘在继续高速旋转，当数据传输完成后，磁头读写第二个扇区时，磁盘已经旋转到了另外一个扇区。因此在早期硬盘中，扇区号是按照某个间隔系数跳跃编排的。</p></blockquote><blockquote><p>3D 寻址参数：×× 磁道(柱面)，×× 磁头，×× 扇区</p></blockquote><h4 id="柱面cylinder">柱面（cylinder）</h4><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号（相同半径）的磁道形成一个圆柱，所以就是<strong>不同盘片相同半径的磁道</strong>所组成的<strong>圆柱</strong>称为<strong>柱面</strong>。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，柱面数等于磁道数。</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/tx1zz26zx6.png" style="zoom:67%;" /></p><h2 id="磁盘容量计算">1.3 磁盘容量计算</h2><p>扇区，磁道（或柱面）和磁头数构成了硬盘结构的基本参数，这些参数可以得到硬盘的容量，基计算公式为：</p><blockquote><p>存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数</p></blockquote><p>如上图，，磁盘是一个3个磁盘、6个磁头、7个柱面（每个磁盘有7个磁道）的磁盘，每条磁道有12个扇区，所以磁盘的容量为：</p><p>6 * 7 * 12 * 512 = 258048（字节）</p><blockquote><p>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</p></blockquote><p>并且：</p><blockquote><p>数据的读/写按柱面从外向内进行，而不是按盘面进行。是因为虽然每个盘面对应一个磁头。但是所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p></blockquote><h2 id="磁盘读取">1.4 磁盘读取</h2><p><strong>扇区编号定义</strong>：由前面介绍可知，我们可以用柱面 + 磁头+扇区来唯一定位磁盘上每一个区域，或是说柱面/磁头/扇区与磁盘上每一个扇区有一一对应关系，通常DOS 将“柱面/磁头/扇区”这样表示法称为“绝对扇区”表示法。</p><p>但 DOS不能直接使用绝对扇区进行磁盘上的信息管理，而是用所谓“相对扇区”或“DOS扇区”。</p><p>“相对扇区”只是一个数字，如柱面 140，磁头 3，扇区 4 对应的相对扇区号为2757。该数字与绝对扇区“柱面/磁头/扇区”具有一一对应关系。当使用相对扇区编号时，DOS是从柱面 0，磁头 1，扇区 1 开始（注：柱面 0，磁头 0，扇区 1 没有 DOS扇区编号，DOS下不能访问，只能调用 BIOS 访问），第一个 DOS 扇区编号为0，该磁道上剩余的扇区编号为 1 到 16（设每磁道 17个扇区），然后是磁头号为 2，柱面为 0的 17 个扇区，形成的 DOS 扇区号从 17到 33。直到该柱面的所有磁头。然后再移到柱面 1，磁头 1，扇区 1 继续进行DOS 扇区的编号，即按扇区号，磁头号，柱面号（磁道号）增长的顺序连续地分配DOS 扇区号。</p><blockquote><p>DOS:<ahref="https://baike.baidu.com/item/磁盘操作系统/3793138?fromModule=lemma_inlink">磁盘操作系统</a>（DiskOperating System）</p></blockquote><p>如果现在要读取某一位置的数据，磁盘需要：</p><ol type="1"><li>寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</li><li>旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。</li><li>数据传输时间：完成传输所请求的数据所需要的时间。</li></ol><h2 id="磁盘块簇page">1.5 磁盘块/簇、page</h2><p>扇区是硬盘数据存储的最小单位，但操作系统无法对数目众多的扇区进行寻址，所以操作系统就将<strong>相邻的扇区组合在一起，形成一个簇</strong>，然后再对簇进行管理.每个簇可以包括2、4、8、16、32、64个扇区。簇有时也称作磁盘块(block)。它是属于文件系统层面的概念，是文件系统层中数据存储的基本单位</p><p>“簇”是DOS进行分配的最小单位。当创建一个很小的文件时，如是一个字节，则它在磁盘上并不是只占一个字节的空间，而是占有整个一簇。</p><p>DOS视不同的存储介质（如软盘，硬盘），不同容量的硬盘，簇的大小也不一样。簇的大小可在称为磁盘参数块（BPB）中获取。簇的概念仅适用于数据区。磁盘驱动器在向磁盘读取和写入数据时，要以扇区为单位。<strong>在磁盘上，DOS操作系统是以“簇”为单位为文件分配磁盘空间的。硬盘的簇通常为多个扇区，与磁盘的种类、DOS版本及硬盘分区的大小有关</strong>。每个簇只能由一个文件占用，即使这个文件中有几个字节，决不允许两个以上的文件共用一个簇，否则会造成数据的混乱。</p><p>这种以簇为最小分配单位的机制，使硬盘对数据的管理变得相对容易，但也造成了磁盘空间的浪费，尤其是小文件数目较多的情况下，一个上千兆的大硬盘，其浪费的磁盘空间可达上百兆字节。（1）“簇”是DOS进行分配的最小单位。（2）不同的存储介质，不同容量的硬盘，不同的DOS版本，簇的大小也不一样。（3）簇的概念仅适用于数据区。</p><p>已经有了扇区，为什么还需要簇？</p><blockquote><p>读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。</p><p>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。</p></blockquote><p><strong>page</strong></p><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p><h4 id="扇区块簇page的关系">扇区、块/簇、page的关系</h4><ol type="1"><li>扇区： 硬盘的最小读写单元</li><li>块/簇： 是操作系统针对硬盘读写的最小单元</li><li>page： 是内存与操作系统之间操作的最小单元。</li></ol><p>扇区 &lt;= 块/簇 &lt;= page</p><h2 id="整体描述">1.6 整体描述</h2><p>下面我们用几张图来整体描述磁盘相关知识点：</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172239121.png" alt="image-20240109172239121" style="zoom:50%;" /></p><p>磁盘由<code>磁盘盘片</code>、<code>传动手臂</code>、<code>读写磁头</code>和<code>马达</code>组成。为了存储容量,主轴像穿糖葫芦一样把多个磁盘片组成一个阵列。通过马达驱动主轴转动以及传动手臂移动，使读写磁头在磁盘片上读写数据。</p><p>数据的读/写按柱面从外向内进行，而不是按盘面进行。是因为虽然每个盘面对应一个磁头。但是所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172330313.png" /></p><p>在磁盘中，磁道被分为多个内角相等的区域，这个区域叫做扇面，在扇面中，每一条被划分的磁道被称为扇区。</p><p>根据×× 磁道(柱面)（找第几个磁道），×× 磁头（找到第几个磁盘），××扇区（找到对应的区域）能定位磁盘上每一个区域。</p><p>磁盘驱动器在向磁盘读取和写入数据时，要以<strong>扇区</strong>为单位。在磁盘上，DOS操作系统是以“簇”为单位为文件分配磁盘空间的。硬盘的簇通常为多个扇区，与磁盘的种类、DOS版本及硬盘分区的大小有关。</p><p>如果磁盘是一记事本，那么一张磁盘片就是本子的一页纸，而主轴就是本子的装订线；磁道就是纸页的行，而扇区可以看作是很宽的列。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172342837.png" /></p><p>如果在磁盘中存储一首诗,想象中大概这个样子。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172357093.png" /></p><p>磁盘的读 I/O操作,需要找到数据所在的<strong>磁盘片</strong>，以及对应的磁道和<strong>扇区</strong>。这些操作类似于从一本书中找到数据所在的页，行，列。</p><p>因为每个磁盘片都对应一个磁头，所以性能的关键就在于找行和列，即<strong>寻道</strong>和磁盘旋转。寻道即通过磁头找到数据所在的磁道，相当于换行到数据所在行。由于磁头只能水平移动，即只能换行寻道，无法在指定磁道上移动，因此需要磁盘高速旋转移动到指定扇区，类似写春联时，笔不动，纸动。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/system/disk/image-20240109172418949.png" /></p><p>综上所述，磁盘的读写是通过机械运动来定位数据所在位置，而 cpu是通过电信号进行数字运算。粗略的认为，机械查询数据，与光速处理数据的性能完全不是在一个量级，总之一句话就是<strong>磁盘处理太慢太慢了</strong>。</p><p>虽然磁盘处理数据太慢了，但是它是目前相对廉价且稳定的存储设备，所以又不能舍弃不用，但大致可以通过以下方法进行优化。</p><ul><li>尽量减少 I/O 次数，比如可以使用缓存；</li><li>每次 I/O 尽量获取更多的数据；</li><li>每次 I/O 尽量获取有用的数据，当然相应的也间接减少总 I/O 次数；</li></ul><h2 id="k对齐">1.7 4K对齐</h2><p>早期的硬盘一个扇区的大小是512个字节，后来随之磁盘容量的不断增加和读写效率提升的要求，将每个扇区的大小调整为4096个字节，也就是4KB，这种扇区又叫4K扇区。4K对齐指的就是对磁盘分区时，让分区的起始扇区位于某一个4K扇区的起始位置。所以分区起始位置只要是4096的倍数就是4K对齐了。</p><p>https://cloud.tencent.com/developer/article/1129947</p><p>https://blog.csdn.net/xiaominthere/article/details/19756551</p><p>https://blog.csdn.net/t_1007/article/details/53032682</p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>磁盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式数据的一致性-ZAB协议</title>
    <link href="/2022/09/24/framework/zookeeper/2022-09-24_%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/09/24/framework/zookeeper/2022-09-24_%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-ZAB%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>我们知道在 ZooKeeper 集群中，服务器分为 Leader 服务器、 Follower服务器以及 Observer 服务器。</p><p>可以这样认为，Leader 选举是一个过程，在这个过程中 ZooKeeper主要做了两个重要工作，一个是数据同步，另一个是选举出新的 Leader服务器。今天我们主要先介绍第一个工作，ZooKeeper集群中的数据同步问题。</p><h3 id="leader-的协调过程">Leader 的协调过程</h3><p>在分布式系统中有一个著名的 CAP定理，是说一个分布式系统不能同时满足一致性、可用性，以及分区容错性。今天我们要讲的就是一致性。其实ZooKeeper中实现的一致性也不是强一致性，即集群中各个服务器上的数据每时每刻都是保持一致的特性。在ZooKeeper中，采用的是最终一致的特性，<strong>即经过一段时间后，ZooKeeper集群服务器上的数据最终保持一致的特性</strong>。</p><p>在 ZooKeeper 集群中，Leader服务器主要负责处理事物性的请求，而在接收到一个客户端的事务性请求操作时，Leader服务器会先向集群中的各个机器针对该条会话发起投票询问。</p><p><strong>什么情况下会对 ZooKeeper集群服务产生不一致的情况？</strong></p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230509160259683.png"alt="image-20230509160259683" /><figcaption aria-hidden="true">image-20230509160259683</figcaption></figure><p>在集群初始化启动的时候，首先要同步集群中各个服务器上的数据。而在集群中Leader 服务器崩溃时，需要选举出新的 Leader而在这一过程中会导致各个服务器上数据的不一致，所以当选举出新的 Leader服务器后需要进行数据的同步操作。</p><h1 id="zab协议">1.ZAB协议</h1><p>ZooKeeper最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群Leader节点发生重新选举时，都会产生数据不一致的情况。为了解决这个问题，ZooKeeper采用了 ZAB 协议算法。</p><p><strong>ZAB 协议算法</strong>（Zookeeper Atomic Broadcast ，Zookeeper原子广播协议）是 ZooKeeper专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是<strong>崩溃恢复</strong>和<strong>原子广播协议</strong>。</p><p>在整个 ZAB 协议的底层实现中，ZooKeeper集群主要采用<strong>主从模式</strong>的系统架构方式来保证 ZooKeeper集群系统的一致性。<strong>实现了一种主备模式的系统架构保持集群中各副本之间数据的一致性，主备模式保证了同一时刻集群汇总只能够有一个主进程来广播服务器的状态变更，因此可以很好的处理客户端大量的并发请求.</strong></p><blockquote><p>ZAB协议的核心是定义了<strong>对于那些会改变Zookeeper服务器数据状态的事务请求的处理方式</strong>。</p></blockquote><p>整个实现过程如下图所示，当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230306175503379.png"alt="image-20230306175503379" /><figcaption aria-hidden="true">image-20230306175503379</figcaption></figure><p>思想如下：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20220729222815112.png"alt="image-20220729222815112" /><figcaption aria-hidden="true">image-20220729222815112</figcaption></figure><p>以 ZooKeeper 集群为例，这个操作过程可以概括为：当 ZooKeeper集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow角色服务器会将该请求转发给 Leader 角色服务器进行处理。当 Leader节点服务器在处理完该条会话请求后。</p><p><strong><em>Leader服务器负责将一个客户端事务请求转化成一个事务Proposal(提议)，并将该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交，最终完成整个ZooKeeper 集群对客户端会话的处理工作。</em></strong></p><blockquote><p>所有事务请求必须由一个<strong>全局唯一的服务器</strong>来协调处理，这样的服务器被称为<code>Leader服务器</code>，余下的服务器则称为<code>Follower服务器</code>，</p></blockquote><h1 id="zab协议两种基本模式">2.ZAB协议两种基本模式</h1><p>ZAB协议包括两种基本模式：<code>崩溃恢复模式</code>和<code>消息广播模式</code>。</p><h2 id="崩溃恢复模式">2.1 <strong>崩溃恢复模式</strong></h2><p>当整个服务框架启动过程中,或者是Leader服务器出现<strong>网络中断</strong>、<strong>崩溃退出</strong>或<strong>重启</strong>等异常情况时,ZAB协议就会进入<code>崩溃恢复模式</code>,同时选举产生新的Leader服务器。当选举产生了新的Leader服务器,同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后,ZAB协议就会<code>退出恢复模式</code>,其中,所谓的状态同步就是指数据同步,用来<strong>保证集群中过半的机器能够和Leader服务器的数据状态保持一致。</strong></p><h2 id="消息广播模式">2.2 <strong>消息广播模式</strong></h2><p>当集群中已经有<strong>过半的Follower服务器完成了和Leader服务器的状态同步</strong>,那么整个服务框架就可以进入消息广播模式,当一台同样遵守ZAB协议的服务器启动后加入到集群中,如果此时集群中已经存在一个Leader服务器在负责进行消息广播,那么加入的服务器就会自觉地进入数据恢复模式:找到Leader所在的服务器,并与其进行数据同步,然后一起参与到消息广播流程中去。<code>Zookeeper只允许唯一的一个Leader服务器来进行事务请求的处理</code>,Leader服务器在接收到客户端的事务请求后,会生成对应的事务提议并发起一轮广播协议,而如果集群中的其他机器收到客户端的事务请求后,那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p><p>当Leader服务器出现崩溃或者机器重启、集群中已经不存在过半的服务器与Leader服务器保持正常通信时，那么在重新开始新的一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此到达一致状态，于是整个ZAB流程就会从<strong>消息广播模式进入到崩溃恢复模式</strong>。</p><p>http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/29%20ZAB%20%E5%8D%8F%E8%AE%AE%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E5%92%8C%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.md</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper服务数据与文件</title>
    <link href="/2022/09/20/framework/zookeeper/2022-09-20_Zookeeper%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/20/framework/zookeeper/2022-09-20_Zookeeper%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper服务数据与文件">Zookeeper服务数据与文件</h1><p>ZooKeeper框架能够实现的功能，而无论是什么程序，其本质就是对数据的操作。比如 MySQl数据库操作的是数据表，Redis 数据库操作的是存储在内存中的 Key-Value值。不同的数据格式和存储方式对系统运行的效率和处理能力都有很大影响。本课时就来学习，在ZooKeeper程序运行期间，都会处理哪些数据，以及他们的存储格式和存储位置。</p><p>ZooKeeper 服务提供了创建节点、添加 Watcher监控机制、集群服务等丰富的功能。这些功能服务的实现，离不开底层数据的支持。从数据存储地点角度讲，ZooKeeper服务产生的数据可以分为内存数据和磁盘数据。而从数据的种类和作用上来说，又可以分为事务日志数据和数据快照数据。</p><h1 id="内存数据">1.内存数据</h1><p>数据节点实际上就是 ZooKeeper 在服务运行过程中所操作的数据。ZooKeeper的数据模型可以看作一棵<strong>树形结构</strong>，而数据节点就是这棵树上的叶子节点。从数据存储的角度看，ZooKeeper的数据模型是存储在内存中的。我们可以把 ZooKeeper的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的ACL 权限信息以及 stat 状态信息等。</p><p>而在底层实现中，ZooKeeper 数据模型是通过 DataTree类来定义的。如下面的代码所示，DataTree 类定义了一个 ZooKeeper数据的内存结构。DataTree 的内部定义类 nodes 节点类型、root根节点信息、子节点的 WatchManager监控信息等数据模型中的相关信息。可以说，一个 DataTree 类定义了 ZooKeeper内存数据的逻辑结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataTree</span> &#123;<br><br>  <span class="hljs-keyword">private</span> DataNode root<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager dataWatches<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager childWatches<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">rootZookeeper</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事务日志">2.事务日志</h1><p>为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper集群中的 Follow 和 Observer服务器就会进行数据同步。而这两种角色服务器所接收到的信息就是 Leader服务器的事务日志。在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个ZooKeeper 集群的执行性能。</p><p>在我们启动一个 ZooKeeper 服务器之前，首先要创建一个 zoo.cfg文件并进行相关配置，其中有一项配置就是 <code>dataLogDir</code>。在这项配置中，我们会指定该台 ZooKeeper 服务器事务日志的存放位置</p><p>在 ZooKeeper 服务的底层实现中，是通过 FileTxnLog类来实现事务日志的底层操作的。如下图代码所示，在 FileTxnLog类中定义了一些属性字段，分别是：</p><ul><li><p>preAllocSize：可存储的日志文件大小。如用户不进行特殊设置，默认的大小为65536*1024 字节。</p></li><li><p>TXNLOG_MAGIC：设置日志文件的魔数信息为ZKLG。</p></li><li><p>VERSION：设置日志文件的版本信息。</p></li><li><p>lastZxidSeen：最后一次更新日志得到的 ZXID。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTxnLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TxnLog</span>, Closeable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TXNLOG_MAGIC</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;ZKLG&quot;</span>.getBytes()).getInt();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VERSION</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <br>      <span class="hljs-comment">/** Maximum time we allow for elapsed fsync before WARNing */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> fsyncWarningThresholdMS;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilePadding</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">preAllocSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">65536</span> * <span class="hljs-number">1024</span>;<br>    ... ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>定义了事务日志操作的相关指标参数后，在 FileTxnLog 类中调用 static静态代码块，来将这些配置参数进行初始化。比如读取 preAllocSize参数分配给日志文件的空间大小等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    LOG = LoggerFactory.getLogger(FileTxnLog.class);<br><br>    <span class="hljs-comment">/** Local variable to read fsync.warningthresholdms into */</span><br>    Long fsyncWarningThreshold;<br>    <span class="hljs-keyword">if</span> ((fsyncWarningThreshold = Long.getLong(ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY)) == <span class="hljs-literal">null</span>) &#123;<br>        fsyncWarningThreshold = Long.getLong(FSYNC_WARNING_THRESHOLD_MS_PROPERTY, <span class="hljs-number">1000</span>);<br>    &#125;<br>    fsyncWarningThresholdMS = fsyncWarningThreshold;<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">logSize</span> <span class="hljs-operator">=</span> Long.getLong(txnLogSizeLimitSetting, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (logSize &gt; <span class="hljs-number">0</span>) &#123;<br>        LOG.info(<span class="hljs-string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, txnLogSizeLimitSetting, logSize);<br><br>        <span class="hljs-comment">// Convert to bytes</span><br>        logSize = logSize * <span class="hljs-number">1024</span>;<br>        txnLogSizeLimit = logSize;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过参数定义和日志文件的初始化创建后，在 ZooKeeper 服务器的 dataDir路径下就生成了一个用于存储事务性操作的日志文件。我们知道在 ZooKeeper服务运行过程中，会不断地接收和处理来自客户端的事务性会话请求，这就要求每次在处理事务性请求的时候，都要记录这些信息到事务日志中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * append an entry to the transaction log</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hdr the header of the transaction</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> txn the transaction part of the entry</span><br><span class="hljs-comment">     * returns true iff something appended, otw false</span><br><span class="hljs-comment">     * 向事务日志追加一个条目</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">append</span><span class="hljs-params">(TxnHeader hdr, Record txn)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>              <span class="hljs-keyword">return</span> append(hdr, txn, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">append</span><span class="hljs-params">(TxnHeader hdr, Record txn, TxnDigest digest)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (hdr == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hdr.getZxid() &lt;= lastZxidSeen) &#123;<br>            LOG.warn(<br>                <span class="hljs-string">&quot;Current zxid &#123;&#125; is &lt;= &#123;&#125; for &#123;&#125;&quot;</span>,<br>                hdr.getZxid(),<br>                lastZxidSeen,<br>                Request.op2String(hdr.getType()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lastZxidSeen = hdr.getZxid();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (logStream == <span class="hljs-literal">null</span>) &#123;<br>            LOG.info(<span class="hljs-string">&quot;Creating new log file: &#123;&#125;&quot;</span>, Util.makeLogName(hdr.getZxid()));<br><br>            logFileWrite = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logDir, Util.makeLogName(hdr.getZxid()));<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(logFileWrite);<br>            logStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>            oa = BinaryOutputArchive.getArchive(logStream);<br>            <span class="hljs-type">FileHeader</span> <span class="hljs-variable">fhdr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileHeader</span>(TXNLOG_MAGIC, VERSION, dbId);<br>            fhdr.serialize(oa, <span class="hljs-string">&quot;fileheader&quot;</span>);<br>            <span class="hljs-comment">// Make sure that the magic number is written before padding.</span><br>            logStream.flush();<br>            filePadding.setCurrentSize(fos.getChannel().position());<br>            streamsToFlush.add(fos);<br>        &#125;<br>        filePadding.padFile(fos.getChannel());<br>        <span class="hljs-type">byte</span>[] buf = Util.marshallTxnEntry(hdr, txn, digest);<br>        <span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">null</span> || buf.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Faulty serialization for header &quot;</span> + <span class="hljs-string">&quot;and txn&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Checksum</span> <span class="hljs-variable">crc</span> <span class="hljs-operator">=</span> makeChecksumAlgorithm();<br>        crc.update(buf, <span class="hljs-number">0</span>, buf.length);<br>        oa.writeLong(crc.getValue(), <span class="hljs-string">&quot;txnEntryCRC&quot;</span>);<br>        Util.writeTxnBytes(oa, buf);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>从对事务日志的底底层代码分析中可以看出，在 datadir配置参数路径下存放着 ZooKeeper服务器所有的事务日志，所有事务日志的命名方法都是“log.+ 该条事务会话的zxid”。</p></blockquote><h1 id="数据快照">3.数据快照</h1><p>说到快照，可能很多技术人员都不陌生。一个快照可以看作是当前系统或软件服务运行状态和数据的副本。在ZooKeeper中，数据快照的作用是将内存数据结构存储到本地磁盘中。因此，从设计的角度说，数据快照与内存数据的逻辑结构一样，都使用DataTree 结构。在 ZooKeeper服务运行的过程中，数据快照每间隔一段时间，就会把 ZooKeeper内存中的数据存储到磁盘中，快照文件是间隔一段时间后对内存数据的备份。</p><p>因此，与内存数据相比，快照文件的数据具有滞后性。而与上面介绍的事务日志文件一样，在创建数据快照文件时，也是使用zxid 作为文件名称。</p><p>在代码层面，ZooKeeper 通过 FileTxnSnapLog类来实现数据快照的相关功能。如下图所示，在FileTxnSnapLog类的内部，最核心的方法是 save 方法，在 save方法的内部，首先会创建数据快照文件，之后调用 FileSnap类对<code>内存数据进行序列化，并写入到快照文件中</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(DataTree dataTree,</span><br><span class="hljs-params"></span><br><span class="hljs-params">                 ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeouts,</span><br><span class="hljs-params"></span><br><span class="hljs-params">                 <span class="hljs-type">boolean</span> syncSnap)</span><br><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">lastZxid</span> <span class="hljs-operator">=</span> dataTree.lastProcessedZxid;<br><br>    <span class="hljs-type">File</span> <span class="hljs-variable">snapshotFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(snapDir, Util.makeSnapshotName(lastZxid));<br><br>    LOG.info(<span class="hljs-string">&quot;Snapshotting: 0x&#123;&#125; to &#123;&#125;&quot;</span>, Long.toHexString(lastZxid),<br><br>            snapshotFile);<br><br>    snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">4.总结</h1><p>我们知道在 ZooKeeper服务的运行过程中，<strong>会涉及内存数据</strong>、<strong>事务日志</strong>、<strong>数据快照这三种数据文件</strong>。从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。事务日志数据主要用于记录本地事务性会话操作，用于ZooKeeper集群服务器之间的数据同步。事务快照则是将内存数据持久化到本地磁盘。</p><p>这里要注意的一点是，<strong>数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致</strong>。在单台ZooKeeper服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper-Watch 机制</title>
    <link href="/2022/09/19/framework/zookeeper/2022-09-19_Zookeeper-Watch%20%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/09/19/framework/zookeeper/2022-09-19_Zookeeper-Watch%20%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="watch-机制">1. Watch 机制</h1><p>在日常生活中也有很多订阅发布的场景。比如我们喜欢观看某一个剧集，视频网站会有一个订阅按钮，用户可以订阅自己喜欢的电视剧，当有新的剧集发布时，网站会通知该用户第一时间观看。或者我们在网站上看到一件心仪的商品，但是当前没有库存，网站会提供到货通知的功能，我们开启这个商品的到货通知功能后，商品补货的时候会通知我们，之后就可以进行购买了。ZooKeeper中的 Watch机制很像这些日常的应用场景，其中的客户端就是用户，而服务端的数据节点就好像是我们订阅的商品或剧集。</p><p>现在我们可以从技术实现的角度分析一下上边提到的这些场景，无论是订阅一集电视剧还是订购一件商品。都有几个核心节点，即用户端注册服务、服务端处理请求、客户端收到回调后执行相应的操作。</p><h1 id="zookeeper-watch机制">2. Zookeeper-Watch机制</h1><p>ZooKeeper 中的 Watch机制<strong>实现了分布式的通知功能，Zookeeper允许客户端向服务端注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，就会向客户端发送一个事件通知来实现分布式的通知功能。</strong></p><p>我们知道Zookeeper是通过<strong>节点</strong>储存数据的，因此当ZNode节点数据发生变化的时候就能触发。过程如下：</p><p><img src="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/typora/project/20181030160347021812.jpeg" alt="技术分享图片" style="zoom:70%;" /></p><p><strong>ZooKeeper 的客户端也可以通过 Watch机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知</strong>，我们可以通过向ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(String connectString, <span class="hljs-type">int</span> sessionTimeout, Watcher watcher)<br></code></pre></td></tr></table></figure><p>上面代码的意思是定义了一个了 ZooKeeper客户端对象实例，并传入三个参数：</p><ul><li><p>connectString 服务端地址</p></li><li><p>sessionTimeout：超时时间</p></li><li><p>Watcher：监控事件</p></li></ul><p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文，一直被保存在客户端 <code>ZKWatchManager</code> 的<code>defaultWatcher</code> 中。</p><p>除此之外，ZooKeeper 客户端也可以通过 <code>getData</code>、<code>getChildren</code> 和<code>exists</code>三个接口来向 ZooKeeper服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p><blockquote><p>getData(String path, Watcher watcher, Stat stat)</p></blockquote><h1 id="状态和事件">3. 状态和事件</h1><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F61ILaAb7sQAAC6T3wMHDU651.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。例如在客户端连接服务端的时候，可以对数据节点的<code>创建、删除、数据变更、子节点的更新</code>等操作进行监控。</p><h1 id="watch-机制的底层原理">4. Watch 机制的底层原理</h1><p>由于 Watch机制涉及了客户端和服务端的多个函数和操作节点，单单按照程序执行流程分析跳跃性对整体实现机制的理解难度大。为了更好地阐述Watch 机制，我们另辟蹊径，从设计模式角度出发来分析其底层实现：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F61IL-AEQuUAABdpaAsy2k628.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>学习 Watch机制的时候，它给我的第一印象是，其结构很像设计模式中的”观察者模式“，一个对象或者数据节点可能会被多个客户端监控，当对应事件被触发时，会通知这些对象或客户端。我们可以将Watch机制理解为是分布式环境下的观察者模式。所以接下来我们就以<code>观察者模式</code>的角度点来看看ZooKeeper 底层 Watch 是如何实现的。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F61IMWAbWW9AABzXk9xuOs953.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>通常我们在实现观察者模式时，最核心或者说关键的代码就是<strong>创建一个列表来存放观察者</strong>。而在 ZooKeeper中则是在客户端和服务器端分别实现两个存放观察者列表，即：<code>ZKWatchManager</code>和 <code>WatchManager</code>。其核心操作就是围绕着这两个展开的。</p><h2 id="客户端-watch-注册实现过程">4.1 客户端 Watch 注册实现过程</h2><p>客户端在发送一个 Watch 监控事件的会话请求时，ZooKeeper客户端主要做了两个工作：</p><ul><li><p>标记该会话是一个带有 Watch 事件的请求</p></li><li><p>将 Watch 事件存储到 ZKWatchManager</p></li><li><p><strong>getData</strong></p></li></ul><p>我们以 getData 接口为例。当发送一个带有 Watch事件的请求时，客户端首先会把该会话标记为带有 Watch监控的事件请求，之后通过 DataWatchRegistration 类来保存 watcher事件和节点的对应关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the data and the stat of the node of the given path.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * If the watch is non-null and the call is successful (no exception is</span><br><span class="hljs-comment">     * thrown), a watch will be left on the node with the given path. The watch</span><br><span class="hljs-comment">     * will be triggered by a successful operation that sets data on the node, or</span><br><span class="hljs-comment">     * deletes the node.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * A KeeperException with error code KeeperException.NoNode will be thrown</span><br><span class="hljs-comment">     * if no node with the given path exists.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path the given path</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> watcher explicit watcher</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stat the stat of the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the data of the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException If the server signals an error with a non-zero error code</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException If the server transaction is interrupted.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if an invalid path is specified</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getData(<span class="hljs-keyword">final</span> String path, Watcher watcher, Stat stat) <span class="hljs-keyword">throws</span> KeeperException, InterruptedException &#123;<br>        ... ...<br>        <span class="hljs-type">WatchRegistration</span> <span class="hljs-variable">wcb</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (watcher != <span class="hljs-literal">null</span>) &#123;<br>            wcb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataWatchRegistration</span>(watcher, clientPath);<br>        &#125;<br>        <br>        <span class="hljs-type">RequestHeader</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeader</span>();<br>        <br>        <span class="hljs-type">GetDataRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetDataRequest</span>();<br>        ... ...<br>        request.setWatch(watcher != <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">GetDataResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetDataResponse</span>();<br>        <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cnxn.submitRequest(h, request, response, wcb);<br>        ... ...<br>        <span class="hljs-keyword">return</span> response.getData();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>cnxn.submitRequest</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReplyHeader <span class="hljs-title function_">submitRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">    RequestHeader h,</span><br><span class="hljs-params">    Record request,</span><br><span class="hljs-params">    Record response,</span><br><span class="hljs-params">    WatchRegistration watchRegistration)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">return</span> submitRequest(h, request, response, watchRegistration, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> ReplyHeader <span class="hljs-title function_">submitRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">    RequestHeader h,</span><br><span class="hljs-params">    Record request,</span><br><span class="hljs-params">    Record response,</span><br><span class="hljs-params">    WatchRegistration watchRegistration,</span><br><span class="hljs-params">    WatchDeregistration watchDeregistration)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplyHeader</span>();<br>    <span class="hljs-type">Packet</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> queuePacket(<br>        h,<br>        r,<br>        request,<br>        response,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        watchRegistration,<br>        watchDeregistration);<br>     ... ...<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>queuePacket</strong></li></ul><p>之后客户端向服务器发送请求时，是将请求封装成一个 <code>Packet</code>对象，并添加到一个等待发送队列 outgoingQueue 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressFBWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)</span><br><span class="hljs-keyword">public</span> Packet <span class="hljs-title function_">queuePacket</span><span class="hljs-params">(</span><br><span class="hljs-params">    RequestHeader h,</span><br><span class="hljs-params">    ReplyHeader r,</span><br><span class="hljs-params">    Record request,</span><br><span class="hljs-params">    Record response,</span><br><span class="hljs-params">    AsyncCallback cb,</span><br><span class="hljs-params">    String clientPath,</span><br><span class="hljs-params">    String serverPath,</span><br><span class="hljs-params">    Object ctx,</span><br><span class="hljs-params">    WatchRegistration watchRegistration,</span><br><span class="hljs-params">    WatchDeregistration watchDeregistration)</span> &#123;<br>    <span class="hljs-type">Packet</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Note that we do not generate the Xid for the packet yet. It is</span><br>    <span class="hljs-comment">// generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),</span><br>    <span class="hljs-comment">// where the packet is actually sent.</span><br>    packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packet</span>(h, r, request, response, watchRegistration);<br>    packet.cb = cb;<br>    packet.ctx = ctx;<br>    packet.clientPath = clientPath;<br>    packet.serverPath = serverPath;<br>    packet.watchDeregistration = watchDeregistration;<br>    <br>    <span class="hljs-comment">// The synchronized block here is for two purpose:</span><br>    <span class="hljs-comment">// 1. synchronize with the final cleanup() in SendThread.run() to avoid race</span><br>    <span class="hljs-comment">// 2. synchronized against each packet. So if a closeSession packet is added,</span><br>    <span class="hljs-comment">// later packet will be notified.</span><br>    <span class="hljs-keyword">synchronized</span> (outgoingQueue) &#123;<br>        <span class="hljs-keyword">if</span> (!state.isAlive() || closing) &#123;<br>            conLossPacket(packet);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// If the client is asking to close the session then</span><br>            <span class="hljs-comment">// mark as closing</span><br>            <span class="hljs-keyword">if</span> (h.getType() == OpCode.closeSession) &#123;<br>                closing = <span class="hljs-literal">true</span>;<br>            &#125;<br>            outgoingQueue.add(packet);<br>        &#125;<br>    &#125;<br>    sendThread.getClientCnxnSocket().packetAdded();<br>    <span class="hljs-keyword">return</span> packet;<br>&#125;<br></code></pre></td></tr></table></figure><p>outgoingQueue是一个LinkedBlockingDeque。正如注释所说：队列存储的是需要被发送的packets。</p><blockquote><p>/**These are the packets that need to be sent.*/ private finalLinkedBlockingDeque<Packet> outgoingQueue = newLinkedBlockingDeque&lt;&gt;();</p></blockquote><p>最后，ZooKeeper客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的SendThread 线程类中的 readResponse 方法接收服务端的回调，并在最后执行finishPacket（）方法将 Watch 注册到 ZKWatchManager 中：</p><p><strong>sendThread</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * This class services the outgoing request queue and generates the heart</span><br><span class="hljs-comment">  * beats. It also spawns the ReadThread.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br>     ... ...<br><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">readResponse</span><span class="hljs-params">(ByteBuffer incomingBuffer)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         <span class="hljs-type">ByteBufferInputStream</span> <span class="hljs-variable">bbis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferInputStream</span>(incomingBuffer);<br>         <span class="hljs-type">BinaryInputArchive</span> <span class="hljs-variable">bbia</span> <span class="hljs-operator">=</span> BinaryInputArchive.getArchive(bbis);<br>         <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">replyHdr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplyHeader</span>();<br><br>         replyHdr.deserialize(bbia, <span class="hljs-string">&quot;header&quot;</span>);<br>         <span class="hljs-keyword">switch</span> (replyHdr.getXid()) &#123;<br>         <span class="hljs-keyword">case</span> PING_XID:<br>             ... ...<br>             <span class="hljs-keyword">return</span>;<br>           <span class="hljs-keyword">case</span> AUTHPACKET_XID:<br>              ... ...     <br>           <span class="hljs-keyword">return</span>;<br>         <span class="hljs-keyword">case</span> NOTIFICATION_XID:<br>             ... ...<br>             <span class="hljs-keyword">return</span>;<br>         <span class="hljs-keyword">default</span>:<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>         ... ...<br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">          * Since requests are processed in order, we better get a response</span><br><span class="hljs-comment">          * to the first request!</span><br><span class="hljs-comment">          */</span><br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;<br>                 packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());<br>                 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Xid out of order. Got Xid &quot;</span> + replyHdr.getXid()<br>                                       + <span class="hljs-string">&quot; with err &quot;</span> + replyHdr.getErr()<br>                                       + <span class="hljs-string">&quot; expected Xid &quot;</span> + packet.requestHeader.getXid()<br>                                       + <span class="hljs-string">&quot; for a packet with details: &quot;</span> + packet);<br>             &#125;<br><br>             packet.replyHeader.setXid(replyHdr.getXid());<br>             packet.replyHeader.setErr(replyHdr.getErr());<br>             packet.replyHeader.setZxid(replyHdr.getZxid());<br>             <span class="hljs-keyword">if</span> (replyHdr.getZxid() &gt; <span class="hljs-number">0</span>) &#123;<br>                 lastZxid = replyHdr.getZxid();<br>             &#125;<br>             <span class="hljs-keyword">if</span> (packet.response != <span class="hljs-literal">null</span> &amp;&amp; replyHdr.getErr() == <span class="hljs-number">0</span>) &#123;<br>                 packet.response.deserialize(bbia, <span class="hljs-string">&quot;response&quot;</span>);<br>             &#125;<br><br>             LOG.debug(<span class="hljs-string">&quot;Reading reply session id: 0x&#123;&#125;, packet:: &#123;&#125;&quot;</span>, Long.toHexString(sessionId), packet);<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             finishPacket(packet);<br>         &#125;<br>     &#125;<br>     ... ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>finishPacket</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishPacket</span><span class="hljs-params">(Packet p)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> p.replyHeader.getErr();<br><br>        <span class="hljs-keyword">if</span> (p.watchRegistration != <span class="hljs-literal">null</span>) &#123;<br><br>            p.watchRegistration.register(err);<br><br>        &#125;<br>       ...<br>&#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-type">int</span> rc)</span> &#123;<br>            <span class="hljs-keyword">if</span> (shouldAddWatch(rc)) &#123;<br>                Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);<br>                <span class="hljs-keyword">synchronized</span> (watches) &#123;<br>                    Set&lt;Watcher&gt; watchers = watches.get(clientPath);<br>                    <span class="hljs-keyword">if</span> (watchers == <span class="hljs-literal">null</span>) &#123;<br>                        watchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>                        watches.put(clientPath, watchers);<br>                    &#125;<br>                    watchers.add(watcher);<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>客户端当发送一个带有 Watch事件的请求时，客户端首先会把该会话标记为带有 Watch监控的事件请求，之后通过 <code>DataWatchRegistration</code> 类来保存watcher 事件和节点的对应关系，然后将请求封装成一个 <code>Packet</code>对象，并添加到一个等待发送队列 <code>outgoingQueue</code> 中。</p><p>最后，ZooKeeper客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的<code>SendThread</code> 线程类中的 <code>readResponse</code>方法接收服务端的回调，并在最后执行 <code>finishPacket</code>方法将 Watch注册到 ZKWatchManager 中。</p><h2 id="服务端-watch-注册实现过程">4.2 服务端 Watch 注册实现过程</h2><p>Zookeeper 服务端处理 Watch 事件基本有 2 个过程：</p><ul><li>解析收到的请求是否带有 Watch 注册事件</li><li>将对应的 Watch 事件存储到 WatchManager</li></ul><p>当 ZooKeeper服务器接收到一个客户端请求后，首先会对请求进行解析，判断该请求是否包含Watch 事件。这在 ZooKeeper 底层是通过 <code>FinalRequestProcessor</code>类中的 processRequest 函数实现的。当 getDataRequest.getWatch() 值为 True时，表明该请求需要进行 Watch 监控注册。并通过<code>zks.getZKDatabase().getData</code> 函数将 Watch 事件注册到服务端的WatchManager 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(Request request)</span> &#123;<br>         ... ...<br>              <span class="hljs-keyword">case</span> OpCode.multiRead: &#123;<br>                lastOp = <span class="hljs-string">&quot;MLTR&quot;</span>;<br>                <span class="hljs-type">MultiOperationRecord</span> <span class="hljs-variable">multiReadRecord</span> <span class="hljs-operator">=</span> request.readRequestRecord(MultiOperationRecord::<span class="hljs-keyword">new</span>);<br>                rsp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultiResponse</span>();<br>                OpResult subResult;<br>                <span class="hljs-keyword">for</span> (Op readOp : multiReadRecord) &#123;<br>                ... ...<br>                 rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);<br>                            <span class="hljs-type">GetDataResponse</span> <span class="hljs-variable">gdr</span> <span class="hljs-operator">=</span> (GetDataResponse) rec;<br>                ... ...            <br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>handleGetDataRequest</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Record <span class="hljs-title function_">handleGetDataRequest</span><span class="hljs-params">(Record request, ServerCnxn cnxn, List&lt;Id&gt; authInfo)</span> <span class="hljs-keyword">throws</span> KeeperException, IOException &#123;<br>     <span class="hljs-type">GetDataRequest</span> <span class="hljs-variable">getDataRequest</span> <span class="hljs-operator">=</span> (GetDataRequest) request;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> getDataRequest.getPath();<br>     <span class="hljs-type">DataNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> zks.getZKDatabase().getNode(path);<br>     <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeeperException</span>.NoNodeException();<br>     &#125;<br>     zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, <span class="hljs-literal">null</span>);<br>     <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br>     <span class="hljs-type">byte</span>[] b = zks.getZKDatabase().getData(path, stat, getDataRequest.getWatch() ? cnxn : <span class="hljs-literal">null</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetDataResponse</span>(b, stat);<br> &#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>zks.getZKDatabase().getData</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getData(String path, Stat stat, Watcher watcher) <span class="hljs-keyword">throws</span> NoNodeException &#123;<br>    <span class="hljs-type">DataNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nodes.get(path);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoNodeException</span>();<br>    &#125;<br>    <span class="hljs-type">byte</span>[] data;<br>    <span class="hljs-keyword">synchronized</span> (n) &#123;<br>        n.copyStat(stat);<br>        <span class="hljs-keyword">if</span> (watcher != <span class="hljs-literal">null</span>) &#123;<br>            dataWatches.addWatch(path, watcher);<br>        &#125;<br>        data = n.data;<br>    &#125;<br>    updateReadStat(path, data == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : data.length);<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过 dataWatches.addWatch(path, watcher);将 Watch 事件注册到服务端的WatchManager 中</p></blockquote><h2 id="服务端-watch-事件的触发过程">4.3 服务端 Watch事件的触发过程</h2><p>在客户端和服务端都对 watch 注册完成后， ZooKeeper会在特定场景汇总中触发Watch 事件。</p><p>以 <strong>setData</strong>接口即"节点数据内容发生变更"事件为例。</p><ul><li><strong>DataTree-&gt;setData</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Stat <span class="hljs-title function_">setData</span><span class="hljs-params">(String path, <span class="hljs-type">byte</span> data[], ...)</span>&#123;<br><br>        <span class="hljs-type">Stat</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br><br>        <span class="hljs-type">DataNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nodes.get(path);<br><br>        ...<br><br>        dataWatches.triggerWatch(path, EventType.NodeDataChanged);<br><br>        <span class="hljs-keyword">return</span> s;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在 setData 方法内部执行完对节点数据的变更后，会调用WatchManager.triggerWatch 方法触发数据变更事件。</p><ul><li><strong>triggerWatch</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">WatcherOrBitSet <span class="hljs-title function_">triggerWatch</span><span class="hljs-params">(String path, EventType type, WatcherOrBitSet supress)</span> &#123;<br>       <span class="hljs-type">WatchedEvent</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedEvent</span>(type, KeeperState.SyncConnected, path);<br>       Set&lt;Watcher&gt; watchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>       <span class="hljs-type">PathParentIterator</span> <span class="hljs-variable">pathParentIterator</span> <span class="hljs-operator">=</span> getPathParentIterator(path);<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              <span class="hljs-keyword">for</span> (String localPath : pathParentIterator.asIterable()) &#123;<br>               Set&lt;Watcher&gt; thisWatchers = watchTable.get(localPath);<br>               <span class="hljs-keyword">if</span> (thisWatchers == <span class="hljs-literal">null</span> || thisWatchers.isEmpty()) &#123;<br>                   <span class="hljs-keyword">continue</span>;<br>               &#125;<br>               Iterator&lt;Watcher&gt; iterator = thisWatchers.iterator();<br>               <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                   <span class="hljs-type">Watcher</span> <span class="hljs-variable">watcher</span> <span class="hljs-operator">=</span> iterator.next();<br>                   <span class="hljs-type">WatcherMode</span> <span class="hljs-variable">watcherMode</span> <span class="hljs-operator">=</span> watcherModeManager.getWatcherMode(watcher, localPath);<br>                   ... ...<br>                   watchers.add(watcher);<span class="hljs-comment">//添加到定义的 Wathcers 集合中</span><br>               &#125;<br>                  <br>               <span class="hljs-keyword">if</span> (thisWatchers.isEmpty()) &#123;<br>                   watchTable.remove(localPath);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (watchers.isEmpty()) &#123;<br>           ... ...<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span> (Watcher w : watchers) &#123;<br>           <span class="hljs-keyword">if</span> (supress != <span class="hljs-literal">null</span> &amp;&amp; supress.contains(w)) &#123;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           w.process(e);<span class="hljs-comment">//调用 process 方法</span><br>       &#125;<br><br>       <span class="hljs-keyword">return</span> watchers;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>triggerWatch函数内部首先封装了一个具有<code>会话状态</code>、<code>事件类型</code>、<code>数据节点</code>3 种属性的 WatchedEvent 对象。之后查询该节点注册的 Watch事件，如果为空说明该节点没有注册过 Watch 事件。如果存在 Watch事件则添加到定义的 Wathcers 集合中，并在 WatchManager管理中删除。最后，通过调用 process 方法向客户端发送通知。</p><h2 id="客户端回调的处理过程">4.4 客户端回调的处理过程</h2><p>服务器端 Watch事件的触发过程后，客户端接收到通知后就会进行相应处理。</p><p>客户端使用 SendThread.readResponse()方法来统一处理服务端的相应。首先反序列化服务器发送请求头信息replyHdr.deserialize(bbia, "header")，并判断相属性字段 xid 的值为-1，表示该请求响应为通知类型。在处理通知类型时，首先将己收到的字节流反序列化转换成WatcherEvent 对象。接着判断客户端是否配置了 chrootPath 属性，如果为 True说明客户端配置了 chrootPath 属性。需要对接收到的节点路径进行 chrootPath处理。最后调用 eventThread.queueEvent( ）方法将接收到的事件交给EventThread 线程进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">readResponse</span><span class="hljs-params">(ByteBuffer incomingBuffer)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         <span class="hljs-type">ByteBufferInputStream</span> <span class="hljs-variable">bbis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferInputStream</span>(incomingBuffer);<br>         <span class="hljs-type">BinaryInputArchive</span> <span class="hljs-variable">bbia</span> <span class="hljs-operator">=</span> BinaryInputArchive.getArchive(bbis);<br>         <span class="hljs-type">ReplyHeader</span> <span class="hljs-variable">replyHdr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplyHeader</span>();<br><br>         replyHdr.deserialize(bbia, <span class="hljs-string">&quot;header&quot;</span>);<span class="hljs-comment">//反序列化服务器发送请求头信息</span><br>         <span class="hljs-keyword">switch</span> (replyHdr.getXid()) &#123;<br>         <span class="hljs-keyword">case</span> PING_XID:<br>           ... ...<br>           <span class="hljs-keyword">return</span>;<br>             <span class="hljs-keyword">case</span> NOTIFICATION_XID:<span class="hljs-comment">//-1:通知类型</span><br>             LOG.debug(<span class="hljs-string">&quot;Got notification session id: 0x&#123;&#125;&quot;</span>,Long.toHexString(sessionId));<br>             <span class="hljs-type">WatcherEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatcherEvent</span>();<br>             event.deserialize(bbia, <span class="hljs-string">&quot;response&quot;</span>);<br><br>             <span class="hljs-comment">// convert from a server path to a client path</span><br>             <span class="hljs-keyword">if</span> (chrootPath != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//判断客户端是否配置了 chrootPath 属性</span><br>                 <span class="hljs-type">String</span> <span class="hljs-variable">serverPath</span> <span class="hljs-operator">=</span> event.getPath();<br>                 <span class="hljs-type">String</span> <span class="hljs-variable">clientPath</span> <span class="hljs-operator">=</span> stripChroot(serverPath);<br>                 event.setPath(clientPath);<br>             &#125;<br><br>             <span class="hljs-type">WatchedEvent</span> <span class="hljs-variable">we</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedEvent</span>(event);<br>             LOG.debug(<span class="hljs-string">&quot;Got &#123;&#125; for session id 0x&#123;&#125;&quot;</span>, we, Long.toHexString(sessionId));<br>             eventThread.queueEvent(we);<span class="hljs-comment">//将接收到的事件交给 EventThread 线程进行处理</span><br>             <span class="hljs-keyword">return</span>;<br>         <span class="hljs-keyword">default</span>:<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>queueEvent</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queueEvent</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>       queueEvent(event, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queueEvent</span><span class="hljs-params">(WatchedEvent event, Set&lt;Watcher&gt; materializedWatchers)</span> &#123;<br>    <span class="hljs-keyword">if</span> (event.getType() == EventType.None &amp;&amp; sessionState == event.getState()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    sessionState = event.getState();<br>    <span class="hljs-keyword">final</span> Set&lt;Watcher&gt; watchers;<br>    <span class="hljs-keyword">if</span> (materializedWatchers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// materialize the watchers based on the event</span><br>        watchers = watchManager.materialize(event.getState(), event.getType(), event.getPath());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        watchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(materializedWatchers);<br>    &#125;<br>    <span class="hljs-type">WatcherSetEventPair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatcherSetEventPair</span>(watchers, event);<br>    <span class="hljs-comment">// queue the pair (watch set &amp; event) for later processing</span><br>    waitingEvents.add(pair);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>materialize</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Set&lt;Watcher&gt; <span class="hljs-title function_">materialize</span><span class="hljs-params">(</span><br><span class="hljs-params">    Watcher.Event.KeeperState state,</span><br><span class="hljs-params">    Watcher.Event.EventType type,</span><br><span class="hljs-params">    String clientPath</span><br><span class="hljs-params">)</span> &#123;<br>    <span class="hljs-keyword">final</span> Set&lt;Watcher&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> None:<br>        ... ...    <br>    <span class="hljs-keyword">case</span> NodeDataChanged:<br>    <span class="hljs-keyword">case</span> NodeCreated:<br>        <span class="hljs-keyword">synchronized</span> (dataWatches) &#123;<br>            addTo(dataWatches.remove(clientPath), result);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (existWatches) &#123;<br>            addTo(existWatches.remove(clientPath), result);<br>        &#125;<br>        addPersistentWatches(clientPath, type, result);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> NodeChildrenChanged:<br>            ... ...<br>    <span class="hljs-keyword">case</span> NodeDeleted:<br>            ... ...<br>    <span class="hljs-keyword">default</span>:<br>            ... ...<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(errorMsg);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会发现此处的Type就是前面的状态：<code>None</code>，<code>NodeDataChanged</code>，<code>NodeCreated</code>，<code>NodeChildrenChanged</code>，<code>NodeDeleted</code>。</p><p>EventThread.queueEvent() 方法内部的执行逻辑。其主要工作分为 2点：</p><ul><li><p>第 1 步按照通知的事件类型，从 ZKWatchManager 中查询注册过的客户端Watch 信息。客户端在查询到对应的 Watch 信息后，会将其从 ZKWatchManager的管理中删除。因此这里多注意，<code>客户端的 Watcher 机制是一次性的，触发后就会被删除</code>。</p></li><li><p>第 2 步获取到对应的 Watcher 信息后，将查询到的 Watcher 存储到waitingEvents 队列中，调用 <code>EventThread</code> 类中的 run方法会循环取出在 <code>waitingEvents</code> 队列中等待的 Watcher事件进行处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressFBWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        isRunning = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> waitingEvents.take();<br>            <span class="hljs-keyword">if</span> (event == eventOfDeath) &#123;<br>                wasKilled = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                processEvent(event);<span class="hljs-comment">//执行实现了 Watcher 接口的 process方法</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (wasKilled) &#123;<br>                <span class="hljs-keyword">synchronized</span> (waitingEvents) &#123;<br>                    <span class="hljs-keyword">if</span> (waitingEvents.isEmpty()) &#123;<br>                        isRunning = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Event thread exiting due to interruption&quot;</span>, e);<br>    &#125;<br><br>    LOG.info(<span class="hljs-string">&quot;EventThread shut down for session: 0x&#123;&#125;&quot;</span>, Long.toHexString(getSessionId()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>processEvent</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processEvent</span><span class="hljs-params">(Object event)</span> &#123;<br>  ... ...<br>  <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> WatcherSetEventPair) &#123;<br>      <span class="hljs-type">WatcherSetEventPair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> (WatcherSetEventPair) event;<br>      <span class="hljs-keyword">for</span> (Watcher watcher : pair.watchers) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              watcher.process(pair.event);<span class="hljs-comment">//执行方法</span><br>          &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>              LOG.error(<span class="hljs-string">&quot;Error while calling watcher &quot;</span>, t);<br>          &#125;<br>      &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> LocalCallback) &#123;<br>      ... ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>processEvent(event) 方法来最终执行实现了 Watcher 接口的process（）方法。</p><h1 id="总结">5. 总结</h1><p>客户端当发送一个带有 Watch事件的请求时，客户端首先会把该会话标记为带有 Watch监控的事件请求，之后通过 <code>DataWatchRegistration</code> 类来保存watcher 事件和节点的对应关系，然后将请求封装成一个 <code>Packet</code>对象，并添加到一个等待发送队列 <code>outgoingQueue</code> 中。</p><p>最后，ZooKeeper客户端就会向服务器端发送这个请求，完成请求发送后。调用负责处理服务器响应的<code>SendThread</code> 线程类中的 <code>readResponse</code>方法接收服务端的回调，并在最后执行 <code>finishPacket</code>方法将 Watch注册到 ZKWatchManager 中。</p><hr /><p>当 ZooKeeper服务器接收到一个客户端请求后，首先会对请求进行解析，判断该请求是否包含Watch 事件。这在 ZooKeeper 底层是通过 <code>FinalRequestProcessor</code>类中的 processRequest 函数实现的。当 getDataRequest.getWatch() 值为 True时，表明该请求需要进行 Watch 监控注册。并通过<code>zks.getZKDatabase().getData</code> 函数将 Watch 事件注册到服务端的WatchManager 中。</p><hr /><p>在特定的场合会触发事件，因此调用 WatchManager.triggerWatch方法触发事件。 triggerWatch函数内部首先封装了一个具有<code>会话状态</code>、<code>事件类型</code>、<code>数据节点</code>3 种属性的 WatchedEvent 对象。之后查询该节点注册的 Watch事件，如果为空说明该节点没有注册过 Watch 事件。如果存在 Watch事件则添加到定义的 Wathcers 集合中，并在 WatchManager管理中删除。最后，通过调用 process 方法向客户端发送通知。</p><hr /><p>服务器端 Watch事件的触发过程后，客户端接收到通知后就会进行相应处理。</p><p>客户端使用 SendThread.readResponse()方法来统一处理服务端的相应。首先反序列化服务器发送请求头信息replyHdr.deserialize(bbia, "header")，并判断相属性字段 xid 的值为<code>-1</code>，表示该请求响应为<code>通知类型</code>。在处理通知类型时，首先将己收到的字节流反序列化转换成<code>WatcherEvent</code> 对象。接着判断客户端是否配置了 chrootPath属性，如果为 True 说明客户端配置了 chrootPath属性。需要对接收到的节点路径进行 chrootPath 处理。最后调用eventThread.queueEvent( ）方法将接收到的事件交给 EventThread线程进行处理。其主要工作分为 2 点：</p><ul><li><p>第 1 步按照通知的事件类型，从 ZKWatchManager 中查询注册过的客户端Watch 信息。客户端在查询到对应的 Watch 信息后，会将其从 ZKWatchManager的管理中删除。因此这里多注意，<code>客户端的 Watcher 机制是一次性的，触发后就会被删除</code>。</p></li><li><p>第 2 步获取到对应的 Watcher 信息后，将查询到的 Watcher 存储到waitingEvents 队列中，调用 <code>EventThread</code> 类中的 run方法会循环取出在 <code>waitingEvents</code> 队列中等待的 Watcher事件进行处理。</p></li></ul><h1 id="使用场景">6.使用场景</h1><h2 id="订阅发布场景实现">订阅发布场景实现</h2><p>现在我们已经知道 Watch 事件在 ZooKeeper中的完整处理过程，接下来我们通过一个实际应用来加深我们对 ZooKeeper 中Watch 机制的理解。</p><p>提到 ZooKeeper的应用场景，你可能第一时间会想到最为典型的发布订阅功能。发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。ZooKeeper采用了两种模式结合的方式实现订阅发布功能。下面我们来分析一个具体案例：</p><p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper的发布订阅功能就能解决这个问题。</p><p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper数据节点中。如图中的 /confs/data_item1。服务器集群客户端对该节点添加Watch事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。而当该节点数据发生变化时，ZooKeeper服务器会发送 Watch事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl61INaAJeAEAAA8lZ8lpbE688.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对ZooKeeper服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。<strong>要注意一点是，我们提到Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch事件。</strong></p><h1 id="section">7. 🍪</h1><p>当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？</p><p>否定的，通过本课时对 ZooKeeper 内部实现机制的解析可以知道，Watch事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的Watch 事件。</p><h1 id="read-more">8.Read more</h1><p>:lollipop::<ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/02%20%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Watch%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E7%9F%A5.md">发布订阅模式：如何使用Watch 机制实现分布式通知</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper Leader选举</title>
    <link href="/2022/09/17/framework/zookeeper/2022-09-17_Zookeeper%20Leader%E9%80%89%E4%B8%BE/"/>
    <url>/2022/09/17/framework/zookeeper/2022-09-17_Zookeeper%20Leader%E9%80%89%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper-leader选举">Zookeeper Leader选举</h1><p>Leader 服务器的作用是管理 ZooKeeper集群中的其他服务器。因此，如果是单独一台服务器，不构成集群规模。在ZooKeeper 服务的运行中不会选举 Leader 服务器，也不会作为 Leader服务器运行。</p><p>在前面，我们说过在 ZooKeeper 集群中将服务器分成 <code>Leader</code>、<code>Follow</code> 、<code>Observer</code>三种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p><ul><li>Leader角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者。</li><li>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个Follow 服务器作为新的 Leader 服务器。</li><li>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器。</li></ul><p>本文主要对"<strong>Leader 服务器是如何产生的</strong>"分析。</p><h1 id="leader-服务器的选举原理">1.Leader 服务器的选举原理</h1><p>一个 ZooKeeper服务要想满足集群方式运行，至少需要三台服务器。本课时我们就以三台服务器组成的ZooKeeper 集群为例，介绍一下 Leader 服务器选举的内部过程和底层实现。</p><h2 id="服务启动时的-leader-选举">1.1 服务启动时的 Leader 选举</h2><p>Leader 服务器的选举操作主要发生在两种情况下。</p><ul><li><p>第一种就是 ZooKeeper 集群服务启动的时候</p></li><li><p>第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时</p></li></ul><p>这时 ZooKeeper 集群需要选举出新的 Leader 服务器。我们先来介绍在ZooKeeper 集群服务最初启动的时候，Leader 服务器是如何选举的。</p><p>在 ZooKeeper 集群启动时，需要在集群中的服务器之间确定一台 Leader服务器。当 ZooKeeper集群中的三台服务器启动之后，首先会进行通信检查，如果集群中的服务器之间能够进行通信。集群中的三台机器开始尝试寻找集群中的Leader 服务器并进行数据同步等操作。如何这时没有搜索到 Leader服务器，说明集群中不存在 Leader 服务器。这时 ZooKeeper 集群开始发起Leader 服务器选举。在整个 ZooKeeper 集群中 Leader选举主要可以分为三大步骤分别是：<code>发起投票</code>、<code>接收投票</code>、<code>统计投票</code>。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308162822843.png"alt="image-20230308162822843" /><figcaption aria-hidden="true">image-20230308162822843</figcaption></figure><h3 id="发起投票">1.1.1 发起投票</h3><p>我们先来看一下发起投票的流程，在 ZooKeeper服务器集群初始化启动的时候，<code>集群中的每一台服务器都会将自己作为 Leader 服务器进行投票</code>。<strong>也就是每次投票时，发送的服务器的myid（服务器标识符）和 ZXID(集群投票信息标识符)等选票信息字段都指向本机服务器。</strong>而一个投票信息就是通过这两个字段组成的。以集群中三个服务器<code>Serverhost1</code>、<code>Serverhost2</code>、<code>Serverhost3</code>为例。</p><p>因为是初始化阶段，每一台服务器都会将自己作为leader服务器来投票，所以三个服务器的投票内容分别是：Severhost1的投票是（1，0）、Serverhost2 服务器的投票是（2，0）、Serverhost3服务器的投票是（3，0）。</p><blockquote><p>myid:server都会有一个用于惟一标识自己的id</p><p>zxid:事务id,初始为0</p></blockquote><h3 id="接收投票">1.1.2 接收投票</h3><p>集群中各个服务器在发起投票的同时，也通过网络接收来自集群中其他服务器的投票信息。在接收到网络中的投票信息后，服务器内部首先会判断该条投票信息的有效性。检查该条投票信息的时效性，是否是本轮最新的投票，并检查该条投票信息是否是处于LOOKING 状态的服务器发出的。</p><h3 id="处理投票">1.1.3 处理投票</h3><p>在接收到投票后，ZooKeeper集群就该处理和统计投票结果了。在接收到来自其它服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，pk的规则如下：</p><ul><li>优先检查ZXID，ZXID 数值比较大的投票信息优先作为 Leader 服务器。</li><li>如果每个投票信息中的 ZXID 相同，就会接着比对投票信息中的 myid信息字段，选举出 myid 较大的服务器作为 Leader 服务器。</li></ul><p>拿上面列举的三个服务器组成的集群例子来说，对于 Serverhost1：</p><p>他自己的投票信息是（1，0），该服务器接收到的 Serverhost2服务器的投票信息是（2，0）。在 ZooKeeper集群服务运行的过程中，首先会对比 ZXID，发现结果相同之后，对比 myid，发现Serverhost2 服务器的 myid比较大，于是更新自己的投票信息为（2，0），并重新向 ZooKeeper集群中的服务器发送新的投票信息。而 Serverhost2服务器则保留自身的投票信息，不需要更新自己的投票信息，只是再一次向集群中的所有机器发出上一次投票信息即可。</p><h3 id="统计投票">1.1.4 统计投票</h3><p>每轮投票过后，ZooKeeper服务都会统计集群中服务器的投票结果，<code>判断是否有过半数的机器投出一样的信息</code>。如果存在过半数投票信息指向的服务器，那么该台服务器就被选举为Leader 服务器。比如上面我们举的例子中，ZooKeeper 集群会选举 Severhost2服务器作为 Leader 服务器。</p><h3 id="改变服务器状态">1.1.5 <strong>改变服务器状态</strong></h3><p>一旦确定了leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为Following，并且会与：Leader进行数据同步。如果是Leader，就变更为Leading。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308164521147.png"alt="image-20230308164521147" /><figcaption aria-hidden="true">image-20230308164521147</figcaption></figure><h2 id="服务器运行时期的leader选举">1.2<strong>服务器运行时期的Leader选举</strong></h2><p>除了ZooKeeper 集群启动时 Leader 服务器的选举方法以外，还存在ZooKeeper 集群服务的运行过程中，Leader 服务器进行选举。</p><p>在集群中，一旦Leader确定后，集群中的角色一般不会再发生变化，即使是非Leader集群挂了或者有新的服务器加入也不会有影响，但是<code>当Leader发生宕机了。那么整个集群则无法对外提供服务。则会进入新的Leader选举</code>。ZooKeeper集群在重新选举 Leader时也经过了四个过程(<strong><em>也可以叫5个过程：统计投票包含处理投票</em></strong>)，分别是<code>变更服务器状态</code>、<code>发起投票</code>、<code>接收投票</code>、<code>统计投票</code>。其中，与初始化启动时Leader服务器的选举过程相比，变更状态和发起投票这两个阶段的实现是不同的。下面我们来分别看看这两个阶段。</p><p>现在假设有3台服务器：Severhost1、Severhost2 、Severhost3，当前Leader为Severhost2 且已经挂掉。此时开始Leader选举。</p><h3 id="变更状态">1.2.1 变更状态</h3><p>当 Leader 服务器崩溃后 ，ZooKeeper集群中的其他服务器会首先将自身的状态信息变为 LOOKING状态，该状态表示服务器已经做好选举新 Leader 服务器的准备了，这之后整个ZooKeeper 集群开始进入选举新的 Leader 服务器过程。</p><h3 id="发起投票-1">1.2.2 发起投票</h3><p>ZooKeeper 集群重新选举 Leader服务器的过程中发起投票的过程与初始化启动时发起投票的过程基本相同。首先每个集群中的服务器都会投票给自己，将投票信息中的Zxid 和 myid 分别指向本机服务器。</p><p>在这个过程中，需要生成投票信息(myid,zxid)，因为是运行期间，因此每个服务器上的zxid可能不同，我们假定Severhost1的zxid为123，而Severhost3的zxid为122.在第一轮投票中，Severhost1和Severhost3都会投给自己，即分别产生投票(1, 123)和(3,122)，然后各自将这个投票发给集群中的所有机器。</p><h1 id="底层实现">2.底层实现</h1><p>进行 Leader 头节点的选举操作。而在 ZooKeeper 中提供了三种 Leader选举算法，分别是 <strong>LeaderElection、AuthFastLeaderElection、FastLeaderElection</strong>。在后面的版本中，只支持<code>快速选举</code>这一种算法。</p><p>在代码层面的实现中，QuorumCnxManager 作为核心的实现类，用来管理Leader 服务器与 Follow 服务器的 TCP 通信，以及消息的接收与发送等功能。在QuorumCnxManager 中，主要定义了 ConcurrentHashMap&lt;Long,SendWorker&gt; 类型的 senderWorkerMap数据字段，用来管理每一个通信的服务器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuorumCnxManager</span> &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;<span class="hljs-type">Long</span>, <span class="hljs-type">SendWorker</span>&gt; senderWorkerMap;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;<span class="hljs-type">Long</span>, <span class="hljs-type">ArrayBlockingQueue</span>&lt;<span class="hljs-type">ByteBuffer</span>&gt;&gt; queueSendMap;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;<span class="hljs-type">Long</span>, <span class="hljs-type">ByteBuffer</span>&gt; lastMessageSent;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而在 QuorumCnxManager 类的内部，定义了 RecvWorker内部类。该类继承了一个 ZooKeeperThread类的多线程类。主要负责消息接收。在 ZooKeeper的实现中，为每一个集群中的通信服务器都分配一个RecvWorker，负责接收来自其他服务器发送的信息。在 RecvWorker 的 run函数中，不断通过 queueSendMap 队列读取信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br>  Long sid;<br>  Socket sock;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  DataInputStream din;<br>  <span class="hljs-keyword">final</span> SendWorker sw;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  threadCnt.incrementAndGet();<br>  <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> din.readInt();<br>    <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">0</span> || length &gt; PACKETMAXSIZE) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<br>                <span class="hljs-string">&quot;Received packet with invalid packet: &quot;</span> + length);<br>    &#125;<br>    <span class="hljs-type">byte</span>[] msgArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    din.readFully(msgArray, <span class="hljs-number">0</span>, length);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msgArray);<br>    addToRecvQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(message.duplicate(), sid));<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了接收信息的功能外，QuorumCnxManager 内还定义了一个 SendWorker内部类用来向集群中的其他服务器发送投票信息。如下面的代码所示。在SendWorker 类中，不会立刻将投票信息发送到 ZooKeeper集群中，而是将投票信息首先插入到 pollSendQueue 队列，之后通过 send函数进行发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br><br>  Long sid;<br><br>  Socket sock;<br>  RecvWorker recvWorker;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  DataOutputStream dout;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);<br>        <span class="hljs-keyword">if</span> (bq != <span class="hljs-literal">null</span>) &#123;<br>            b = pollSendQueue(bq, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.error(<span class="hljs-string">&quot;No queue of incoming messages for &quot;</span> + <span class="hljs-string">&quot;server &quot;</span> + sid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b != <span class="hljs-literal">null</span>)&#123;<br>            lastMessageSent.put(sid, b);<br>            send(b);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>        LOG.warn(<span class="hljs-string">&quot;Interrupted while waiting for message on queue&quot;</span>,<br><br>                e);<br>    &#125;<br>   &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了投票信息的发送与接收后，接下来我们就来看看如何处理投票结果。在ZooKeeper 的底层，是通过 FastLeaderElection类实现的。如下面的代码所示，在 FastLeaderElection的内部，定义了最大通信间隔 maxNotificationInterval、服务器等待时间finalizeWait 等属性配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastLeaderElection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Election</span> &#123;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxNotificationInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">60000</span>;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">IGNOREVALUE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span><br><br>  QuorumCnxManager manager;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 ZooKeeper 底层通过 getVote函数来设置本机的投票内容，如下图面的代码所示，在 getVote 中通过proposedLeader 服务器信息、proposedZxid 服务器 ZXID、proposedEpoch投票轮次等信息封装投票信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> Vote <span class="hljs-title function_">getVote</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(proposedLeader, proposedZxid, proposedEpoch);<br><br> &#125;<br></code></pre></td></tr></table></figure><p>在完成投票信息的封装以及投票信息的接收和发送后。一个 ZooKeeper集群中，Leader 服务器选举底层实现的关键步骤就已经介绍完了。 Leader节点的底层实现过程的逻辑相对来说比较简单，基本分为封装投票信息、发送投票、接收投票等。</p><h1 id="section">3.🍪</h1><p>崩溃的 Leader 服务器是否会参与本次投票，以及是否能被重新选举为 Leader服务器?</p><blockquote><p>这主要取决于在选举过程中旧的 Leader服务器的运行状态。如果该服务器可以正常运行且可以和集群中其他服务器通信，那么该服务器也会参与新的Leader 服务器的选举，在满足条件的情况下该台服务器也会再次被选举为新的Leader 服务器。</p></blockquote><h1 id="read-more">4.Read more</h1><p>:lollipop:: <ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/15%20ZooKeeper%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%89%E4%B8%AD%20Leader%20%E7%9A%84%EF%BC%9F.md">ZooKeeper究竟是怎么选中 Leader 的？</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACL权限控制</title>
    <link href="/2022/09/14/framework/zookeeper/2022-09-14_ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/09/14/framework/zookeeper/2022-09-14_ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="acl-权限控制">1. ACL 权限控制</h1><p>ZooKeeper 基础知识基本分为三大模块：</p><ul><li>数据模型</li><li>Watch 监控</li><li>ACL 权限控制</li></ul><p>在前面已经讲了<code>数据模型</code>与<code>Watch 监控</code>，现在来讲一下ACL权限控制。</p><p>权限控制相信你一定很熟悉。比如 Linux系统将对文件的使用者分为三种身份，即User、Group、Others。使用者对文件拥有读（read）写（write）以及执行（execute）3种方式的控制权。这种权限控制方式相对比较粗糙，在复杂的授权场景下往往并不适用。比如下边一个应用场景。</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl67twGANQ9kAABTpMHtYI0138.png" /></p><p>上图如果使用 Linux 权限来设计，则：</p><p>首先作为技术组长使用 User身份，具有读、写、执行权限。项目组其他成员使用 Group身份，具有读写权限，其他项目组的人员则没有任何权限。这样就实现了满足要求的权限设定了。</p><p>但是针对于Zookeeper来说。Zookeeper有临时节点的特性。比如现在新加入一个实习生，他只有熟悉项目的权限，却没有修改项目的能力。则此时使用的权限规则就无法满足要求。</p><p><strong>ZooKeeper 中的 ACl就能应对这种复杂的权限应用场景</strong></p><h1 id="acl的使用">2.ACL的使用</h1><p>ACL 权限设置通常可以分为 3部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。最终组成一条例如<code>scheme:id:permission</code>格式的ACL 请求信息。</p><h2 id="权限模式scheme">2.1 权限模式（Scheme）</h2><p>权限模式就是用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper的权限验证方式大体分为两种类型:</p><ul><li><p><strong>范围验证</strong></p><p>ZooKeeper 可以针对一个 IP 或者一段 IP地址授予某种权限。比如我们可以让一个 IP地址为“ip：192.168.1.10”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.1.10/22”给<strong>一段IP 地址的机器赋权</strong>。</p></li><li><p><strong>口令验证</strong></p><p>也可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。</p><p>在 ZooKeeper 中这种验证方式是 Digest认证，我们知道通过网络传输相对来说并不安全，所以“绝不通过明文在网络发送密码”也是程序设计中很重要的原则之一，而Digest这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper服务端会对密码 部分使用 SHA-1 和 BASE64算法进行加密，以保证安全性。另一种权限模式 Super 可以认为是一种特殊的Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper上的任意数据节点进行任意操作。下面这段代码给出了 Digest模式下客户端的调用方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">//创建节点<br><br>create /digest_node1<br><br>//设置digest权限验证<br><br>setAcl /digest_node1 digest:用户名:<span class="hljs-built_in">base64</span>格式密码:rwadc <br><br>//查询节点Acl权限<br><br>getAcl /digest_node1 <br><br>//授权操作<br><br>addauth digest user:passwd<br></code></pre></td></tr></table></figure><p>最后一种授权模式是 world模式，其实这种授权模式对应于系统中的所有用户，本质上起不到任何作用。设置了world 权限模式系统中的所有用户操作都可以不进行权限验证。</p></li></ul><h2 id="授权对象id">2.2 授权对象（ID）</h2><p>接下来我们再看一下授权对象部分，其实这个很好理解，所谓的授权对象就是说我们要把权限赋予谁，而对应于4 种不同的权限模式来说，如果我们选择采用 IP方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或Super 方式，则对应于一个用户名。如果是 World模式，是授权系统中所有的用户。</p><h2 id="权限信息permission">2.3 权限信息（Permission）</h2><p>权限就是指我们可以在数据节点上执行的操作种类，如下图所示：在ZooKeeper 中已经定义好的权限有 5 种：</p><ul><li>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li><li>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</li><li>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</li><li>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li><li>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行ACL 权限设置。</li></ul><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl67tw2AbgggAACW3WWz4D4066.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong><em>Mark:</em></strong></p><p><strong>每个节点都有维护自身的 ACL权限数据，即使是该节点的子节点也是有自己的 ACL权限而不是直接继承其父节点的权限</strong>。如下中“172.168.11.1”服务器有“/Config”节点的读取权限，但是没有其子节的“/Config/dataBase_Config1”权限。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl67txWALBicAABysKoJmFg484.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="权限扩展">2.4 权限扩展</h2><p>虽然 ZooKeeper自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p><p>官方文档中对这种机制的定义是<code>Pluggable ZooKeeper Authenication</code>，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。要想实现自定义的权限控制机制，最核心的一点是实现ZooKeeper 提供的权限控制器接口 <code>AuthenticationProvider</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AuthenticationProvider</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The String used to represent this provider. This will correspond to the</span><br><span class="hljs-comment">     * scheme field of an Id.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the scheme of this provider.</span><br><span class="hljs-comment">     * 用于表示此提供程序的字符串。这将对应于Id的scheme字段。</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">getScheme</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called when a client passes authentication data for this</span><br><span class="hljs-comment">     * scheme. The authData is directly from the authentication packet. The</span><br><span class="hljs-comment">     * implementor may attach new ids to the authInfo field of cnxn or may use</span><br><span class="hljs-comment">     * cnxn to send packets back to the client.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cnxn</span><br><span class="hljs-comment">     *                the cnxn that received the authentication information.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authData</span><br><span class="hljs-comment">     *                the authentication data received.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> TODO</span><br><span class="hljs-comment">     * 当客户端传递此方案的身份验证数据时，将调用此方法。authData直接来自认证报文。实现者可以将新的id附加到cnxn的authInfo字段，也可以使用cnxn将包发送回客户端</span><br><span class="hljs-comment">     */</span><br>    KeeperException.Code <span class="hljs-title function_">handleAuthentication</span><span class="hljs-params">(ServerCnxn cnxn, <span class="hljs-type">byte</span>[] authData)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called when admin server command passes authentication data for this</span><br><span class="hljs-comment">     * scheme.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     *                the request that contains the authentication information.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authData</span><br><span class="hljs-comment">     *                the authentication data received.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Ids</span><br><span class="hljs-comment">     *                the list of Id. Empty list means not authenticated</span><br><span class="hljs-comment">     * 当管理服务器命令为此方案传递身份验证数据时，将调用此方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> List&lt;Id&gt; <span class="hljs-title function_">handleAuthentication</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-type">byte</span>[] authData)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called to see if the given id matches the given id</span><br><span class="hljs-comment">     * expression in the ACL. This allows schemes to use application specific</span><br><span class="hljs-comment">     * wild cards.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     *                the id to check.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> aclExpr</span><br><span class="hljs-comment">     *                the expression to match ids against.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if the id can be matched by the expression.</span><br><span class="hljs-comment">     * 调用此方法以查看给定id是否与ACL中的给定id表达式匹配。这允许方案使用特定于应用程序的通配符。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String id, String aclExpr)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is used to check if the authentication done by this provider</span><br><span class="hljs-comment">     * should be used to identify the creator of a node. Some ids such as hosts</span><br><span class="hljs-comment">     * and ip addresses are rather transient and in general don&#x27;t really</span><br><span class="hljs-comment">     * identify a client even though sometimes they do.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if this provider identifies creators.</span><br><span class="hljs-comment">     * 此方法用于检查此提供程序完成的身份验证是否应用于标识节点的创建者。一些id，如主机和ip地址，是相当短暂的，通常不能真正识别客户端，即使有时它们可以。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAuthenticated</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Validates the syntax of an id.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     *                the id to validate.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if id is well formed.</span><br><span class="hljs-comment">     * 验证id的语法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;param&gt;id&lt;/param&gt; represents the authentication info which is set in server connection.</span><br><span class="hljs-comment">     * id may contain both user name as well as password.</span><br><span class="hljs-comment">     * This method should be implemented to extract the user name.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id authentication info set by client.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> String user name</span><br><span class="hljs-comment">     * 表示在服务器连接中设置的身份验证信息。Id可能包含用户名和密码。应该实现这个方法来提取用户名。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-comment">// Most of the authentication providers id contains only user name.</span><br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现了自定义权限后，如何才能让 ZooKeeper服务端使用自定义的权限验证方式呢？接下来就需要将自定义的权限控制注册到ZooKeeper 服务器中，而注册的方式通常有两种。</p><p>第一种是通过设置系统属性来注册自定义的权限控制器：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Dzookeeper.authProvider.x</span>=<span class="hljs-string">CustomAuthenticationProvider</span><br></code></pre></td></tr></table></figure><p>另一种是在配置文件 zoo.cfg 中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">authProvider.x</span>=<span class="hljs-string">CustomAuthenticationProvider</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义ACL此处不会详细讲解，感兴趣的盆友可以自己查询相关资料。</p></blockquote><h1 id="acl-内部实现原理">3. ACL 内部实现原理</h1><h2 id="客户端处理过程">3.1 客户端处理过程</h2><p>以节点授权 addAuth 接口为例，首先客户端通过 ClientCnxn 类中的addAuthInfo 方法向服务端发送 ACL 权限信息变更请求，该方法首先将 scheme和 auth 封装成 AuthPacket 类，并通过 RequestHeader方法表示该请求是权限操作请求，最后将这些数据统一封装到 packet中，并添加到 outgoingQueue 队列中发送给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAuthInfo</span><span class="hljs-params">(String scheme, <span class="hljs-type">byte</span>[] auth)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!state.isAlive()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    authInfo.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthData</span>(scheme, auth));<br>    queuePacket(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeader</span>(ClientCnxn.AUTHPACKET_XID, OpCode.auth),<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthPacket</span>(<span class="hljs-number">0</span>, scheme, auth),<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>queuePacket( RequestHeader h, ReplyHeader r, Record request, Recordresponse, AsyncCallback cb, String clientPath, String serverPath, Objectctx, WatchRegistration watchRegistration, WatchDeregistrationwatchDeregistration)</p><p>这个方法我们在讲Watcher机制的时候讲过，就是讲数据封装到packet中，然后添加到outgoingQueue队列中发送给服务端。</p></blockquote><h2 id="服务端实现过程">3.2 服务端实现过程</h2><p>相比于客户端的处理过程，服务器端对 ACL内部实现就比较复杂，当节点授权请求发送到服务端后，在服务器的处理中首先调用readRequest（）方法作为服务器处理的入口，其内部只是调用 processPacket方法。</p><p><strong>NIOServerCnxn:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">RequestHeader</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeader</span>();<br>        ByteBufferInputStream.byteBuffer2Record(incomingBuffer, h);<br>        <span class="hljs-type">RequestRecord</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestRecord.fromBytes(incomingBuffer.slice());<br>        zkServer.processPacket(<span class="hljs-built_in">this</span>, h, request);<br>    &#125;<br></code></pre></td></tr></table></figure><p>而在 processPacket 方法的内部，首先反序列化客户端的请求信息并封装到AuthPacket 对象中。之后通过 getServerProvider 方法根据不同的 scheme判断具体的实现类。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> processPacket(ServerCnxn cnxn, RequestHeader h, RequestRecord request) throws IOException &#123;<br><span class="hljs-params">...</span> <span class="hljs-params">...</span><br>  <span class="hljs-keyword">if</span> (h.getType() == OpCode.auth) &#123;<br>           <span class="hljs-params">...</span> <span class="hljs-params">...</span><br>           AuthPacket authPacket = request.readRecord(AuthPacket<span class="hljs-type">::new</span>);<br>           <span class="hljs-built_in">String</span> scheme = authPacket.getScheme();<br>           ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);<br>           Code authReturn = KeeperException.Code.AUTHFAILED;<br>           <span class="hljs-keyword">if</span> (ap != <span class="hljs-built_in">null</span>) &#123;<br>                   authReturn = ap.handleAuthentication(<br>                       <span class="hljs-literal">new</span> ServerAuthenticationProvider.ServerObjs(this, cnxn),<br>                       authPacket.getAuth());<br>                 <span class="hljs-params">...</span> <span class="hljs-params">...</span><br>               &#125;<br>        &#125;<br>    <span class="hljs-params">...</span> <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>authReturn == KeeperException.Code.OK表明权限验证成功。</p></blockquote><h2 id="digest-模式验证">3.3 Digest 模式验证</h2><p>这里我们使用 Digest 模式为例，因此该实现类是DigestAuthenticationProvider 。之后调用其<code>handleAuthentication()</code> 方法进行权限验证。如果返KeeperException.Code.OK则表示该请求已经通过了权限验证，如果返回的状态是其他或者抛出异常则表示权限验证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> KeeperException.Code <span class="hljs-title function_">handleAuthentication</span><span class="hljs-params">(ServerCnxn cnxn, <span class="hljs-type">byte</span>[] authData)</span> &#123;<br>    <span class="hljs-keyword">final</span> List&lt;Id&gt; ids = handleAuthentication(authData);<br>    <span class="hljs-keyword">if</span> (ids.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> KeeperException.Code.AUTHFAILED;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Id id : ids) &#123;<br>        cnxn.addAuthInfo(id);<br>    &#125;<br>    <span class="hljs-keyword">return</span> KeeperException.Code.OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>handleAuthentication</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> List&lt;Id&gt; handleAuthentication(<span class="hljs-keyword">final</span> byte[] authData) &#123;<br>     <span class="hljs-keyword">final</span> List&lt;Id&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> id = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(authData);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> digest = generateDigest(id);<br>         <span class="hljs-keyword">if</span> (digest.equals(superDigest)) &#123;<br>             ids.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Id</span>(<span class="hljs-string">&quot;super&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>         &#125;<br>         ids.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Id</span>(getScheme(), digest));<br>     &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> NoSuchAlgorithmException e) &#123;<br>         LOG.error(<span class="hljs-string">&quot;Missing algorithm&quot;</span>, e);<br>     &#125;<br>     <span class="hljs-keyword">return</span> Collections.unmodifiableList(ids);<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="addauthinfo">4.addAuthInfo</h1><p>重点讲解一下 addAuthInfo函数，其作用是<code>将解析到的权限信息存储到 ZooKeeper 服务器的内存中</code>，该信息在整个会话存活期间一直会保存在服务器上，如果会话关闭，该信息则会被删，<strong>这个特性很像我们之前学过的数据节点中的临时节点</strong>。</p><p>经过上面的步骤，服务器已经将客户端 ACL请求解析并将对应的会话权限信息存储在服务器上，下面我们再看一下服务器是如何进行权限验证的。</p><p>首先，在处理一次权限请求时，先通过 PrepRequestProcessor 中的 checkAcl函数检查对应的请求权限，</p><ul><li><p>如果该节点没有任何权限设置则直接返回</p></li><li><p>如果该节点有权限设置则循环遍历节点信息进行检查</p></li></ul><p>如果具有相应的权限则直接返回表明权限认证成功，否则最后抛出NoAuthException 异常中断操作表明权限认证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkACL</span><span class="hljs-params">(...)</span>&#123;<br><br>  ...<br><br>  <span class="hljs-keyword">for</span> (ACL a : acl) &#123;<br><br>    <span class="hljs-keyword">if</span>(authId.getScheme().equals(id.getScheme()..)&#123;<br><br>      <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeeperException</span>.NoAuthException();<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">5.总结</h1><p>到目前为止我们对 ACL 权限在 ZooKeeper服务器客户端和服务端的底层实现过程进行了深度的分析。总体来说，客户端在ACL权限请求发送过程的步骤比较简单：<code>首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。</code>本课时的例子采用了授权接口addAuth 而没有采用权限设置接口setAcl，是因为权限设置接口相对简单，其核心功能点已经包括在授权接口实现中。而在授权接口中，<strong>值得注意的是会话的授权信息存储在ZooKeeper服务端的内存中，如果客户端会话关闭，授权信息会被删除。下次连接服务器后，需要重新调用授权接口进行授权。</strong></p><h1 id="section">6.🍪</h1><p>如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。对其创建的节点要想进行修改应该怎么做呢？</p><blockquote><p>我们可以通过“super模式”即超级管理员的方式删除该节点或变更该节点的权限验证方式。正因为“super模式”有如此大的权限，我们在平时使用时也应该更加谨慎。</p></blockquote><h1 id="read-more">8.Read more</h1><p>:lollipop::<ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/03%20ACL%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%9C%AA%E7%BB%8F%E6%8E%88%E6%9D%83%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9F.md">ACL权限控制</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper启动流程</title>
    <link href="/2022/09/12/framework/zookeeper/2022-09-12_zookeeper%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/09/12/framework/zookeeper/2022-09-12_zookeeper%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器初始化到对外提供服务">服务器初始化到对外提供服务</h1><p>前面讲解了Zookeeper的基础知识，其实还涉及到Zookeeper-jute序列化，网络通信协议还没有讲。现在来讲讲ZooKeeper 中的启动与服务的初始化过程，来学习 ZooKeeper服务端相关的处理知识</p><h1 id="单机版">2.单机版</h1><p>我们在启动Zookeeper的时候，都会将<code>zoo_sample.cfg</code>文件复制重新命名为<code>zoo.cfg</code>，如下：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308140602652.png"alt="image-20230308140602652" /><figcaption aria-hidden="true">image-20230308140602652</figcaption></figure><h2 id="启动准备实现">2.1 启动准备实现</h2><p>ZooKeeper服务的初始化之前，首先要对配置文件等信息进行解析和载入。也就是在真正开始服务的初始化之前需要对服务的相关参数进行准备，而ZooKeeper服务的准备阶段大体上可分为<code>启动程序入口</code>、<code>zoo.cfg 配置文件解析</code>、<code>创建历史文件清理器</code>等，如下图所示：</p><p><img src="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308140659021.png" alt="image-20230308140659021" style="zoom:67%;" /></p><p><code>QuorumPeerMain</code> 类是 ZooKeeper 服务的启动接口，可以理解为Java 中的 main 函数。 通常我们在控制台启动 ZooKeeper 服务的时候，输入zkServer.cm 或 zkServer.sh 命令就是用来启动这个 Java类的。如下代码所示，QuorumPeerMain 类函数只有一个 initializeAndRun方法，是作用为所有 ZooKeeper 服务启动逻辑的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * When the main() method of this class is used to start the program, the first</span><br><span class="hljs-comment"> * argument is used as a path to the config file, which will be used to obtain</span><br><span class="hljs-comment"> * configuration information. This file is a Properties file, so keys and</span><br><span class="hljs-comment"> * values are separated by equals (=) and the key/value pairs are separated</span><br><span class="hljs-comment"> * by new lines. The following is a general summary of keys used in the</span><br><span class="hljs-comment"> * configuration file. For full details on this see the documentation in</span><br><span class="hljs-comment"> * docs/index.html</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *当使用该类的main()方法启动程序时，第一个参数将用作配置文件的路径，该配置文件将用于获取配置信息。该文件是一个   Properties文件，因此键和值用等号(=)分隔，键值对用新行分隔。下面是配置文件中使用的密钥的一般摘要。有关这方   面的详细信息，请参阅docsindex.html中的文档</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuorumPeerMain</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(QuorumPeerMain.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Usage: QuorumPeerMain configfile&quot;</span>;<br><br>    <span class="hljs-keyword">protected</span> QuorumPeer quorumPeer;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * To start the replicated server specify the configuration file name on</span><br><span class="hljs-comment">     * the command line.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args path to the configfile</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">QuorumPeerMain</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuorumPeerMain</span>();<br>        ... ...<br>        main.initializeAndRun(args);<br>        ... ... <br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="解析配置文件">2.2 解析配置文件</h2><p>上文写到<code>当使用该类的main()方法启动程序时，第一个参数将用作配置文件的路径，该配置文件将用于获取配置信息</code>，因此在ZooKeeper 启动过程中，首先要做的事情就是解析配置文件 zoo.cfg。</p><blockquote><p>zoo.cfg是服务端的配置文件，在这个文件中我们可以配置数据目录、端口号等信息。</p></blockquote><h2 id="创建文件清理器">2.3 创建文件清理器</h2><p>文件清理器在我们日常的使用中非常重要，我们都知道面对大流量的网络访问，ZooKeeper会因此产生海量的数据，如果磁盘数据过多或者磁盘空间不足，则会导致ZooKeeper服务器不能正常运行，进而影响整个分布式系统。所以面对这种问题，ZooKeeper采用了 <code>DatadirCleanupManager</code>类作为历史文件的清理工具类。</p><p>在 3.4.0 版本后的 ZooKeeper中更是增加了自动清理历史数据的功能以尽量避免磁盘空间的浪费(我是用的版本为3.9.0-SNAPSHOT)。</p><p>如下代码所示，DatadirCleanupManager 类有 5 个属性，其中 snapDir 和dataLogDir分别表示数据快照地址以及日志数据的存放地址。而我们在日常工作中可以通过在zoo.cfg 文件中配置 autopurge.snapRetainCount 和 autopurge.purgeInterval这两个参数实现数据文件的定时清理功能，autopurge.purgeInterval这个参数指定了清理频率，以小时为单位，需要填写一个 1或更大的整数，默认是0，表示不开启自己清理功能。autopurge.snapRetainCount这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目，默认是保留3 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatadirCleanupManager</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Status of the dataDir purge task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PurgeTaskStatus</span> &#123;<br>        NOT_STARTED,<br>        STARTED,<br>        COMPLETED<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File snapDir;<span class="hljs-comment">//数据快照地址</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> File dataLogDir;<span class="hljs-comment">//日志数据的存放地址</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> snapRetainCount;<span class="hljs-comment">//需要保留的文件数目，默认是保留 3 个</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> purgeInterval;<span class="hljs-comment">//清理频率，以小时为单位,需要填写一个 1 或更大的整数，默认是 0</span><br><br>    <span class="hljs-keyword">private</span> Timer timer;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="服务初始化">2.4 服务初始化</h2><p>经过了上面的配置文件解析等准备阶段后， ZooKeeper开始服务的初始化阶段。<strong>初始化阶段可以理解为根据解析准备阶段的配置信息，实例化服务对象。服务初始化阶段的主要工作是创建用于服务统计的工具类</strong>，如下图所示主要有以下几种：</p><ol type="1"><li>ServerStats 类，它可以用于服务运行信息统计；</li><li>FileTxnSnapLog 类，可以用于数据管理。</li><li>会话管理类，设置服务器 TickTime和会话超时时间、创建启动会话管理器等操作。</li></ol><p><img src="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308143210537.png" alt="image-20230308143210537" style="zoom:67%;" /></p><h3 id="serverstats">2.4.1 ServerStats</h3><p>ServerStats是一个统计工具类，用于统计 ZooKeeper服务运行时的状态信息统计。主要统计的数据有<code>服务端向客户端发送的响应包次数</code>、<code>接收到的客户端发送的请求包次数</code>、<code>服务端处理请求的延迟情况</code>以及<code>处理客户端的请求次数</code>等。在日常运维工作中，监控服务器的性能以及运行状态等参数很多都是这个类负责收集的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerStats</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">packetsSent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">packetsReceived</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AvgMinMaxCounter</span> <span class="hljs-variable">requestLatency</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AvgMinMaxCounter</span>(<span class="hljs-string">&quot;request_latency&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">fsyncThresholdExceedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BufferStats</span> <span class="hljs-variable">clientResponseStats</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferStats</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">nonMTLSRemoteConnCntr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">nonMTLSLocalConnCntr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">authFailedCntr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="filetxnsnaplog">2.4.2 FileTxnSnapLog</h3><p>FileTxnSnapLog是一个持久化工具类，用来管理 ZooKeeper的数据存储等相关操作，可以看作为 ZooKeeper服务层提供底层持久化的接口。在 ZooKeeper 服务启动过程中，它会根据zoo.cfg 配置文件中的 dataDir 数据快照目录和 dataLogDir事物日志目录来创建 FileTxnSnapLog 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTxnSnapLog</span> &#123;<br>    <span class="hljs-comment">//the directory containing the</span><br>    <span class="hljs-comment">//the transaction logs</span><br>    <span class="hljs-keyword">final</span> File dataDir;<br>    <span class="hljs-comment">//the directory containing the</span><br>    <span class="hljs-comment">//the snapshot directory</span><br>    <span class="hljs-keyword">final</span> File snapDir;<br>    TxnLog txnLog;<br>    SnapShot snapLog;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> autoCreateDB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> trustEmptySnapshot;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VERSION</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;version-&quot;</span>;<br>  &#125;  <br></code></pre></td></tr></table></figure><h3 id="servercnxnfactory">2.4.3 ServerCnxnFactory</h3><p>ServerCnxnFactory是一个NIO类，ZooKeeper中客户端和服务端通过网络通信，其本质是通过 Java 的 IO数据流的方式进行通信，但是传统的 IO 方式具有阻塞等待的问题，而 NIO框架作为传统的 Java IO框架的替代方案，在性能上大大优于前者。也正因如此，NIO框架也被广泛应用于网络传输的解决方案中。而 ZooKeeper最早也是使用自己实现的 NIO 框架.</p><blockquote><p>但是从 3.4.0 版本后，引入了第三方 Netty等框架来满足不同使用情况的需求，而我们可以通过 ServerCnxnFactory类来设置 ZooKeeper 服务器，从而在运行的时候使用我们指定的 NIO 框架。</p></blockquote><p>如代码中 ServerCnxnFactory 类通过setServerCnxnFactory函数来创建对应的工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerCnxnFactory</span> &#123;<br>    <br>  <span class="hljs-comment">// Tells whether SSL is enabled on this ServerCnxnFactory</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> secure;<br>    <br>    <span class="hljs-keyword">protected</span> ZooKeeperServer zkServer;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZooKeeperServer</span><span class="hljs-params">(ZooKeeperServer zks)</span> &#123;<br>      <span class="hljs-built_in">this</span>.zkServer = zks;<br>      <span class="hljs-keyword">if</span> (zks != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">if</span> (secure) &#123;<br>             zks.setSecureServerCnxnFactory(<span class="hljs-built_in">this</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             zks.setServerCnxnFactory(<span class="hljs-built_in">this</span>);<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在通过 ServerCnxnFactory 类制定了具体的 NIO 框架类后。ZooKeeper首先会创建一个线程 Thread 类作为 ServerCnxnFactory 类的启动主线程。之后ZooKeeper 服务再初始化具体的 NIO类。这里请你注意的是，虽然初始化完相关的 NIO 类，比如已经设置好了服务端的对外端口，客户端也能通过诸如 2181端口等访问到服务端，但是此时 ZooKeeper服务器还是无法处理客户端的请求操作。<strong>这是因为 ZooKeeper启动后，还需要从本地的快照数据文件和事务日志文件中恢复数据</strong>。这之后才真正完成了ZooKeeper 服务的启动。</p><h2 id="初始化请求处理链">2.5 初始化请求处理链</h2><p>在完成了 ZooKeeper 服务的启动后，ZooKeeper会初始化一个请求处理逻辑上的相关类。这个操作就是初始化请求处理链。所谓的请求处理链是一种责任链模式的实现方式，根据不同的客户端请求，在ZooKeeper服务器上会采用不同的处理逻辑。而为了更好地实现这种业务场景，ZooKeeper中采用多个请求处理器类一次处理客户端请求中的不同逻辑部分。这种处理请求的逻辑方式就是责任链模式。而本课时主要说的是单机版服务器的处理逻辑，主要分为PrepRequestProcessor、SyncRequestProcessor、FinalRequestProcessor3 个请求处理器，而在一个请求到达 ZooKeeper服务端进行处理的过程，则是严格按照这个顺序分别调用这 3个类处理请求中的对应逻辑，如下图所示。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230308151250635.png"alt="image-20230308151250635" /><figcaption aria-hidden="true">image-20230308151250635</figcaption></figure><h1 id="集群版">3.集群版</h1><h2 id="集群模式特点">3.1 集群模式、特点</h2><p>为了解决单机模式下性能的瓶颈问题，以及出于对系统可靠性的高要求，集群模式的系统架构方式被业界普遍采用。那什么是集群模式呢？<code>集群模式可以简单理解为将单机系统复制成几份，部署在不同主机或网络节点上，最终构成了一个由多台计算机组成的系统“集群”。而组成集群中的每个服务器叫作集群中的网络节点。</code></p><p>到现在我们对集群的组织架构形式有了大概的了解，那么你可能会产生一个问题：我们应该如何使用集群？当客户端发送一个请求到集群服务器的时候，究竟是哪个机器为我们提供服务呢？为了解决这个问题，我们先介绍一个概念名词“<code>调度者</code>”。<strong>调度者的工作职责就是在集群收到客户端请求后，根据当前集群中机器的使用情况，决定将此次客户端请求交给哪一台服务器或网络节点进行处理</strong>，例如我们都很熟悉的负载均衡服务器就是一种调度者的实现方式。</p><p><strong>特点：</strong></p><p>在 ZooKeeper 集群模式中，将服务器分成 Leader 、Follow 、Observer三种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p><ul><li>Leader角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者。</li><li>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个Follow 服务器作为新的 Leader 服务器。</li><li>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器。</li></ul><h2 id="启动准备实现-1">3.2 启动准备实现</h2><p>同单机版启动一样，ZooKeeper 服务启动会调用入口 QuorumPeerMain 类中的main 函数。在 main 函数中的 initializeAndRun 方法中根据 zoo.cfg配置文件，判断服务启动方式是集群模式还是单机模式。在函数中首先根据 arg参数和 config.isDistributed() 来判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeAndRun</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException &#123;<br>    <span class="hljs-type">QuorumPeerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuorumPeerConfig</span>();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>        config.parse(args[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// Start and schedule the the purge task</span><br>    <span class="hljs-type">DatadirCleanupManager</span> <span class="hljs-variable">purgeMgr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatadirCleanupManager</span>(<br>        config.getDataDir(),<br>        config.getDataLogDir(),<br>        config.getSnapRetainCount(),<br>        config.getPurgeInterval());<br>    purgeMgr.start();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span> &amp;&amp; config.isDistributed()) &#123;<br>        <span class="hljs-comment">//集群模式，完成之后的集群模式的初始化工作</span><br>        runFromConfig(config);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Either no config or no quorum defined in config, running in standalone mode&quot;</span>); <span class="hljs-comment">//单机模式</span><br>        ZooKeeperServerMain.main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="quorumpeer">3.2.1 QuorumPeer</h3><p>在 ZooKeeper 服务的集群模式启动过程中，一个最主要的核心类是QuorumPeer 类。</p><blockquote><p>我们可以将每个 QuorumPeer 类的实例看作集群中的一台服务器。</p></blockquote><p>在 ZooKeeper 集群模式的运行中，一个 QuorumPeer 类的实例通常具有 3种状态，分别是参与 Leader 节点的选举、作为 Follow 节点同步 Leader节点的数据，以及作为 Leader 节点管理集群中的 Follow 节点。</p><p>介绍完 QuorumPeer 类后，下面我们看一下在 ZooKeeper服务的启动过程中，针对 QuorumPeer类都做了哪些工作。如下面的代码所示，在一个 ZooKeeper服务的启动过程中，首先调用 runFromConfig函数将服务运行过程中需要的核心工具类注册到 QuorumPeer 实例中去。</p><p>这些核心工具就是我们在上一节课单机版服务的启动中介绍的诸如FileTxnSnapLog 数据持久化类、ServerCnxnFactory 类 NIO工厂方法等。这之后还需要配置服务器地址列表、Leader选举算法、会话超时时间等参数到 QuorumPeer 实例中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runFromConfig</span><span class="hljs-params">(QuorumPeerConfig config)</span>&#123;<br><br>  <span class="hljs-type">ServerCnxnFactory</span> <span class="hljs-variable">cnxnFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-type">ServerCnxnFactory</span> <span class="hljs-variable">secureCnxnFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  ...<br><br>  quorumPeer = getQuorumPeer()<br><br>  quorumPeer.setElectionType(config.getElectionAlg());<br><br>  quorumPeer.setCnxnFactory(cnxnFactory);<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>ZooKeeper 将集群中的机器分为 Leader 、 Follow 、Obervser三种角色，每种角色服务器在集群中起到的作用都各不相同。在 ZooKeeper中的这三种角色服务器，在服务启动过程中也有各自的不同，下面我们就以Leader 角色服务器的启动和 Follow服务器服务的启动过程来看一下各自的底层实现原理。</p><h3 id="leader-服务器启动过程">3.2.2 Leader 服务器启动过程</h3><p>在 ZooKeeper 集群中，Leader服务器负责管理集群中其他角色服务器，以及处理客户端的数据变更请求。因此，在整个ZooKeeper 服务器中，Leader 服务器非常重要。所以在整个 ZooKeeper集群启动过程中，首先要先选举出集群中的 Leader 服务器。</p><p>在 ZooKeeper 集群选举 Leader节点的过程中，首先会根据服务器自身的服务器 ID（SID）、最新的ZXID、和当前的服务器 epoch（currentEpoch）这三个参数来生成一个选举标准。之后，ZooKeeper 服务会根据zoo.cfg 配置文件中的参数，选择参数文件中规定的 Leader 选举算法，进行Leader 头节点的选举操作。而在 ZooKeeper 中提供了三种 Leader选举算法，分别是 LeaderElection、AuthFastLeaderElection、FastLeaderElection。在我们日常开发过程中，可以通过在zoo.cfg 配置文件中使用 electionAlg参数属性来制定具体要使用的算法类型。具体的 Leader选举算法我们会在之后的章节中展开讲解。</p><p>这里我们只需要知道，在 ZooKeeper集群模式下服务启动后。首先会创建用来选举 Leader 节点的工具类QuorumCnxManager 。下面这段代码给出了 QuorumCnxManager在创建实例的时候首先要实例化 Listener 对象用于监听 Leader 选举端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.zookeeper.server.quorum;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuorumCnxManager</span> &#123;<br><br>...<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">QuorumCnxManager</span><span class="hljs-params">(QuorumPeer self)</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cnxToValue</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;zookeeper.cnxTimeout&quot;</span>)<br><br>    listener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>();<br><br>    listener.setName(<span class="hljs-string">&quot;QuorumPeerListener&quot;</span>);<br><br>  &#125;<br><br> ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而在 ZooKeeper 中，Leader选举的大概过程，总体说来就是在集群中的所有机器中直接进行一次选举投票，选举出一个最适合的机器作为Leader 节点。而具体的评价标准就是我们上面提到的三种选举算法。而从 3.4.0版本开始，ZooKeeper 只支持 FastLeaderElection这一种选举算法。同时没有被选举为 Leader 节点的机器则作为 Follow 或Observer 节点机器存在。</p><h3 id="follow-服务器启动过程">3.2.3 Follow 服务器启动过程</h3><p>在服务器的启动过程中，Follow 机器的主要工作就是和 Leader节点进行数据同步和交互。当 Leader 机器启动成功后，Follow节点的机器会收到来自 Leader 节点的启动通知。而该通知则是通过LearnerCnxAcceptor类来实现的。该类就相当于一个接收器。专门用来接收来自集群中 Leader节点的通知信息。下面这段代码中 LearnerCnxAcceptor 类首先初始化要监听的Leader 服务器地址和设置收到监听的处理执行方法等操作 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LearnerCnxAcceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperCriticalThread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LearnerCnxAcceptor</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;LearnerCnxAcceptor-&quot;</span> + ss.getLocalSocketAddress(), zk<br><br>                .getZooKeeperServerListener());<br><br>    &#125;<br><br> &#125;   <br></code></pre></td></tr></table></figure><p>在接收到来自 Leader 服务器的通知后，Follow 服务器会创建一个LearnerHandler 类的实例，用来处理与 Leader 服务器的数据同步等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.zookeeper.server.quorum;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LearnerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZooKeeperThread</span> &#123;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Socket sock;<br><br>  <span class="hljs-keyword">final</span> Leader leader;<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在完成数据同步后，一个 ZooKeeper服务的集群模式下启动的关键步骤就完成了，整个服务就处于运行状态，可以对外提供服务了。</p><h1 id="section">4.🍪</h1><p>在我们日常使用 ZooKeeper集群服务器的时候，集群中的机器个数应该如何选择？</p><blockquote><p>最好使用奇数原则，最小的集群配置应该是三个服务器或者节点。而如果采用偶数，在Leader节点选举投票的过程中就不满足大多数原则，这时就产生“脑裂”这个问题。</p></blockquote><h1 id="read-more">5.Read more</h1><p>:lollipop::<ahref="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/08%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%EF%BC%9F.md">服务启动过程</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper简介</title>
    <link href="/2022/09/11/framework/zookeeper/2022-09-11_zookeeper%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/11/framework/zookeeper/2022-09-11_zookeeper%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/image-20230306150013020.png" /></p><h1 id="what-is-zookeeper">1. What is ZooKeeper?</h1><p>ZooKeeper 是 Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p><a href="https://zookeeper.apache.org/">Zookeeper官网:</a></p><p><ahref="https://zookeeper.apache.org/doc/r3.6.0/zookeeperProgrammers.html">Zookeeper官方文档:</a></p><p>ZooKeeper is a centralized service for maintaining configurationinformation, naming, providing distributed synchronization, andproviding group services. All of these kinds of services are used insome form or another by distributed applications. Each time they areimplemented there is a lot of work that goes into fixing the bugs andrace conditions that are inevitable. Because of the difficulty ofimplementing these kinds of services, applications initially usuallyskimp on them, which make them brittle in the presence of change anddifficult to manage. Even when done correctly, different implementationsof these services lead to management complexity when the applicationsare deployed.</p><p>Learn more about ZooKeeper on the <ahref="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index">ZooKeeperWiki</a>.</p><blockquote><p>简而言之：ZooKeeper是一个用于维护配置信息、命名、提供分布式同步和提供组服务的集中式服务。</p></blockquote><h2 id="设计目标">1.2设计目标</h2><h3 id="zookeeper-is-simple">1.2.1 <strong>ZooKeeper issimple</strong></h3><p>ZooKeeper允许分布式进程通过类似于标准文件系统组织的共享分层命名空间相互协调。命名空间由数据寄存器组成——用ZooKeeper 的说法称为znodes——它们类似于文件和目录。与为存储而设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟数。</p><p>ZooKeeper实现非常重视高性能、高可用性、严格有序的访问。<strong>ZooKeeper的性能方面意味着它可以用于大型分布式系统。可靠性方面使其不会成为单点故障。严格的排序意味着可以在客户端实现复杂的同步原语</strong>。</p><h3 id="zookeeper-is-replicated.">1.2.2 <strong>ZooKeeper isreplicated.</strong></h3><p>就像它协调的分布式进程一样，ZooKeeper本身旨在通过一组称为集成的主机进行复制。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/zkservice.jpg"alt="动物园管理员服务" /><figcaption aria-hidden="true">动物园管理员服务</figcaption></figure><p>构成 ZooKeeper服务的服务器必须相互了解。它们在内存中维护状态数据，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。</p><p>客户端连接到单个 ZooKeeper 服务器。客户端维护一个 TCP连接，通过它发送请求、获取响应、获取监视事件和发送心跳。如果与服务器的TCP 连接中断，客户端将连接到另一台服务器。</p><h3 id="zookeeper-is-ordered">1.2.3 <strong>ZooKeeper isordered</strong></h3><p>ZooKeeper 用反映所有 ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原语。</p><h3 id="zookeeper-is-fast">1.2.4 <strong>ZooKeeper is fast</strong></h3><p>它在“读主导”工作负载中特别快。ZooKeeper应用程序在数千台机器上运行，它在读取比写入更常见的情况下表现最佳，比率约为10:1。</p><h1 id="zookeeper安装">2.Zookeeper安装</h1><ul><li><ahref="https://www.runoob.com/w3cnote/zookeeper-setup.html">Zookeeper安装</a></li><li><ahref="https://blog.51cto.com/u_15856491/5815098">Zookeeper常见错误</a></li></ul><p><strong><em>本文省略Zookeeper安装具体教程，如果有兴趣查找以上资料进行安装。</em></strong></p><p>zoo.cfg相关参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># The number of milliseconds of each tick</span><br><span class="hljs-comment"># 这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳，以毫秒为单位。</span><br><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of ticks that the initial </span><br><span class="hljs-comment"># synchronization phase can take</span><br><span class="hljs-comment"># 这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 52000=10 秒</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of ticks that can pass between </span><br><span class="hljs-comment"># sending a request and getting an acknowledgement</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-comment"># do not use /tmp for storage, /tmp here is just </span><br><span class="hljs-comment"># example sakes.</span><br><span class="hljs-comment"># 顾名思义就是 Zookeeper 保存数据的目录，默认情况下</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\software\zookeeper\apache-zookeeper-3.7.0\data</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Zookeeper 将写数据的日志文件保存在这个目录里。</span><br><span class="hljs-attr">dataLogDir</span>=<span class="hljs-string">D:\software\zookeeper\apache-zookeeper-3.7.0\log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the port at which the clients will connect</span><br><span class="hljs-comment"># 这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the maximum number of client connections.</span><br><span class="hljs-comment"># increase this if you need to handle more clients</span><br><span class="hljs-comment">#maxClientCnxns=60</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Be sure to read the maintenance section of the </span><br><span class="hljs-comment"># administrator guide before turning on autopurge.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of snapshots to retain in dataDir</span><br><span class="hljs-comment">#autopurge.snapRetainCount=3</span><br><span class="hljs-comment"># Purge task interval in hours</span><br><span class="hljs-comment"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="hljs-comment">#autopurge.purgeInterval=1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">## Metrics Providers</span><br><span class="hljs-comment"># https://prometheus.io Metrics Exporter</span><br><span class="hljs-comment">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="hljs-comment">#metricsProvider.httpPort=7000</span><br><span class="hljs-comment">#metricsProvider.exportJvmInfo=true</span><br></code></pre></td></tr></table></figure><h1 id="zookeeper概念">3.Zookeeper概念</h1><h2 id="数据模型和分层命名空间">3.1 数据模型和分层命名空间</h2><p>ZooKeeper中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。ZooKeeper的数据模型也具有一个固定的根节点（/），我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。ZooKeeper树中的每一层级用斜杠（/）分隔开，且只能用绝对路径（如“get/work/task1”）的方式查询 ZooKeeper节点，而不能使用相对路径。具体的结构看看下面这张图：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl6yL9uAbpHYAABF_GHyGNc950.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>ZooKeeper数据模型的结构与Unix文件系统很类似，每个节点称作一个ZNode，ZNode 是以key-value 形式存在的。名称 key 由斜线 / 分割的一系列路径元素，zookeeper名称空间中的每个节点都是由一个路径标识。</p><p>注意：ZooKeeper不使用相对路径。所以以下是无效的：“/a/b/./c”或“/a/b/../c”。</p></blockquote><h2 id="节点和临时节点">3.2 节点和临时节点</h2><p>与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以有与其关联的数据以及子节点。这就像拥有一个允许文件也可以是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息、配置、位置信息等，因此每个节点存储的数据通常很小，在字节到千字节范围内。）我们使用术语znode 来<em>明确</em>我们正在谈论 ZooKeeper 数据节点。</p><p>Znodes 维护一个统计结构，其中包括数据更改的版本号、ACL更改和时间戳，以允许缓存验证和协调更新。每次 znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</p><p>存储在命名空间中每个 znode 的数据是原子读取和写入的。读取获取与 znode关联的所有数据字节，写入替换所有数据。每个节点都有一个访问控制列表(ACL)，用于限制谁可以做什么。</p><p>ZooKeeper 也有临时节点的概念。只要创建 znode 的会话处于活动状态，这些znode 就会存在。当会话结束时，znode 将被删除。</p><h2 id="条件更新和监视">3.3 条件更新和监视</h2><p><em>ZooKeeper 支持watches</em>的概念。客户端可以在 znode上设置监视。当 znode 更改时，将触发并删除watch。触发监视时，客户端会收到一个数据包，说明 znode已更改。如果客户端和其中一个 ZooKeeper服务器之间的连接断开，客户端将收到本地通知。</p><p><strong>3.6.0 中的新增功能：</strong>客户端还可以在 znode上设置永久的递归监视，这些监视在触发时不会被删除，并且会递归地触发已注册znode 以及任何子 znode 上的更改。</p><h2 id="保证">3.4 保证</h2><p>ZooKeeper非常快速且非常简单。但是，由于它的目标是成为构建更复杂服务（例如同步）的基础，因此它提供了一组保证。这些都是：</p><ul><li>顺序一致性——来自客户端的更新将按照它们发送的顺序应用。</li><li>原子性——更新要么成功要么失败。没有部分结果。</li><li>单一系统映像——无论连接到哪个服务器，客户端都将看到相同的服务视图。即，即使客户端故障转移到具有相同会话的不同服务器，客户端也永远不会看到系统的旧视图。</li><li>可靠性——应用更新后，它将一直持续到客户端覆盖更新为止。</li><li>及时性——系统的客户视图保证在特定时间范围内是最新的。</li></ul><h2 id="simple-api">3.5 Simple Api</h2><p>ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持这些操作：</p><ul><li><em>create</em>：在树中的某个位置创建一个节点</li><li><em>delete</em> : 删除一个节点</li><li><em>exists</em> : 测试节点是否存在于某个位置</li><li><em>获取数据</em>：从节点读取数据</li><li><em>设置数据</em>：将数据写入节点</li><li><em>get children</em>：检索节点的子节点列表</li><li><em>sync</em>：等待数据传播</li></ul><h1 id="zookeeper节点">4.Zookeeper节点</h1><h2 id="节点的状态结构">4.1 节点的状态结构</h2><p>节点称为 <strong>ZNode</strong>。每个 ZNode有一个名称标识，即树根到该节点的路径（用 “/” 分隔），ZooKeeper树中的每个节点都可以拥有子节点，这与文件系统的目录树类似。</p><p>上图中，每一个节点都是一个ZNode，每个ZNode都会保存自己的数据内容和一系列属性信息，维护一个stat结构。比如上面我们创建的<code>works</code>节点：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[zk</span>: <span class="hljs-string">localhost:2181(CONNECTED) 15] stat /works</span><br><span class="hljs-attr">cZxid</span> = <span class="hljs-string">0x4</span><br><span class="hljs-attr">ctime</span> = <span class="hljs-string">Mon Mar 06 16:07:21 CST 2023</span><br><span class="hljs-attr">mZxid</span> = <span class="hljs-string">0x4</span><br><span class="hljs-attr">mtime</span> = <span class="hljs-string">Mon Mar 06 16:07:21 CST 2023</span><br><span class="hljs-attr">pZxid</span> = <span class="hljs-string">0x7</span><br><span class="hljs-attr">cversion</span> = <span class="hljs-string">3</span><br><span class="hljs-attr">dataVersion</span> = <span class="hljs-string">0</span><br><span class="hljs-attr">aclVersion</span> = <span class="hljs-string">0</span><br><span class="hljs-attr">ephemeralOwner</span> = <span class="hljs-string">0x0</span><br><span class="hljs-attr">dataLength</span> = <span class="hljs-string">0</span><br><span class="hljs-attr">numChildren</span> = <span class="hljs-string">3</span><br><span class="hljs-attr">[zk</span>: <span class="hljs-string">localhost:2181(CONNECTED) 16]</span><br></code></pre></td></tr></table></figure><p>其中每个字段的含义为：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/Ciqc1F6zbwWAVkt5AAC_yMQVCFo712.png"alt="表.png" /><figcaption aria-hidden="true">表.png</figcaption></figure><blockquote><p>在zookeeper中，事务是指能够改变zookeeper服务器状态的操作，称为事务操作和更新操作。一般包括数据节点的创建与删除、数据节点内容更新等操作。</p><p>每一次事务请求，zk都会为其分配一个全局唯一的事务id，用ZXID表示，通常是一个64位数字。每一个ZXID对应一次更新更新操作。</p></blockquote><p><strong>为什么 ZooKeeper 不能采用相对路径查找节点呢？</strong></p><blockquote><p>因为 ZooKeeper大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。ZooKeeper在底层实现的时候，使用了一个 hashtable，即hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes，用节点的完整路径来作为 key 存储节点数据。这样就大大提高了 ZooKeeper的性能。</p></blockquote><p>上述众多节点特性，使得 zookeeper能开发不出不同的经典应用场景，比如：</p><ul><li><ol type="1"><li>数据发布/订阅</li></ol></li><li><ol start="2" type="1"><li>负载均衡</li></ol></li><li><ol start="3" type="1"><li>分布式协调/通知</li></ol></li><li><ol start="4" type="1"><li>集群管理</li></ol></li><li><ol start="5" type="1"><li>集群管理</li></ol></li><li><ol start="6" type="1"><li>master 管理</li></ol></li><li><ol start="7" type="1"><li>分布式锁</li></ol></li><li><ol start="8" type="1"><li>分布式队列</li></ol></li></ul><h2 id="节点类型">4.2 <strong>节点类型</strong></h2><p>与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以有与其关联的数据以及子节点。这就像拥有一个允许文件也可以是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息、配置、位置信息等，因此每个节点存储的数据通常很小，在字节到千字节范围内。）我们使用术语<code>znode</code>来<em>明确</em>我们正在谈论 ZooKeeper 数据节点。</p><p>Znodes 维护一个统计结构，其中包括数据更改的版本号、ACL更改和时间戳，以允许缓存验证和协调更新。每次 znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</p><p>存储在命名空间中每个 znode 的数据是原子读取和写入的。读取获取与 znode关联的所有数据字节，写入替换所有数据。<strong>每个节点都有一个访问控制列表(ACL)，用于限制谁可以做什么</strong>。</p><p>ZooKeeper 由节点来存储信息，ZooKeeper 中的数据节点也分为<code>持久节点</code>、<code>临时节点</code>和<code>有序节点</code>三种类型：</p><h3 id="持久节点">4.2.1 <strong>持久节点</strong></h3><p>持久节点，这种节点也是在 ZooKeeper最为常用的，持久节点一旦将节点创建为持久节点，该数据节点会一直存储在ZooKeeper服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用delete 函数进行删除操作。</p><p>### 4.2.2 临时节点</p><p>ZooKeeper 也有临时节点的概念。只要创建 znode 的会话处于活动状态，这些znode 就会存在。当会话结束时，znode 将被删除。</p><p>临时节点的一个最重要的特性就是临时性。所谓临时性是指，如果将节点创建为临时节点，那么该节点数据不会一直存储在ZooKeeper服务器上。<code>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除</code>。同样，我们可以像删除持久节点一样主动删除临时节点。</p><p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为“/servers”节点，并为集群下的每台服务器创建一个临时节点“/servers/host”，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。如下图所示：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl6yL-SAb0zaAABQBLohKvo019.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>临时节点不允许有子节点，因为它随时可能被删除。</p></blockquote><p>### 4.2.3 有序节点</p><p>其实有序节点并不算是一种单独种类的节点，而是在之前提到的持久节点和临时节点特性的基础上，增加了一个节点有序的性质。所谓节点有序是说在我们创建有序节点的时候，ZooKeeper服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。例如一个客户端创建了一个路径为works/task- 的有序节点，那么 ZooKeeper将会生成一个序号并追加到该节点的路径后，最后该节点的路径为works/task-1。通过这种方式我们可以直观的查看到节点的创建顺序。</p><blockquote><p>因此可以分为：</p><ul><li><strong>持久节点</strong>：节点被创建后会一直存在服务器，除非主动进行ZNode删除操作，主动清除。否则一直被保存</li><li><strong>持久顺序节点</strong>：创建节点时会在节点名后面加上一个数字后缀来表示顺序，和持久节点特性一样</li><li><strong>临时节点</strong>：生命周期和客户端会话绑在一起，客户端会话结束，节点会被删除；不能创建子节点</li><li><strong>临时顺序节点</strong>：有顺序的临时节点</li></ul></blockquote><p>到目前为止我们知道在 ZooKeeper 服务器上存储数据的基本信息，知道了ZooKeeper中的数据节点种类有持久节点和临时节点等。上述这几种数据节点虽然类型不同，但ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组（bytedata[]），用来存储节点的数据、ACL访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p><h1 id="zookeeper命令">5.Zookeeper命令</h1><p><strong>命令：</strong></p><p>为了后续讲解，此处只展示常用的基础命令。</p><ul><li><strong>connect host:port</strong> 连接zookeeper</li></ul><blockquote><p>connect 127.0.0.1:2181</p></blockquote><p>可选的“chroot”后缀也可以附加到连接字符串。这将运行客户端命令，比如我们运行：</p><blockquote><p>connect 127.0.0.1:2181/works</p></blockquote><p>其中客户端将根于此路径，所有路径都将相对于此根</p><ul><li><strong>ls</strong>查看某个路径下目录列表，<strong>path</strong>：代表路径。</li></ul><blockquote><p>ls path</p></blockquote><ul><li><strong>ls2</strong> 查看某个路径下目录列表，它比 ls命令列出更多的详细信息</li></ul><blockquote><p>ls2 path</p></blockquote><ul><li><strong>get</strong>用于获取节点数据和状态信息，<strong>[watch]</strong>：对<strong>节点</strong>进行事件监听。</li></ul><blockquote><p>get path [watch]</p><p>节点监听：如果有另一个终端对该节点进行了修改，则监听此节点的终端会得到事件通知</p></blockquote><ul><li><strong>stat</strong> 查看节点状态信息。</li></ul><blockquote><p>stat path [watch]</p></blockquote><ul><li><strong>create</strong> 用于创建节点并赋值。</li></ul><blockquote><p>create [-s] [-e] path data acl</p></blockquote><ul><li><strong>[-s] [-e]</strong>：-s 和 -e 都是可选的，-s 代表顺序节点，-e 代表临时节点，</li><li><strong>path</strong>：指定要创建节点的路径，比如<strong>/runoob</strong>。</li><li><strong>data</strong>：要在此节点存储的数据。</li><li><strong>acl</strong>：访问权限相关，默认是world，相当于全世界都能访问。</li></ul><p><strong>注意其中 -s 和 -e可以同时使用的，并且临时节点不能再创建子节点。</strong></p><ul><li><strong>set</strong>修改节点存储的数据。<strong>[version]</strong>：可选项，版本号(可用作乐观锁)。</li></ul><blockquote><p>set path data [version]</p></blockquote><ul><li><strong>delete</strong> 删除某节点</li></ul><blockquote><p>delete path [version]</p></blockquote><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/zookeeper/CgqCHl6yL9uAbpHYAABF_GHyGNc950.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>举例，现在我们创建上图节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: localhost:2181(CONNECTED) 0] <span class="hljs-built_in">ls</span> /<br>[zookeeper]<br>[zk: localhost:2181(CONNECTED) 1] create /locks<br>Created /locks<br>[zk: localhost:2181(CONNECTED) 2] create /works<br>Created /works<br>[zk: localhost:2181(CONNECTED) 3] create /works/test1<br>Created /works/test1<br>[zk: localhost:2181(CONNECTED) 4] create /works/test2<br>Created /works/test2<br>[zk: localhost:2181(CONNECTED) 5] create /works/test3<br>Created /works/test3<br>[zk: localhost:2181(CONNECTED) 6] <span class="hljs-built_in">ls</span> /<br>[locks, works, zookeeper]<br>[zk: localhost:2181(CONNECTED) 7]<br></code></pre></td></tr></table></figure><h1 id="read-more">6.Read more</h1><p>:lollipop::https://www.runoob.com/w3cnote/zookeeper-znode-data-model.html</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="/2022/05/27/framework/spring/2022-05-22_Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/05/27/framework/spring/2022-05-22_Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="spring依赖注入">Spring依赖注入</h1><p>spring依赖注入包括三种：<strong>1.setter注入，2.构造器注入，3,属性注入</strong>，</p><h1 id="基于构造器注入">1.基于构造器注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于setter注入">2.基于setter注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> UserDao userDao;<br>  <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>      <span class="hljs-built_in">this</span>.userDao = userDao;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="基于filed注解注入">3.基于Filed(注解)注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>    <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-comment">//@Inject</span><br>  <span class="hljs-keyword">private</span> UserDao userDao;<br>  <br>  <span class="hljs-comment">//简单的使用例子，下同</span><br>  <span class="hljs-keyword">public</span> List <span class="hljs-title function_">listFoo</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> userDao.list();<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们使用最多的方式就是属性注入的方式：</p><ol type="1"><li>注入方式非常简单：加入要注入的字段，附上<code>@Autowired</code>，即可完成。</li><li>使得整体代码简洁明了，看起来美观大方</li></ol></blockquote><h1id="spring为什么推荐构造器注入方式">4.spring为什么推荐构造器注入方式？</h1><p>先来看看Spring在文档里怎么说：</p><blockquote><p>The Spring team generally advocates constructor injection as itenables one to implement application components as immutable objects andto ensure that required dependencies are not null. Furthermoreconstructor-injected components are always returned to client (calling)code in a fully initialized state.As a side note, a large number ofconstructor arguments is a bad code smell, implying that the classlikely has too many responsibilities and should be refactored to betteraddress proper separation of concerns.”</p></blockquote><p>简单的翻译一下：这个构造器注入的方式<strong>能够保证注入的组件不可变，并且确保需要的依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。与此同时，从代码质量的角度来看，一个巨大的构造方法通常代表着出现了代码异味，这个类可能承担了过多的责任。</p><blockquote><p>对于这个类可能承担了过多的责任这个问题，说明你的类当中有太多的责任，那么你要好好想一想是不是自己违反了类的<ahref="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#s单一职责srp">单一性职责原则</a>，从而导致有这么多的依赖要注入。</p></blockquote><ul><li><p><strong>依赖不可变</strong>：其实说的就是final关键字。</p></li><li><p><strong>依赖不为空</strong>（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK。2：无该类型的参数-&gt;报错。</p></li><li><p><strong>完全初始化的状态</strong>：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</p></li></ul><h1 id="autowiredresourceinject">5.@Autowired、<span class="citation"data-cites="Resource">@Resource</span>、<span class="citation"data-cites="Inject">@Inject</span></h1><p>Spring 支持使用<code>@Autowired</code>, <code>@Resource</code>,<code>@Inject</code> 三个注解进行依赖注入。那@Autowired和<spanclass="citation" data-cites="Resource以及">@Resource以及</span><spanclass="citation"data-cites="Inject等注解注入有何区别">@Inject等注解注入有何区别</span>？</p><h2 id="autowired">5.1 <span class="citation"data-cites="Autowired">@Autowired</span></h2><p>在Spring 2.5 引入了 <span class="citation"data-cites="Autowired">@Autowired</span> 注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从Autowired注解源码上看，可以使用在下面这些地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> #方法<br><span class="hljs-meta">@Target(ElementType.PARAMETER)</span> #方法参数<br><span class="hljs-meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量<br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span> #注解<br></code></pre></td></tr></table></figure><ul><li><strong>字段属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><ul><li><strong>构造函数，方法参数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HelloDao helloDao;<br><br><span class="hljs-comment">//@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloServiceImpl</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> HelloDao helloDao)</span> &#123;<br> <span class="hljs-built_in">this</span>.helloDao = helloDao;<br>&#125;<br><span class="hljs-comment">// 构造器注入也可不写@Autowired，也可以注入成功。</span><br></code></pre></td></tr></table></figure><ul><li><strong>方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HelloDao helloDao;<br><br><span class="hljs-keyword">public</span> HelloDao <span class="hljs-title function_">getHelloDao</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">return</span> helloDao;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHelloDao</span><span class="hljs-params">(HelloDao helloDao)</span> &#123;<br>    <span class="hljs-built_in">this</span>.helloDao = helloDao;<br>&#125;<br></code></pre></td></tr></table></figure><p>将@Autowired写在被注入的成员变量上，setter或者构造器上，就不用再xml文件中配置了。</p><p>如果有多个类型一样的Bean候选者，则默认根据设定的属性名称进行获取。如HelloDao 在Spring中有 helloWorldDao 和 helloDao 两个Bean候选者。</p><p>首先根据类型获取，发现多个HelloDao，然后根据helloDao进行获取，如果要获取限定的其中一个候选者，结合@Qualifier进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;helloWorldDao&quot;)</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><blockquote><p>注入名称为helloWorldDao 的Bean组件。<span class="citation"data-cites="Qualifier">@Qualifier</span>("XXX") 中的 XX是 Bean的名称，所以 <span class="citation"data-cites="Autowired">@Autowired</span> 和 <span class="citation"data-cites="Qualifier">@Qualifier</span> 结合使用时，自动注入的策略就从byType 转变成 byName 了。</p></blockquote><p>注入名称为helloWorldDao的Bean组件。<code>@Qualifier("XXX")</code>中的 XX是 Bean 的名称，所以<code>@Autowired</code> 和 <code>@Qualifier</code>结合使用时，自动注入的策略就从 byType 转变成 byName 了。</p><p>多个类型一样的Bean候选者，也可以<code>@Primary</code>进行使用，设置首选的组件，也就是默认优先使用哪一个。</p><p>注意：使用@Qualifier时候，如何设置的指定名称的Bean不存在，则会抛出异常，如果防止抛出异常，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier(&quot;xxxxyyyy&quot;)</span><br><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><p>举例：</p><p>声明一个接口UserDao与2个实现类UserDaoImpl、UserDaoImpl2，如下：</p><p><strong>UserDao</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserDaoImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello111...&quot;</span> + data1 + <span class="hljs-string">&quot;  &quot;</span> + data2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserDaoImpl2</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello222...&quot;</span> + data1+<span class="hljs-string">&quot;  &quot;</span> + data2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">(String data1,<span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.gogo&quot;</span>);<br>        userDao.sayHello(data1,data2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后通过测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    ApplicationContext applicationContext= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config.xml&quot;</span>);<br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>    userService.gogo(<span class="hljs-string">&quot;xx1&quot;</span>,<span class="hljs-number">798</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>就会发现控制台报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="hljs-string">&#x27;userService&#x27;</span>: Unsatisfied dependency expressed through field <span class="hljs-string">&#x27;userDao&#x27;</span>; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;com.itszt.ioc.dao.UserDao&#x27;</span> available: expected single matching bean but found 2: userDaoImpl,userDaoImpl2<br>... ...<br><br>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;com.itszt.ioc.dao.UserDao&#x27;</span> available: expected single matching bean but found 2: userDaoImpl,userDaoImpl2<br></code></pre></td></tr></table></figure><p>加上<code>@Qualifier</code>注解，：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value = &quot;userDaoImpl&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">(String data1,<span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.gogo&quot;</span>);<br>        userDao.sayHello(data1,data2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>则运行正常:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">17:35:58,153  INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [com/xxx/ioc/spring-config.xml]<br>UserServiceImpl.gogo<br>hello111...xx1  798<br></code></pre></td></tr></table></figure><ul><li><strong>简单总结</strong>：</li></ul><p>1、<span class="citation"data-cites="Autowired是Spring自带的注解">@Autowired是Spring自带的注解</span>，通过<code>AutowiredAnnotationBeanPostProcessor</code>类实现的依赖注入</p><p>2、<span class="citation"data-cites="Autowired可以作用在CONSTRUCTOR">@Autowired可以作用在CONSTRUCTOR</span>、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE</p><p>3、<span class="citation"data-cites="Autowired默认是根据类型">@Autowired默认是根据类型</span>（byType）进行自动装配的</p><p>4、如果有多个类型一样的Bean候选者，需要指定按照名称（byName）进行装配，则需要配合@Qualifier。</p><blockquote><p>指定名称后，如果SpringIOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常。</p><p>如果容器中有同种类型的多个实现，使用@Autowired则会抛出NoUniqueBeanDefinitionException异常，存在多个实现类会不知道选择哪一个而报错。所以说，存在多个实现类的情况，不能用byType的形式。</p></blockquote><h2 id="resouce">5.2 <span class="citation"data-cites="Resouce">@Resouce</span></h2><ul><li><strong>Resource注解源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">// 其他省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从Resource注解源码上看，可以使用在下面这些地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> #接口、类、枚举、注解<br><span class="hljs-meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> #方法<br></code></pre></td></tr></table></figure><p>name 指定注入指定名称的组件。</p><ul><li><strong>字段属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resouce</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><blockquote><p>同理，如果有多个候选bean，则也会抛出NoUniqueBeanDefinitionException异常</p></blockquote><p>也可以直接指定注入的bean，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;userDaoImpl&quot;)</span><br><span class="hljs-keyword">private</span> UserDao userDao ;<br></code></pre></td></tr></table></figure><blockquote><p>name 的作用类似 <span class="citation"data-cites="Qualifier">@Qualifier</span>，所以Autowired</p></blockquote><ul><li><strong>简单总结</strong>：</li></ul><p>1、<span class="citation"data-cites="Resource是JSR250规范的实现">@Resource是JSR250规范的实现</span>，在javax.annotation包下</p><p>2、<span class="citation"data-cites="Resource可以作用TYPE">@Resource可以作用TYPE</span>、FIELD、METHOD上</p><p>3、<span class="citation"data-cites="Resource是默认根据属性名称进行自动装配的">@Resource是默认根据属性名称进行自动装配的</span>，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入</p><h2 id="inject">5.3 <span class="citation"data-cites="Inject">@Inject</span></h2><ul><li><strong>Inject注解源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123; METHOD, CONSTRUCTOR, FIELD &#125;)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Inject &#123;&#125;<br></code></pre></td></tr></table></figure><p>从Inject注解源码上看，可以使用在下面这些地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数<br><span class="hljs-meta">@Target(ElementType.METHOD)</span> #方法<br><span class="hljs-meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量<br></code></pre></td></tr></table></figure><ul><li><strong>字段属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">private</span> HelloDao helloDao;<br></code></pre></td></tr></table></figure><blockquote><p>同理，如果有多个候选bean，则也会抛出NoUniqueBeanDefinitionException异常</p></blockquote><p>也可以直接指定注入的bean，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span><br><span class="hljs-meta">@Named(name = &quot;userDaoImpl&quot;)</span><br><span class="hljs-keyword">private</span> UserDao userDao ;<br></code></pre></td></tr></table></figure><blockquote><p>name 的作用类似 <span class="citation"data-cites="Qualifier">@Qualifier</span>，所以Autowired</p></blockquote><ul><li><strong>简单总结</strong>：</li></ul><p>1、<span class="citation"data-cites="Inject是JSR330">@Inject是JSR330</span> (Dependency Injectionfor Java)中的规范，需要导入javax.inject.Inject jar包 ，才能实现注入</p><p>2、<span class="citation"data-cites="Inject可以作用CONSTRUCTOR">@Inject可以作用CONSTRUCTOR</span>、METHOD、FIELD上</p><p>3、<span class="citation"data-cites="Inject是根据类型进行自动装配的">@Inject是根据类型进行自动装配的</span>，如果需要按名称进行装配，则需要配合@Named；</p><h1 id="autowiredresourceinject总结">6.@Autowired、<spanclass="citation" data-cites="Resource">@Resource</span>、<spanclass="citation" data-cites="Inject总结">@Inject总结</span></h1><p>1、<span class="citation"data-cites="Autowired是Spring自带的">@Autowired是Spring自带的</span>，<spanclass="citation"data-cites="Resource是JSR250规范实现的">@Resource是JSR250规范实现的</span>，<spanclass="citation"data-cites="Inject是JSR330规范实现的">@Inject是JSR330规范实现的</span>。</p><p>2、<span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Inject用法基本一样">@Inject用法基本一样</span>，不同的是@Inject没有required属性。</p><p>3、<span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Inject是默认按照">@Inject是默认按照</span><strong>类型</strong>匹配的，<spanclass="citation"data-cites="Resource是按照">@Resource是按照</span><strong>名称</strong>匹配的。</p><p>4、<span class="citation"data-cites="Autowired如果需要按照名称匹配需要和">@Autowired如果需要按照名称匹配需要和</span><spanclass="citation"data-cites="Qualifier一起使用">@Qualifier一起使用</span>，<spanclass="citation" data-cites="Inject和">@Inject和</span><spanclass="citation" data-cites="Named一起使用">@Named一起使用</span>，<spanclass="citation"data-cites="Resource则通过name进行指定">@Resource则通过name进行指定</span>。</p><h1 id="read-more">7.Read more</h1><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc.html</p><p>:lollipop::https://www.cnblogs.com/diandianquanquan/p/11518365.html</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="/2022/05/20/framework/spring/2022-05-20_Spring%20Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/20/framework/spring/2022-05-20_Spring%20Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="spring中bean的生命周期">1.Spring中bean的生命周期</h1><p>在spring中，bean是springIOC容器实例化、组装和管理的对象，因此spring中的bean的生命周期也由spring管理。</p><p>bean的生命周期分为4个阶段为：</p><ul><li>实例化 - Instantiation</li><li>初始化 - Populate</li><li>使用 - Initialization</li><li>销毁 - Destruction</li></ul><h1 id="bean的生命周期图">2.Bean的生命周期图</h1><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20220731180239724.png" /></p><h1 id="代码测试">3.代码测试</h1><h2 id="person">3.1 <strong>Person</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xxx.beancycle.instant;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanNameAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.DisposableBean;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> javax.annotation.PreDestroy;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, DisposableBean &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> phone;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【构造器】调用Person的构造器实例化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【注入属性】注入属性name:&quot;</span> + name);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【注入属性】注入属性address:&quot;</span>+address);<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> phone;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPhone</span><span class="hljs-params">(<span class="hljs-type">int</span> phone)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【注入属性】注入属性phone:&quot;</span>+ phone);<br>        <span class="hljs-built_in">this</span>.phone = phone;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [address=&quot;</span> + address + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, phone=&quot;</span><br>                + phone + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//@PostConstruct--&gt;InitializingBean接口方法(afterPropertiesSet)--&gt;自定义的方法</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PostConstruct</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;PostConstruct!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这是InitializingBean接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>+<span class="hljs-built_in">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myInit</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;</span>);<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">//@PreDestroy--&gt;DiposibleBean接口方法(destroy)--&gt;自定义的方法</span><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PreDestroy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;PreDestroy!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//这是DiposibleBean接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myDestory</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;</span>);<br>    &#125;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>三个属性：name、address、phone。且分别有3个方法@PostConstruct、afterPropertiesSet()、myInit()。针对于bean的初始化方法。同理，有3个方法对应bean销毁调用的方法。</p></blockquote><h2 id="mybeanpostprocessor">3.2 MyBeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是BeanPostProcessor实现类构造器！！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object arg0, String arg1)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性1进行更改！&quot;</span>);<br>        <span class="hljs-keyword">return</span> arg0;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object arg0, String arg1)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性1进行更改！&quot;</span>);<br>        <span class="hljs-keyword">return</span> arg0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现<code>BeanPostProcessor</code>接口，覆写postProcessBeforeInitialization、postProcessAfterInitialization方法。</p></blockquote><h2 id="myinstantiationawarebeanpostprocessor">3.3MyInstantiationAwareBeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span><br>        <span class="hljs-title class_">InstantiationAwareBeanPostProcessorAdapter</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInstantiationAwareBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;</span>);<br>    &#125;<br>    <br>        <span class="hljs-comment">// 接口方法、实例化Bean之前调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//实例化后置方法调用:return false时，不再走spring的逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object o, String s)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;:=============&quot;</span>+o +<span class="hljs-string">&quot;---------&quot;</span> + s);<br>        System.out.println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口方法、设置某个属性时调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessPropertyValues</span><span class="hljs-params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> pvs;<br>    &#125;<br><br>    <span class="hljs-comment">//初始化前置方法调用</span><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="hljs-comment">//        System.out.println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInitialization方法对属性2进行更改&quot;);</span><br><span class="hljs-comment">//        return bean;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    // 接口方法、初始化Bean之后调用</span><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="hljs-comment">//        System.out.println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法对属性2进行更改&quot;);</span><br><span class="hljs-comment">//        return bean;</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现MyInstantiationAwareBeanPostProcessor，只覆写postProcessPropertyValues、postProcessBeforeInstantiation、postProcessAfterInstantiation三个接口。它也实现了<code>BeanPostProcessor</code>接口，在上文我们已经覆写postProcessBeforeInitialization、postProcessAfterInitialization方法。此处就不用再次覆写。---可以覆写，只不过会先执行BeanPostProcessor的实现类，然后再依次执行。</p></blockquote><h2 id="spring-config.xml">3.4 spring-config.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>       <span class="hljs-comment">&lt;!--IoC的注解扫描--&gt;</span><br> <span class="hljs-comment">&lt;!--    &lt;context:component-scan base-package=&quot;com.xxx.beancycle.instant&quot;&gt;&lt;/context:component-scan&gt;--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.MyBeanPostProcessor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;instantiationAwareBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.MyInstantiationAwareBeanPostProcessor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;myInit&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;myDestory&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;广州&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15900&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过setter注入的方式将上述bean对象注入到ioc容器中。</p></blockquote><h2 id="test">3.5 Test</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBean</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:com/xxx/beancycle/spring-config.xml&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;容器初始化成功！！！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;现在开始关闭容器！！！&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;person&quot;</span>, Person.class);<br>    System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>+bean);<br>    applicationContext.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台打印如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">17:20:52,762  INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [com/xxx/beancycle/spring-config.xml]<br>这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性name:张三<br>【注入属性】注入属性address:广州<br>【注入属性】注入属性phone:15900<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性1进行更改！<br>==================Person [address=广州, name=张三, phone=15900]<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性1进行更改！<br>容器初始化成功！！！<br>现在开始关闭容器！！！<br>-----------Person [address=广州, name=yangxin, phone=177]<br>17:20:52,892  INFO ClassPathXmlApplicationContext:984 - Closing org.springframework.context.support.ClassPathXmlApplicationContext@3ac3fd8b: startup <span class="hljs-built_in">date</span> [Fri Mar 03 17:20:52 CST 2023]; root of context hierarchy<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br><br>Process finished with <span class="hljs-built_in">exit</span> code 0<br><br></code></pre></td></tr></table></figure><h1 id="详解日志">4.详解日志</h1><h2 id="实例化">4.1 实例化</h2><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230303172218383.png" /></p><p><strong>对应下列日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">这是BeanPostProcessor实现类构造器！！<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br></code></pre></td></tr></table></figure><blockquote><p>首先，spring会实例化MyBeanPostProcessor、MyInstantiationAwareBeanPostProcessor这些实现或者继承spring的类。然后再实例化我们定义的"bean"，此处实例化Person类时，会优先执行InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法，也就是实例化前置方法。改方法允许我们在实例化对象的时候，可以对bean进行前置处理。然后通过反射实例化对象，</p><p>实例化完成之后会调用postProcessAfterInstantiation方法，<strong>该方法返回布尔值，如果返回false则不执行postProcessPropertyValues</strong>方法，也就是不会进行属性修改。</p><p>剩余的初始化方法会执行，也就是BeanPostProcessor的postProcessBeforeInitialization与postProcessAfterInitialization方法会执行。如果在这些方法里对bean都没有进行任何处理，则该bean的所有属性值均为默认值。</p></blockquote><p>如下是返回false的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInitialization方法对属性2进行更改<br>==================Person [address=null, name=null, phone=0]<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法对属性2进行更改<br>容器初始化成功！！！<br>现在开始关闭容器！！！<br>-----------Person [address=null, name=null, phone=0]<br>17:33:33,215  INFO ClassPathXmlApplicationContext:984 - Closing org.springframework.context.support.ClassPathXmlApplicationContext@3ac3fd8b: startup <span class="hljs-built_in">date</span> [Fri Mar 03 17:33:33 CST 2023]; root of context hierarchy<br>【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法<br><br>-------&gt;打印的Person对象的属性值为空。<br></code></pre></td></tr></table></figure><h2 id="初始化">4.2 初始化</h2><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230303174845027.png" /></p><p><strong>对应下列日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">【注入属性】注入属性name:张三<br>【注入属性】注入属性address:广州<br>【注入属性】注入属性phone:15900<br>BeanPostProcessor接口方法postProcessBeforeInitialization对属性1进行更改！<br>==================Person [address=广州, name=张三, phone=15900]<br>【InitializingBean接口】调用InitializingBean.afterPropertiesSet()<br>【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法<br>BeanPostProcessor接口方法postProcessAfterInitialization对属性1进行更改！<br></code></pre></td></tr></table></figure><p>我们可以看到在xml里、配置了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;myInit&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;myDestory&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;广州&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15900&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过postProcessPropertyValues方法给bean填充属性、填充的就是我们在xml配置的属性。</p><p>aware接口我们暂时不用管。</p><p>然后执行BeanPostProcessor的postProcessBeforeInitialization方法，对bean进行初始化前置操作处理。</p><p>然后执行初始化方式（上文没有执行@PostConstruct标注的方法是因为我没有让spring扫描Persond对象。因此注解没有生效）</p></blockquote><p><strong>初始化方法优先级：</strong></p><blockquote><p><span class="citation"data-cites="PostConstruct">@PostConstruct</span>---&gt;InitializingBean.afterPropertiesSet()---&gt;xml配置的Init-method</p></blockquote><h2 id="销毁">4.3 销毁</h2><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230303182021701.png" /></p><p><strong>对应下列日志：</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">【DiposibleBean接口】调用DiposibleBean.destory()<br>【destroy-<span class="hljs-keyword">method</span>】调用&lt;<span class="hljs-title function_">bean</span>&gt;的<span class="hljs-title function_">destroy</span>-<span class="hljs-title function_">method</span>属性指定的初始化方法<br></code></pre></td></tr></table></figure><p><strong>销毁方法优先级：</strong></p><blockquote><p><span class="citation"data-cites="PreDestroy">@PreDestroy</span>---&gt;DiposibleBean.destory()---&gt;xml配置的destroy-method</p></blockquote><h1 id="beanfactorypostprocessor">5.BeanFactoryPostProcessor</h1><ul><li><strong>BeanPostProcessor</strong></li><li><strong>InstantiationAwareBeanPostProcessor</strong></li></ul><p>这两兄弟可能是Spring扩展中<strong>最重要</strong>的两个接口！InstantiationAwareBeanPostProcessor作用于<strong>实例化</strong>阶段的前后，BeanPostProcessor作用于<strong>初始化</strong>阶段的前后。</p><p>说到BeanPostProcessor，不得不提一下<code>BeanFactoryPostProcessor</code>，BeanFactoryPostProcessor和BeanPostProcessor，这两个接口，都是Spring初始化bean时对外暴露的扩展点。两个接口名称看起来很相似，但作用及使用场景却不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Modify the application context&#x27;s internal bean factory after its standard</span><br><span class="hljs-comment"> * initialization. All bean definitions will have been loaded, but no beans</span><br><span class="hljs-comment"> * will have been instantiated yet. This allows for overriding or adding</span><br><span class="hljs-comment"> * properties even to eager-initializing beans.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanFactory the bean factory used by the application context</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们新写一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanFactoryPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是BeanFactoryPostProcessor实现类构造器！！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory arg0)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanFactoryPostProcessor调用postProcessBeanFactory方法&quot;</span>);<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> arg0.getBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues());<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues().get(<span class="hljs-string">&quot;address&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues().get(<span class="hljs-string">&quot;name&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;-=-=-=-=-=-=&quot;</span>+bd.getPropertyValues().get(<span class="hljs-string">&quot;phone&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;----------:操作bean的定义&quot;</span>);<br>        bd.getPropertyValues().addPropertyValue(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;110&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>并且通过xml注入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanFactoryPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot; com.xxx.beancycle.instant.MyBeanFactoryPostProcessor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再运行测试类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">这是BeanFactoryPostProcessor实现类构造器！！<br>BeanFactoryPostProcessor调用postProcessBeanFactory方法<br>-=-=-=-=-=-=PropertyValues: length=3; bean property <span class="hljs-string">&#x27;name&#x27;</span>; bean property <span class="hljs-string">&#x27;address&#x27;</span>; bean property <span class="hljs-string">&#x27;phone&#x27;</span><br>-=-=-=-=-=-=TypedStringValue: value [广州], target <span class="hljs-built_in">type</span> [null]<br>-=-=-=-=-=-=TypedStringValue: value [张三], target <span class="hljs-built_in">type</span> [null]<br>-=-=-=-=-=-=TypedStringValue: value [15900], target <span class="hljs-built_in">type</span> [null]<br>----------:操作bean的定义<br>这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！<br>InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法<br>【构造器】调用Person的构造器实例化<br>:=============Person [address=null, name=null, phone=0]---------person<br>InstantiationAwareBeanPostProcessor调用postProcessAfterInstantiation方法<br>InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法<br>【注入属性】注入属性name:张三<br>【注入属性】注入属性address:广州<br>【注入属性】注入属性phone:110  <br>... ...<br></code></pre></td></tr></table></figure><p>我们会发现我们在xml里定义的参数已经被改变了。以前的<code>【注入属性】注入属性phone:15900</code>变为<code>【注入属性】注入属性phone:110</code>。</p><blockquote><p>实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前<strong>读取配置元数据，并可以根据需要进行修改</strong>，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置'order'属性来控制各个BeanFactoryPostProcessor的执行次序。</p></blockquote><h1 id="aware接口">6.Aware接口</h1><p>为了更好的理解生命周期，我们前面暂时没有解释生命周期图中的第六步，也就是<code>Aware</code>接口，在此处我们来讲一下Aware接口。我们看一下spring对aware接口的解释：</p><blockquote><p>A marker superinterface indicating that a bean is eligible to benotified by the Spring container of a particular framework objectthrough a callback-style method. The actual method signature isdetermined by individual subinterfaces but should typically consist ofjust one void-returning method that accepts a single argument. Note thatmerely implementing Aware provides no default functionality. Rather,processing must be done explicitly, for example in a BeanPostProcessor.Refer to ApplicationContextAwareProcessor for an example of processingspecific *Aware interface callbacks.</p></blockquote><p>含义：</p><blockquote><p>一个标记超接口，指示bean有资格通过回调样式方法被Spring容器通知特定框架对象。实际的方法签名由各个子接口确定，但通常只应由一个接受单个参数的返回空值的方法组成。</p><p>注意，仅实现Aware不提供默认功能。相反，处理必须显式完成，例如在BeanPostProcessor中。有关处理特定*Aware接口回调的示例，请参阅ApplicationContextAwareProcessor。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanClassLoaderAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanNameAware;<br><span class="hljs-keyword">import</span> org.springframework.context.*;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportAware;<br><span class="hljs-keyword">import</span> org.springframework.context.weaving.LoadTimeWeaverAware;<br><span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ResourceLoader;<br><span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;<br><span class="hljs-keyword">import</span> org.springframework.instrument.classloading.LoadTimeWeaver;<br><span class="hljs-keyword">import</span> org.springframework.jmx.export.notification.NotificationPublisher;<br><span class="hljs-keyword">import</span> org.springframework.jmx.export.notification.NotificationPublisherAware;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StringValueResolver;<br><span class="hljs-keyword">import</span> org.springframework.web.context.ServletConfigAware;<br><span class="hljs-keyword">import</span> org.springframework.web.context.ServletContextAware;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletConfig;<br><span class="hljs-keyword">import</span> javax.servlet.ServletContext;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllAwareInterface</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>, BeanClassLoaderAware,<br>        BeanFactoryAware, EnvironmentAware, EmbeddedValueResolverAware,<br>        ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware,<br>        ApplicationContextAware, ServletContextAware, LoadTimeWeaverAware, ImportAware ,<br>        NotificationPublisherAware, ServletConfigAware, ApplicationStartupAware  &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-comment">// BeanNameAware作用：让Bean对Name有知觉</span><br>        <span class="hljs-comment">//这个方法只是简单的返回我们当前的beanName,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用</span><br>        System.out.println(<span class="hljs-string">&quot;1 我是 BeanNameAware 的 setBeanName 方法  ---参数：name，内容：&quot;</span>+ name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2 我是 BeanClassLoaderAware 的 setBeanClassLoader 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 注意： 如果使用 @Configuration 注解的话，setBeanFactory方法会执行2次，</span><br>        System.out.println(<span class="hljs-string">&quot;3 我是 BeanFactoryAware 的 setBeanFactory 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnvironment</span><span class="hljs-params">(Environment environment)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;4 我是 EnvironmentAware 的 setEnvironment 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver stringValueResolver)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;5 我是 EmbeddedValueResolverAware 的 setEmbeddedValueResolver 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResourceLoader</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;6 我是 ResourceLoaderAware 的 setResourceLoader 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher applicationEventPublisher)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;7 我是 ApplicationEventPublisherAware 的 setApplicationEventPublisher 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageSource</span><span class="hljs-params">(MessageSource messageSource)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;8 我是 MessageSourceAware 的 setMessageSource 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">//实现ApplicationContextAware接口的类，都可以取得applicationContext</span><br>        System.out.println(<span class="hljs-string">&quot;9 我是 ApplicationContextAware 的 setApplicationContext 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>        <span class="hljs-comment">//实现ServletContextAware接口的类，都可以取得ServletContext</span><br>        System.out.println(<span class="hljs-string">&quot;10 我是 ServletContextAware 的 setServletContext 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLoadTimeWeaver</span><span class="hljs-params">(LoadTimeWeaver loadTimeWeaver)</span> &#123;<br>        <span class="hljs-comment">//LoadTimeWeaver 简称LTW，LTW是AOP的一种实现方式，此方法是为了获取Aop织入的对象，使用的织入方式是：类加载期织入，</span><br>        <span class="hljs-comment">// 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是LTW是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法</span><br>        <span class="hljs-comment">// 只有在使用 @EnableLoadTimeWeaving 或者存在 LoadTimeWeaver 实现的 Bean 时才会调用，顺序也很靠后</span><br>        System.out.println(<span class="hljs-string">&quot;11 我是 LoadTimeWeaverAware 的 setLoadTimeWeaver 方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImportMetadata</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>        <span class="hljs-comment">//只有被其他配置类 @Import(XX.class) 时才会调用，这个调用对 XX.class 中的所有 @Bean 来说顺序是第 1 的。</span><br>        System.out.println(<span class="hljs-string">&quot;12 我是 ImportAware 的 setImportMetadata 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNotificationPublisher</span><span class="hljs-params">(NotificationPublisher notificationPublisher)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;13 我是 NotificationPublisherAware 的 setNotificationPublisher 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServletConfig</span><span class="hljs-params">(ServletConfig servletConfig)</span> &#123;<br>        <span class="hljs-comment">//实现ServletContextAware接口的类，都可以取得ServletContext</span><br>        System.out.println(<span class="hljs-string">&quot;14 我是 ServletConfigAware 的 setServletConfig 方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationStartup</span><span class="hljs-params">(ApplicationStartup applicationStartup)</span> &#123;<br>        <span class="hljs-comment">//容器启动成功后，通过ApplicationStartup进行相应处理。</span><br>        System.out.println(<span class="hljs-string">&quot;15 我是 ApplicationStartupAware 的 setApplicationStartup 方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>spring中所有的<code>aware</code>接口：</p><p><code>ApplicationEventPublisherAware</code>,<code>ApplicationStartupAware</code>, <code>BeanClassLoaderAware</code>,<code>BeanFactoryAware</code>, <code>BeanNameAware</code>,<code>EmbeddedValueResolverAware</code>, <code>EnvironmentAware</code>,<code>ImportAware</code>, <code>LoadTimeWeaverAware</code>,<code>MessageSourceAware</code>,<code>NotificationPublisherAware</code>,<code>ResourceLoaderAware</code>, <code>SchedulerContextAware</code>,<code>ServletConfigAware</code>, <code>ServletContextAware</code></p><p>本着最简单的原则，本文不会讲aware接口全部讲解，只讲最常用的aware接口。</p><h2 id="applicationcontextaware">6.1 ApplicationContextAware</h2><p>该接口是最常用的一个注解，通过实现ApplicationContextAware接口，我们能够得到applicationContext，因此我们可以再spring容器启动的试试，对容器进行处理。</p><h2 id="applicationstartupaware">6.2 ApplicationStartupAware</h2><p>通过实现ApplicationStartupAware接口，可以在容器启动成功后，通过ApplicationStartup进行相应处理。</p><h2 id="beanfactoryaware">6.3 BeanFactoryAware</h2><p>让Bean获取配置他们的BeanFactory的引用。</p><h2 id="beannameaware">6.4 BeanNameAware</h2><p>调用BeanNameAware接口的实现类中的setBeanName方法，获取容器中 Bean的名称，</p><h2 id="environmentaware">6.5 EnvironmentAware</h2><p>实现了EnvironmentAware接口重写setEnvironment方法后，在工程启动时可以获得application.properties、xml、yml 的配置文件配置的属性值。</p><h1 id="总结">7. 总结</h1><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/spring生命周期.png"alt="spring生命周期" /><figcaption aria-hidden="true">spring生命周期</figcaption></figure><p><strong>总结：</strong></p><p>spring的生命周期分为<code>实例化</code>、<code>属性赋值</code>、<code>初始化</code>、<code>销毁</code></p><ul><li>如果 BeanFactoryPostProcessor 和 Bean 关联,则调用postProcessBeanFactory方法.(即首<strong>先尝试从Bean工厂中获取Bean</strong>)</li><li>如果 InstantiationAwareBeanPostProcessor 和 Bean关联，则调用postProcessBeforeInstantiation方法</li><li>根据配置情况调用 Bean 构造方法<strong>实例化 Bean</strong>。</li><li>如果 InstantiationAwareBeanPostProcessor 和 Bean关联，则调用postProcessAfterInstantiation方法和postProcessPropertyValues方法（前几个版本叫postProcessProperty）</li><li>调用setter方法完成 Bean 中<strong>属性注入</strong>。</li><li>调用xxxAware接口<ul><li>第一类Aware接口<ul><li>如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的setBeanName() 方法传入当前 Bean 的 id 值。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，则 Spring 调用setBeanClassLoader() 方法传入classLoader的引用。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用setBeanFactory() 方法传入当前工厂实例的引用。</li></ul></li><li>第二类Aware接口<ul><li>如果 Bean 实现了 EnvironmentAware 接口，则 Spring 调用setEnvironment() 方法传入当前 Environment 实例的引用。</li><li>如果 Bean 实现了 EmbeddedValueResolverAware 接口，则 Spring 调用setEmbeddedValueResolver() 方法传入当前 StringValueResolver实例的引用。</li><li>如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用setApplicationContext() 方法传入当前 ApplicationContext实例的引用。</li><li>... ...</li></ul></li></ul></li></ul><hr /><ul><li>如果 <code>BeanPostProcessor</code> 和 Bean 关联，则 Spring将调用该接口的预初始化方法<code>postProcessBeforeInitialzation()</code>对 Bean进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</li><li><strong>Bean初始化前置方法</strong><ul><li>如果 Bean有执行@PostConstruct注解的方法，则调用该初始化方法。</li><li>如果 Bean 实现了<code>InitializingBean</code> 接口，则 调用<code>afterPropertiesSet()</code> 方法。</li><li>如果在配置文件中通过 <strong>init-method</strong>属性指定了初始化方法，则调用该初始化方法。</li></ul></li><li>如果 BeanPostProcessor 和 Bean 关联，则 Spring将调用该接口的初始化方法<code>postProcessAfterInitialization()</code>。此时，Bean已经可以被应用系统使用了。</li><li>如果在 <code>&lt;bean&gt;</code> 中指定了该 Bean 的作用范围为scope="singleton"，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring对该 Bean 的生命周期管理；如果在 <code>&lt;bean&gt;</code> 中指定了该Bean 的作用范围为 scope="prototype"，则将该 Bean交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</li></ul><hr /><ul><li><strong>Bean销毁前置方法</strong><ul><li>如果 Bean有执行@PreDestroy注解的方法，则调用该初始化方法。</li><li>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory()方法将 Spring 中的 Bean 销毁</li><li>如果在配置文件中通过 <strong>destory-method</strong> 属性指定了 Bean的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</li></ul></li></ul><hr /><p><strong>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类</strong>：(结合上图，需要有如下顶层思维)</p><ul><li><strong>Bean自身的方法</strong>：这个包括了Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的init-method和destroy-method指定的方法</li><li><strong>Bean级生命周期接口方法</strong>：这个包括了BeanNameAware、BeanFactoryAware、ApplicationContextAware；当然也包括InitializingBean和DiposableBean这些接口的方法（可以被@PostConstruct和<spanclass="citation"data-cites="PreDestroy注解替代">@PreDestroy注解替代</span>)</li><li><strong>容器级生命周期接口方法</strong>：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor这两个接口实现，一般称它们的实现类为“后处理器”。</li><li><strong>工厂后处理器接口方法</strong>：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor,CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li></ul><h1 id="read-more">8.Read more</h1><p>:lollipop::https://blog.csdn.net/caihaijiang/article/details/35552859</p><p>:lollipop::https://www.cnblogs.com/zrtqsk/p/3735273.html</p><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Core-IOC</title>
    <link href="/2022/05/15/framework/spring/2022-05-15_Spring%20Core-IOC/"/>
    <url>/2022/05/15/framework/spring/2022-05-15_Spring%20Core-IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="spring-bean是什么">1. Spring Bean是什么？</h1><p>我们常说IOC容器，<em>容器</em>是指用以容纳物料并以壳体为主的基本装置。在Spring中，IOC容器同样也是用来容纳“东西”的。但是这个东西在Spring中变成了bean对象。</p><p>在 Spring 中，构成应用程序主干的对象和由 Spring IoC容器管理的对象称为 Bean。Bean 是由 Spring IoC容器实例化、组装和管理的对象。否则，Bean只是应用程序中的许多对象之一。Bean以及它们之间的依赖关系反映在容器使用的配置元数据中。</p><h1 id="spring-ioc">2. Spring IoC</h1><h2 id="spring-ioc简介">2.1 Spring IoC简介</h2><p><code>IoC（Inversion of Control）</code>就是常说的控制反转。依赖注入(DI) 是 IoC的一种特殊形式，对象仅通过构造函数参数、工厂方法的参数或在对象实例上设置的属性来定义其依赖关系（即它们使用的其他对象）。由工厂方法构造或返回。然后，IoC容器在创建 bean 时注入这些依赖项。这个过程从根本上来说是 bean本身的逆过程（因此得名“控制反转”），通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖项的实例化或位置。</p><p><code>org.springframework.beans</code>和包<code>org.springframework.context</code>是Spring Framework 的 IoC 容器的基础。该 <ahref="https://docs.spring.io/spring-framework/docs/6.1.6/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>接口提供了能够管理任何类型对象的高级配置机制。 <ahref="https://docs.spring.io/spring-framework/docs/6.1.6/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>是<code>BeanFactory</code>接口的子接口。它在<code>BeanFactory</code>接口功能基础上添加了更多企业特定的功能。如aop特性、事件发布功能等等，因此我们使用最多的也是<code>ApplicationContext</code>。</p><blockquote><p>Ioc—Inversion ofControl，即“控制反转”，<strong>不是什么技术，而是一种设计思想</strong>。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><p><code>BeanFactory</code>提供了配置框架和基本功能，<code>ApplicationContext</code>在此基础上添加了更多企业特定的功能。</p></blockquote><h2 id="控制反转">2.2 控制反转</h2><p><code>org.springframework.context.ApplicationContext</code> 代表Spring IoC容器，负责实例化、配置和组装Bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。</p><p>配置元数据以 XML、Java annotations或 JavaCode表示。组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p><p>讲解控制反转之前，我们先来思考一下：</p><ul><li><strong>谁控制谁，控制什么</strong>？</li></ul><p>传统JavaSE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是<strong>IoC容器控制了对象</strong>；控制什么？那就是主要控制了<strong>外部资源获取</strong>（不只是对象包括比如文件等）。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152049160.png"alt="image-20230228152049160" /><figcaption aria-hidden="true">image-20230228152049160</figcaption></figure><ul><li><strong>为何是反转，哪些方面反转了</strong>?</li></ul><p>有反转就有正转，传统应用程序是由<strong>我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象</strong>；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152120929.png"alt="image-20230228152120929" /><figcaption aria-hidden="true">image-20230228152120929</figcaption></figure><p>主动创建：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/spring-framework-ioc-1.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>IOC容器注入：</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/spring-framework-ioc-2.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，<strong>把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</strong>。</p></blockquote><h1 id="didependency-injection">3. DI—Dependency Injection</h1><p>即依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由<strong>容器动态的将某个依赖关系注入到组件之中。</strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><blockquote><p>控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p></blockquote><ul><li><strong>谁依赖谁？</strong></li></ul><p>在spring项目中，将对象理解为Bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，<strong>bean对象的创建是依赖容器的</strong></p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152658783.png"alt="image-20230228152658783" /><figcaption aria-hidden="true">image-20230228152658783</figcaption></figure><ul><li><strong>谁注入谁?</strong></li></ul><p>通过容器注入了bean对象，而且这个过程是自动化的，也就是说<strong>容器会自动找到和bean对象匹配的类型实例注入到对象中</strong>。</p><figure><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230228152243110.png"alt="image-20230228152243110" /><figcaption aria-hidden="true">image-20230228152243110</figcaption></figure><h1 id="ioc配置元数据configuration-metadata">4.<strong>IoC配置元数据(Configuration metadata)</strong></h1><p>容器通过读取配置元数据获取关于实例化、配置和组装什么对象的指令。配置元数据用XML、 Java 注释或 Java 代码表示。目前的主流方式是 <strong>注解 + Java配置</strong></p><blockquote><p>元数据(metadata)描述的是“自身”的一些信息，包括</p><p>ClassMetadata 描述的是class类的基本信息</p><p>AnnotationMetadata描述的是注解信息</p><p>MethodMetadata描述的是方法的信息</p></blockquote><h2 id="xml方式">4.1 XML方式</h2><p>顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。</p><ul><li><strong>优点</strong>：可以使用于任何场景，结构清晰，通俗易懂，所以xml方式是最全面的配置元数据的方式</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;userDao1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.dao.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>     <br>     <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;services.xml&quot;</span>/&gt;</span><br>     <span class="hljs-comment">&lt;!--使用一个或多个出现的 &lt; import/&gt; 元素从另一个文件加载 bean 定义前导斜杠被忽略，但是考虑到这些路径</span><br><span class="hljs-comment">相对的，最好不要使用斜杠--&gt;</span><br>     <br>     <span class="hljs-comment">&lt;!--使用Bean节点来创建对象id属性标识着对象，不能重复name属性代表着要创建对象的类全名--&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="java-配置">4.2Java 配置</h2><p>从 Spring 3.0开始，Spring JavaConfig 项目提供的许多特性成为核心Spring 框架的一部分。因此，您可以使用 Java 而不是 XML文件在应用程序类之外定义bean。要使用这些新特性，请参见@Configuration、<span class="citation"data-cites="bean">@bean</span>、<span class="citation"data-cites="import">@import</span> 和@DependsOn 注释</p><ol type="1"><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理</li></ol><blockquote><p><span class="citation"data-cites="Configuration注解声明为配置类">@Configuration注解声明为配置类</span>，<spanclass="citation"data-cites="Bean来修饰方法">@Bean来修饰方法</span>，该方法返回一个对象，容器中bean的ID默认为方法名（方法名建议与实例名相同（首字母小写）），Spring内部会将该对象加入到Spring容器中。</p></blockquote><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configuration</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> UserDao <span class="hljs-title function_">userDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br>        System.out.println(<span class="hljs-string">&quot;我是在configuration中的&quot;</span>+userDao);<br>        <span class="hljs-keyword">return</span> userDao;<br>    &#125;<br>     <br>    <span class="hljs-comment">//可以不写，默认为方法名</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserServiceImpl <span class="hljs-title function_">userService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.setUserDao(userDao());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Bird <span class="hljs-title function_">bird</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        bird.setBirdAge(<span class="hljs-number">18</span>);<br>        bird.setBirDid(<span class="hljs-string">&quot;1&quot;</span>);<br>        bird.setBirdName(<span class="hljs-string">&quot;小小鸟&quot;</span>);<br>        <span class="hljs-keyword">return</span> bird;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解方式">4.3 注解方式</h2><p>Spring 2.5引入了对基于注释的配置元数据的支持：<ahref="https://docs.spring.io/spring-framework/docs/5.0.x/spring-framework-reference/core.html#beans-annotation-config">Annotation-basedconfiguration</a>，使得我们可以通过简单的注解方式即可使用spring容器中的bean</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>           xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>       http://www.springframework.org/schema/beans/spring-beans.xsd<br>        http://www.springframework.org/schema/context<br>        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>    &lt;!--IoC的注解扫描--&gt;<br>    &lt;context:component-scan base-package=&quot;com.xxx.ioc.service, com.xxx.ioc.dao&quot;&gt;&lt;/context:component-scan&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>自定义扫描类以@CompoentScan修饰来扫描IOC容器的Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表明该类是配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;bb&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationScan</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>就可以在代码中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gogo</span><span class="hljs-params">(String data1,<span class="hljs-type">int</span> data2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.gogo&quot;</span>);<br>        userDao.sayHello(data1,data2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过注解把对象添加到IOC容器中，对象名默认首字母小写。注解方式注入在XML注入之前执行，因此对于通过两种方法连接的属性，后者的配置将覆盖前者。</p></blockquote><h1 id="依赖注入">5.依赖注入</h1><p>上述我们简单的讲述了如何向spring容器中注入bean对象。一个bean对象可以有自己的属性（基本数据类型或者引用数据类型），因此需要通过“<strong>依赖注入</strong>”将所需要的属性注入到目标对象中去。</p><p>举个例子：现在我们像IOC容器里注入一个自定义的bean，且我们为其注入值或者依赖。</p><p><strong>Dog：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String dogname;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dogage;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDogname</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dogname;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDogname</span><span class="hljs-params">(String dogname)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dogname = dogname;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDogage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dogage;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDogage</span><span class="hljs-params">(<span class="hljs-type">int</span> dogage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dogage = dogage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;dogname=&#x27;&quot;</span> + dogname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dogage=&quot;</span> + dogage +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="setter注入setter-injection">5.1 setter注入<strong>(SetterInjection)</strong></h2><p>setter注入也叫setter装配，本质是在xml里配置，然后通过setter方法给对象注入。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> data1;<br>    <span class="hljs-keyword">private</span> int data2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span>[] data3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; data4;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Integer</span>&gt; data5;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Dog</span>&gt; data6;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Dog</span> data7;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData6</span>(<span class="hljs-params">List&lt;Dog&gt; data6</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data6</span> = data6;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData5</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; data5</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data5</span> = data5;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData4</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; data4</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data4</span> = data4;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData3</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] data3</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data3</span> = data3;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> data1</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data1</span> = data1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData2</span>(<span class="hljs-params">int data2</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data2</span> = data2;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setData7</span>(<span class="hljs-params">Dog data7</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data7</span> = data7;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyBean1&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;data1=&#x27;&quot;</span> + data1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, data2=&quot;</span> + data2 +<br>                <span class="hljs-string">&quot;, data3=&quot;</span> + <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">toString</span>(data3) +<br>                <span class="hljs-string">&quot;, data4=&quot;</span> + data4 +<br>                <span class="hljs-string">&quot;, data5=&quot;</span> + data5 +<br>                <span class="hljs-string">&quot;, data6=&quot;</span> + data6 +<br>                <span class="hljs-string">&quot;, data7=&quot;</span> + data7 +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>在XML配置方式中</strong>，property都是setter方式注入，比如下面的xml:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--setter装配--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mybean1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.setter.MyBean1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;呵呵哒&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data3&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--String[]--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data4&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--List&lt;String&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data5&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--Map&lt;String, Integer&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;222333&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data6&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--List&lt;Dog&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Dog--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data7&quot;</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.setter.Dog&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;55&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itszt.ioc.setter.Dog&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot; 另一个接口/类 &quot;  ref=&quot;xx(另一个类的id) &quot;&gt;&lt;/property&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang222&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dogage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;888&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSetter</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config-setter.xml&quot;</span>);<br><br>        <span class="hljs-type">MyBean1</span> <span class="hljs-variable">mybean1</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;mybean1&quot;</span>, MyBean1.class);<br>        System.out.println(mybean1.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">31</span>:<span class="hljs-number">33</span>,<span class="hljs-number">050</span>  INFO XmlBeanDefinitionReader:<span class="hljs-number">317</span> - Loading XML bean definitions from <span class="hljs-keyword">class</span> <span class="hljs-title class_">path</span> resource [com/xxx/ioc/spring-config-setter.xml]<br>MyBean1&#123;data1=<span class="hljs-string">&#x27;呵呵哒&#x27;</span>, data2=<span class="hljs-number">123456</span>, data3=[hehe1, hehe2, hehe3, hehe4], data4=[haha1, haha2, haha3, haha4], data5=&#123;xx1=<span class="hljs-number">123456</span>, xx2=<span class="hljs-number">222333</span>&#125;, data6=[Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;, Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang222&#x27;</span>, dogage=<span class="hljs-number">888</span>&#125;], data7=Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="构造器注入constructor-injection">5.2 构造器注入（ConstructorInjection）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String data1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data2;<br>    <span class="hljs-keyword">private</span> String[] data3;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; data4;<br>    <span class="hljs-keyword">private</span> Map&lt;String,Integer&gt; data5;<br>    <span class="hljs-keyword">private</span> List&lt;Dog&gt; data6;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBean2</span><span class="hljs-params">(String data1, <span class="hljs-type">int</span> data2, String[] data3, List&lt;String&gt; data4, Map&lt;String, Integer&gt; data5, List&lt;Dog&gt; data6)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data1 = data1;<br>        <span class="hljs-built_in">this</span>.data2 = data2;<br>        <span class="hljs-built_in">this</span>.data3 = data3;<br>        <span class="hljs-built_in">this</span>.data4 = data4;<br>        <span class="hljs-built_in">this</span>.data5 = data5;<br>        <span class="hljs-built_in">this</span>.data6 = data6;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyBean2&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;data1=&#x27;&quot;</span> + data1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, data2=&quot;</span> + data2 +<br>                <span class="hljs-string">&quot;, data3=&quot;</span> + Arrays.toString(data3) +<br>                <span class="hljs-string">&quot;, data4=&quot;</span> + data4 +<br>                <span class="hljs-string">&quot;, data5=&quot;</span> + data5 +<br>                <span class="hljs-string">&quot;, data6=&quot;</span> + data6 +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>在XML配置方式中</strong>，<code>&lt;constructor-arg&gt;</code>是通过构造函数参数注入，比如下面的xml:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--构造器装配1--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mybean2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo.xx.MyBean2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;222333&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--构造器装配1--&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--构造器装配2--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mybean22&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo.xx.MyBean2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dahuang2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data3&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hehe4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data4&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>haha4<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data5&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xx2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;222333&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data6&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dog2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--构造器装配2--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>构造器赋初始值的时候，index=角标（指定索引还可以解决构造函数具有两个相同类型的参数时的不确定性。注意，索引是基于0的。）或者<strong>name="名称"</strong>这两种方式都可以赋初始值，属性为String和int在里面不用写<strong>""</strong></p><p>我们在上面通过<strong>index=角标</strong>和<strong>name="名称"</strong>分别额注入了不同的bean。</p><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>      ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config-constructor.xml&quot;</span>);<br>      <span class="hljs-type">MyBean2</span> <span class="hljs-variable">mybean2</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;mybean2&quot;</span>, MyBean2.class);<br>      System.out.println(mybean2.toString());<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>      ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;com/xxx/ioc/spring-config-constructor.xml&quot;</span>);<br>      <span class="hljs-type">MyBean2</span> <span class="hljs-variable">mybean22</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;mybean22&quot;</span>, MyBean2.class);<br>      System.out.println(mybean22.toString());<br>  &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">mybean2:MyBean2&#123;data1=<span class="hljs-string">&#x27;dahuang2&#x27;</span>, data2=<span class="hljs-number">123456</span>, data3=[hehe1, hehe2, hehe3, hehe4], data4=[haha1, haha2, haha3, haha4], data5=&#123;xx1=<span class="hljs-number">123456</span>, xx2=<span class="hljs-number">222333</span>&#125;, data6=[Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;, Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang222&#x27;</span>, dogage=<span class="hljs-number">888</span>&#125;]&#125;<br><br><br>mybean22:MyBean2&#123;data1=<span class="hljs-string">&#x27;dahuang2&#x27;</span>, data2=<span class="hljs-number">123456</span>, data3=[hehe1, hehe2, hehe3, hehe4], data4=[haha1, haha2, haha3, haha4], data5=&#123;xx1=<span class="hljs-number">123456</span>, xx2=<span class="hljs-number">222333</span>&#125;, data6=[Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang1&#x27;</span>, dogage=<span class="hljs-number">55</span>&#125;, Dog&#123;dogname=<span class="hljs-string">&#x27;dahuang222&#x27;</span>, dogage=<span class="hljs-number">888</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><h2 id="注解注入">5.3 注解注入</h2><p>也叫属性注入以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p><ul><li><strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</li><li><strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</li><li><strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</li></ul><blockquote><p>解释一下参数类型：java思想是一切皆对象，因此可以通过接口或者抽象类，父类等方式去标识一类。byType就是限定于同一种"参数类型"下。</p></blockquote><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="为什么推荐构造器注入方式">为什么推荐构造器注入方式？</h1><p>先来看看Spring在文档里怎么说：</p><blockquote><p>The Spring team generally advocates constructor injection as itenables one to implement application components as immutable objects andto ensure that required dependencies are not null. Furthermoreconstructor-injected components are always returned to client (calling)code in a fully initialized state.As a side note, a large number ofconstructor arguments is a bad code smell, implying that the classlikely has too many responsibilities and should be refactored to betteraddress proper separation of concerns.”</p></blockquote><p>简单的翻译一下：这个构造器注入的方式<strong>能够保证注入的组件不可变，并且确保需要的依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。与此同时，从代码质量的角度来看，一个巨大的构造方法通常代表着出现了代码异味，这个类可能承担了过多的责任。</p><p><strong>依赖不可变</strong>：其实说的就是final关键字。</p><p><strong>依赖不为空</strong>（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK。2：无该类型的参数-&gt;报错。</p><p><strong>完全初始化的状态</strong>：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</p><blockquote><p>在另一篇文章，详细的介绍了为什么推荐构造器注入方式？</p></blockquote><h1 id="read-more">6.Read more</h1><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc.html</p><h1 id="spring-core-ioc">1. Spring Core-IOC</h1><p>1.Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫<strong>控制反转- Inversion of Control (IoC)</strong></p><p>2.Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>IoCContainer</strong>;</p><p>3.Spring框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean？这便是xml配置，Java配置，注解配置</strong>等支持</p><p>4.Spring框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等；</p><p>5.应用程序代码从IocContainer中获取依赖的Bean，注入到应用程序中，这个过程叫<strong>依赖注入(Dependency Injection，DI)</strong> ；所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></p><p>6.在依赖注入时，有哪些方式呢？这就是构造器方式，<spanclass="citation" data-cites="Autowired">@Autowired</span>, <spanclass="citation" data-cites="Resource">@Resource</span>, <spanclass="citation" data-cites="Qualifier">@Qualifier</span>...同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖问题</strong>等）</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架介绍</title>
    <link href="/2022/05/10/framework/spring/2022-05-10_Spring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/10/framework/spring/2022-05-10_Spring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">1.背景</h1><p>在 Enterprise Java Beans (EJB) 出现之前，Java 开发人员需要使用JavaBeans 来创建 Web 应用程序。尽管 JavaBeans 有助于开发用户界面 (UI)组件，但它们无法提供开发健壮且安全的企业应用程序所需的服务，例如事务管理和安全性。EJB的出现被视为这个问题的解决方案 EJB 扩展了 Java 组件，例如 Web和企业组件，并提供有助于企业应用程序开发的服务。然而，使用 EJB开发企业应用程序并不容易，因为开发人员需要执行各种任务，例如创建 Home 和Remote 接口以及实现生命周期回调方法，这导致为 EJB提供代码的复杂性由于这种复杂性，</p><h1 id="spring框架">2. Spring框架</h1><h2 id="介绍">2.1 介绍</h2><p><code>Spring 框架（通常称为 Spring）的出现是为了解决所有这些复杂问题</code>。该框架使用各种新技术，例如面向方面的编程(AOP)、Plain Old Java Object (POJO) 和依赖注入 (DI)，开发企业应用程序，从而消除使用 EJB开发企业应用程序时涉及的复杂性<strong>，Spring是一个开源轻量级框架，它允许 Java EE开发人员构建简单、可靠和可扩展的企业应用程序。该框架主要侧重于提供各种方式来帮助我们管理我们的业务对象。与经典的Java 框架和应用程序编程接口 (API)（例如 Java 数据库连接(JDBC)、JavaServer Pages (JSP) 和 Java Servlet）相比，它使 Web应用程序的开发更加容易。</strong></p><p>Spring框架可以看成是子框架的集合，也叫层，比如Spring AOP。Spring对象关系映射（Spring ORM）。Spring Web Flow 和 Spring WebMVC。它是用于开发企业应用程序的轻量级应用程序框架。在构建 Web应用程序时，我们可以单独使用这些模块中的任何一个。这些模块也可以组合在一起以在Web 应用程序中提供更好的功能。由于依赖注入，Spring框架是松散耦合的。</p><blockquote><p>Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《<ahref="https://item.jd.com/68619611892.html">Expert One-on-One J2EEDesign andDevelopment</a>》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。</p></blockquote><h2 id="spring框架的演变">2.2 Spring框架的演变</h2><p>Spring Framework 于 2004 年首次发布，之后进行了重大的重大修订，如Spring 2.0 提供了 XML 命名空间和 AspectJ 支持，Spring 2.5提供了注解驱动的配置，Spring 3.0 提供了基于 Java 的@Configuration模型。spring 框架的最新版本是 4.0。它发布时支持 Java 8 和 Java EE 7技术。尽管我们仍然可以将 Spring 与旧版本的 java一起使用，但最低要求仅限于 Java SE 6。Spring 4.0 还支持 Java EE 7技术，例如 java 消息服务 (JMS) 2.0、java 持久性 API (JPA) 2.1、 Bean验证 1.1、servlet 3.1 和 JCache，如今spring已经来到了spring5.0。</p><h1 id="spring框架架构">3. Spring框架架构</h1><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/Spring-Framework-Architecture-1677156614942-1.png" /></p><p>Spring 框架由七个模块组成，如上图所示。这些模块是 <strong>SpringCore、Spring AOP、Spring Web MVC、Spring DAO、Spring ORM、Springcontext</strong> 和 <strong>Spring Webflow</strong>。这些模块提供了不同的平台来开发不同的企业应用程序；例如，你可以使用Spring Web MVC 模块来开发基于 MVC 的应用程序。</p><h2 id="spring-框架模块">3.1 Spring 框架模块</h2><ul><li><p><strong>Spring Core：</strong> SpringCore模块是Spring框架的核心组件，提供了IoC容器，Spring容器有两种实现方式，分别是bean工厂和应用上下文。Bean工厂是使用 org.springframework.beans.factory.BeanFactory接口定义的，充当 bean 的容器。Bean工厂容器允许我们将依赖项的配置和规范与程序逻辑分离。在 Spring框架中，Bean 工厂充当中央 IoC容器，负责实例化应用程序对象。它还配置和组装这些对象之间的依赖关系。BeanFactory接口有许多实现。XmlBeanFactory 类是 BeanFactory接口最常见的实现。</p></li><li><p><strong>Spring AOP ：</strong>与将应用程序分解为对象层次结构的面向对象编程 (OOP) 类似，AOP将程序分解为方面或关注点。Spring AOP 模块允许我们在 Spring AOP 中的Spring 应用程序中实现关注点或方面，这些方面是常规的 Spring bean 或使用<span class="citation" data-cites="Aspect">@Aspect</span>注释注释的常规类。这些方面有助于应用程序的事务管理和日志记录以及故障监控。例如，在银行操作中需要事务管理，例如将金额从一个帐户转移到另一个账户，Spring AOP 模块提供了一个可以应用于事务 API 的事务管理抽象层。</p></li><li><p><strong>Spring ORM</strong> ：</p><p>Spring ORM 模块用于从应用程序中的数据库访问数据。它提供用于使用JDO、Hibernate 和 iBatis 操作数据库的 API。Spring ORM 支持DAO，它提供了一种便捷的方式来构建以下基于 DAO 的 ORM 解决方案：</p><ul><li>简单的声明式事务管理</li><li>透明的异常处理</li><li>线程安全的轻量级模板类</li><li>DAO 支持类</li><li>资源管理</li></ul></li><li><p><strong>Spring Web MVC ：</strong> Spring 的 Web MVC模块实现了用于创建 Web 应用程序的 MVC 架构。它将 Web应用程序的模型和视图组件的代码分开。在 Spring MVC中，当从浏览器生成请求时，它首先转到 DispatcherServlet类（前端控制器），该类使用一组处理程序映射将请求分派给控制器（SimpleFormController类或 AbstractWizardformController类）。控制器提取并处理请求中嵌入的信息，并将结果以模型对象的形式发送给DispatcherServlet 类。最后，DispatcherServlet 类使用 ViewResolver类将结果发送到视图，视图将这些结果显示给用户。</p></li><li><p><strong>Spring Web Flow</strong> ：</p><p>Spring Web Flow 模块是 Spring Web MVC 模块的扩展。Spring Web MVC框架提供了表单控制器，如SimpleFormController类和AbstractWizardFormController 类，以实现预定义的工作流。Spring WebFlow 有助于定义管理 Web 应用程序不同页面之间工作流的 XML 文件或 Java类。Spring Web Flow是单独发布的，可以通过http://www.springframework.org网站下载。</p><p>以下是 Spring Web Flow 的优点：</p><ul><li>通过在 XML 文件中定义 Web 流，可以清楚地提供应用程序不同 UI之间的流。</li><li>Web流定义可帮助我们虚拟地将应用程序拆分为不同的模块，并在多种情况下重用这些模块。</li></ul></li><li><p><strong>Spring Web DAO ：</strong> Spring 框架中的 DAO包通过使用数据访问技术（如 JDBC、Hibernate 或 JDO）提供 DAO支持。该模块通过消除提供繁琐的 JDBC 编码的需要引入了 JDBC抽象层。它还提供编程式和声明式事务管理类。Spring DAO 包支持异构 Java数据库连接和 O/R 映射，这有助于 Spring使用多种数据访问技术。为了方便快捷地访问数据库资源，Spring框架提供了抽象的DAO基类。Spring框架支持的每种数据访问技术都有多种实现。例如，在 JDBC 中，JdbcDaoSupport类及其方法用于访问 DataSource 实例和预配置的 JdbcTemplate实例。</p></li><li><p><strong>Spring Context ：</strong> Spring Context基于核心模块。也就是我们常说的<code>ApplicationContext</code>，org.springframework.context.ApplicationContext是BeanFactory的一个接口。该模块的特性源自org.springframework.beans 包，还支持国际化(I18N)、验证、事件传播和资源加载等功能。Application 上下文实现MessageSource 接口并向应用程序提供消息传递功能。</p></li></ul><h1 id="spring组件">4.Spring组件</h1><p>Spring Framework 相关组件：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/spring-framework-introduce-8.png" /></p><h2 id="core-containerspring的核心容器">4.1 CoreContainer（Spring的核心容器）</h2><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core核心模块、Context 上下文模块和 SpEL表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web等上层的功能。具体介绍如下。</p><ul><li><p><strong>Beans模块</strong>：提供了框架的基础部分，包括控制反转[IOC]和依赖注入[DI]。</p></li><li><p><strong>Core 核心模块</strong>：封装了 Spring框架的底层部分，包括资源访问、类型转换及一些常用工具类。</p></li><li><p><strong>Context 上下文模块</strong>：建立在 Core 和 Beans模块的基础之上，集成 Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等。ApplicationContext接口是上下文模块的焦点。</p></li><li><p><strong>SpEL模块</strong>：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p></li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130162802973.png" /></p><h2 id="data-accessintegration数据访问集成">4.2 DataAccess/Integration（数据访问／集成）</h2><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions模块，具体介绍如下。</p><ul><li><strong>JDBC 模块</strong>：提供了一个 JDBC的样例模板，使用这些模板能消除传统冗长的 JDBC编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li><li><strong>ORM 模块</strong>：提供与流行的“对象-关系”映射框架无缝集成的API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring事务管理，无需额外控制事务。</li><li><strong>OXM 模块</strong>：提供了一个支持 Object /XML映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li><li><strong>JMS 模块</strong>：指 Java 消息服务，提供一套“消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li><li><strong>Transactions事务模块</strong>：支持编程和声明式事务管理。</li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130162935159.png" /></p><h2 id="web模块">4.3 Web模块</h2><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Webflux组件，具体介绍如下。</p><ul><li><strong>Web 模块</strong>：提供了基本的 Web开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC容器初始化以及 Web 应用上下文。</li><li><strong>Servlet 模块</strong>：提供了一个 Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP 标签，完全无缝与 Spring 其他技术协作。</li><li><strong>WebSocket模块</strong>：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建WebSocket Server，从而实现双向通讯。</li><li><strong>Webflux 模块</strong>： Spring WebFlux 是 Spring Framework5.x中引入的新的响应式web框架。与Spring MVC不同，它不需要ServletAPI，是完全异步且非阻塞的，并且通过Reactor项目实现了ReactiveStreams规范。Spring WebFlux用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</li></ul><p>此外Spring4.x中还有Portlet 模块，在Spring 5.x中已经移除</p><ul><li><strong>Portlet 模块</strong>：提供了在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。</li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130163141867.png" /></p><h2 id="aopaspectsinstrumentation和messaging">4.4AOP、Aspects、Instrumentation和Messaging</h2><p>在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p><ul><li><strong>AOP模块</strong>：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li><li><strong>Aspects 模块</strong>：提供与 AspectJ的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li><strong>Instrumentation模块</strong>：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li><strong>messaging 模块</strong>：Spring 4.0以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li><li><strong>jcl 模块</strong>： Spring5.x中新增了日志框架集成的模块。</li></ul><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130163330973.png" /></p><h2 id="test模块">4.5 Test模块</h2><p>Test 模块：Spring 支持 Junit 和 TestNG测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web框架时，模拟 Http 请求的功能。</p><p>包含Mock Objects, TestContext Framework, Spring MVC Test,WebTestClient。</p><p>对应的源码模块如下：</p><hr /><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/image-20230130163426380.png" /></p><blockquote><p>这也印证了前面所说的观点：Spring框架是松散耦合的，可以看成是子框架的集合</p></blockquote><h1 id="为什么要使用spring">5.为什么要使用Spring</h1><p>最重要的体现在它能做什么，这是Spring的核心所在:</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/spring-framework-introduce-0.png" /></p><p>官方对此专门对此做了详细介绍，感兴趣可以看下</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/Spring-guides/spring-framework-introduce-01.png" /></p><h1 id="如何学习spring">6.如何学习spring?</h1><p>非常负责任的告诉你，最好最全的资料在Spring的官网，Spring能成为最主要的企业开发框架，文档和生态体系也做的很好，在学习Spring时，一定要把它当做生态体系，而是不是一个简单的开发框架。如下是Spring相关地址：</p><ul><li><p>Spring官方网站：<ahref="http://www.springframework.org/">http://www.springframework.org</a></p></li><li><p>Spring 官方各个版本文档：<ahref="https://docs.spring.io/spring-framework/docs/">https://docs.spring.io/spring-framework/docs/</a></p></li><li><p>Github地址：<ahref="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p></li></ul><h1 id="read-more">7.Read more</h1><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-introduce.html</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架介绍</title>
    <link href="/2022/05/10/framework/spring/2022-05-27_Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <url>/2022/05/10/framework/spring/2022-05-27_Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="bean实例化循环依赖">1.Bean实例化、循环依赖</h1><h2 id="什么是循环依赖">1.1 什么是循环依赖？</h2><p>如下有 A、B、C三个类，可以看到发生了循环依赖：<code>彼此互相依赖，导致各自都需要对方的依赖，形成依赖闭环。</code></p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230302103233180.png" /></p><p>但是我们会发现field属性注入、setter方法注入的循环依赖：<code>即使发生了循环依赖，我们依然可以启动，使用并没有任何影响。</code>这种方式是我们最为常用的依赖注入方式，Spring会解决<code>field属性注入、setter方法注入</code>的循环依赖。但是无法解决构造器注入的循环依赖。</p><p>Spring IoC容器会在运行时检测到<strong>构造函数</strong>注入循环引用，并抛出<code>BeanCurrentlyInCreationException</code>。从而提醒你避免循环依赖。所以要避免构造函数注入，可以使用setter 注入替代。根据官方文档说明，Spring 会自动解决基于 setter注入的循环依赖。当然在咱们工作中现在都使用 <span class="citation"data-cites="Autowired">@Autowired</span> 注解来注入属性。 <spanclass="citation" data-cites="Autowired">@Autowired</span>是通过反射进行赋值。</p><p>依赖注入的方式：</p><ol type="1"><li>注解注入：<span class="citation"data-cites="Autowire和">@Autowire和</span><span class="citation"data-cites="Resource">@Resource</span>：这种注解可以直接解决循环依赖问题，不需要额外处理</li><li>构造方法器注入：构造方法注入需要使用@Lazy注解来作用于循环依赖的属性</li><li>setter注入：setter注入也可以直接解决循环依赖问题，不需要额外处理</li></ol><blockquote><p>Spring只是解决了单例模式下属性依赖的循环问题；Spring为了解决单例的循环依赖问题，使用了三级缓存。</p></blockquote><h1 id="spring的循环依赖">2.Spring的循环依赖</h1><p>现在有循环依赖代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServiceB serviceB;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceB</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServiceA serviceA;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论先创建ServiceA还是ServiceB时，都会发生循环依赖！</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/format,png.png" /></p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自己依赖自己</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServiceA serviceA;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自己依赖自己其实也是循环依赖的一种</p></blockquote><h2 id="实例化与初始化">2.1 实例化与初始化</h2><p>在介绍spring如何解决循环依赖前，我们必须先了解一个完整的对象其实包含两部分：当前对象实例化和对象属性的实例化：</p><ul><li><p><strong>类的实例化：</strong></p><p>是指创建一个对象的过程。这个过程中会在堆中开辟内存，将一些<strong>非静态</strong>的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。（就是调用构造函数，生成一个对象。）</p></li><li><p><strong>类的初始化：</strong></p></li></ul><p>是完成程序执行前的准备工作。在这个阶段，<strong><em>*静态的*</em></strong>（变量，方法，代码块）会被执行。同时在会开辟一块存储空间用来存放静态的数据。初始化只在类加载的时候执行一次（为变量设置值）</p><p>这个过程可以按照如下方式进行理解：</p><blockquote><p>在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。</p></blockquote><h2 id="解决循环依赖">2.2 解决循环依赖</h2><p>在spring中，通过三级缓存来解决循环依赖的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton objects: bean name --&gt; bean instance（一级缓存，存储单例对象，Bean 已经实例化，初始化完成） */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="hljs-number">64</span>);<br><br><span class="hljs-comment">/** Cache of early singleton objects: bean name --&gt; bean instance（二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化） */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory（三级缓存，单例的工厂Bean缓存集合） */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, ObjectFactory&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Names of beans that are currently in creation 正在创建的对象*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =<br>Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><br></code></pre></td></tr></table></figure><ul><li><p>「<strong>singletonObjects</strong>」：缓存某个 beanName对应的经过了完整生命周期的bean；</p></li><li><p>「<strong>earlySingletonObjects</strong>」：缓存提前拿原始对象进行了AOP 之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcesso r等生命周期；</p></li><li><p>「<strong>singletonFactories</strong>」：缓存的是一个ObjectFactory ，主要用来去生成原始对象进行了AOP之后得到的「代理对象」，在每个 Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本 bean 按照自己的生命周期执行，执行完后直接把本bean 放入 singletonObjects 中即可，如果出现了循环依赖依赖了本bean，则另外那个 bean 执行 ObjectFactory 提交得到一个 AOP之后的代理对象（如果有 AOP 的话，如果无需 AOP，则直接得到一个原始对象</p></li></ul><p>spring容器的实现从根源上来看的话是通过<code>BeanFactory</code>实现的，但是<code>BeanFactory</code>只是一个接口类，真正作为一个可以独立使用的容器还是通过<code>DeafultListableBeanFactory</code>实现的，<code>DefaultListableBeanFactory</code>结构图解：</p><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230302114741837.png" /></p><h1 id="源码角度">3.源码角度</h1><h2 id="defaultlistablebeanfactory的preinstantiatesingletons方法">3.1<strong>DefaultListableBeanFactory的preInstantiateSingletons方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   ... ...<br>   List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>   <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>   <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>      <span class="hljs-comment">//获取指定名称的Bean定义</span><br>      <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>      <span class="hljs-comment">//Bean不是抽象的，是单态模式的，且lazy-init属性配置为false</span><br>      <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>        ... ...<br>            <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>               <span class="hljs-comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程</span><br>               getBean(beanName);<br>            &#125;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>            getBean(beanName);<br>         &#125;<br>      &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>最终都会调用<code>getBean</code>方法，触发容器对Bean实例化和依赖注入过程。<code>getBean</code>方法是在<code>Beanfactory</code>中的一个接口，由<code>AbstractBeanFactory</code>实现，执行<code>doGetBean</code>方法，在Spring中，凡是以do开头的方法一般都是细节上的逻辑处理，也就是具体的实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取IOC容器中指定名称的Bean</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span><br>   <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在spring中，想要使用对象最终都会调用<code>AbstractBeanFactory</code>的<code>getBean()</code>方法，进而执行<code>doGetBean()</code>方法。</p><p>在spring中，凡是以do开头的方法一般都是细节上的逻辑实现，所以在<code>doGetBean()</code>中执行了<code>DefaultSingletonBeanRegistry</code>的<code>getSingleton()</code>方法。</p></blockquote><h2 id="abstractbeanfactory的dogetbean方法">3.2<strong>AbstractBeanFactory的doGetBean方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType, <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>        <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//1、转换beanName，返回 bean 名称，必要时去除工厂取消引用前缀，并将别名解析为规范名称</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    Object bean;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 有缓存，如果指定名称的Bean在容器中已有单例模式的Bean被创建。直接返回已经创建的Bean</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ... ...<br>        <span class="hljs-comment">// Check if bean definition exists in this factory.</span><br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// 父 factory 里加载</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">//2、转换成RootBeanDefinition</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        checkMergedBeanDefinition(mbd, beanName, args);<br><br>        <span class="hljs-comment">//依赖，先不考虑</span><br>        String[] dependsOn = mbd.getDependsOn();<br>        <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//...</span><br>        &#125;<br><br>        <span class="hljs-comment">// Create bean instance.</span><br>        <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>            <span class="hljs-comment">//3、关键：单例类的初始化</span><br>            sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                        <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>                        <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>                        <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>            <span class="hljs-comment">//prototype ...</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他scope ...</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><br>    <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; bean != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;<br>        <span class="hljs-comment">// 如果类型不一致，做类型转换</span><br>        <span class="hljs-keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="defaultsingletonbeanregistry的getsingletonstring-beanname-boolean-allowearlyreference">3.3DefaultSingletonBeanRegistry的getSingleton(String beanName， booleanallowEarlyReference)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">----&gt; <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getSingleton(beanName);<br><br><span class="hljs-comment">//返回在给定名称下注册的（原始）单例对象。 &lt;p&gt;检查已经实例化的单例，并允许提前引用当前创建的单例（解决循环引用）</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>   <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>   <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>          <span class="hljs-comment">/** </span><br><span class="hljs-comment">          * 如果singletonObjects还没有此bean，有两种情况</span><br><span class="hljs-comment">          * 1.这个bean正在创建状态，先从earlySingletonObjects获取</span><br><span class="hljs-comment">          * 2.这个bean还没开始创建</span><br><span class="hljs-comment">          */</span><br>         singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>         <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>              <span class="hljs-comment">/** </span><br><span class="hljs-comment">             * 如果earlySingletonObjects还没有此bean，有两种情况</span><br><span class="hljs-comment">             * 1.说明还未被其他bean注入，正在创建状态，先从singletonFactories获取</span><br><span class="hljs-comment">             * 2.该bean还没开始创建</span><br><span class="hljs-comment">             */</span><br>            ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>            <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                *将此bean放到提前缓存到earlySingletonObjects中</span><br><span class="hljs-comment">                * 从singletonObject删除bean</span><br><span class="hljs-comment">                */</span><br>               singletonObject = singletonFactory.getObject();<br>               <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>               <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法做了这么一件事，</p><ol type="1"><li><p>先到singletonObjects中获取，如果有表示实例化已经完成；</p></li><li><p>否则到earlySingletonObjects获取，如果有表示已经有bean，且存在循环依赖，将此bean作为属性注入了</p></li><li><p>否则到singletonFactories获取，如果存在循环依赖，且此属性是第一次被其他bean作为属性</p></li></ol><h2id="defaultsingletonbeanregistry的getsingletonstring-beanname-objectfactory-singletonfactory">3.4DefaultSingletonBeanRegistry的getSingleton(String beanName,ObjectFactory&lt;?&gt; singletonFactory)</h2><p>上面的代码主要就是执行一些条件判断，重要的是单例类的getSingleton()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Create bean instance.</span><br>      <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>          <span class="hljs-comment">//3、关键：单例类的初始化</span><br>          sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                  &#125;<br>                  <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                      <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>                      <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>                      <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                      destroySingleton(beanName);<br>                      <span class="hljs-keyword">throw</span> ex;<br>                  &#125;<br>              &#125;<br>          &#125;);<br>          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>      &#125;<br></code></pre></td></tr></table></figure><p>其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">---&gt; sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;()<br>                                   <br><span class="hljs-comment">//返回以给定名称注册的（原始）单例对象，如果尚未注册，则创建并注册一个新对象  </span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br> Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>      <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>         ... ...<br>         beforeSingletonCreation(beanName);<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">newSingleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">recordSuppressedExceptions</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.suppressedExceptions == <span class="hljs-literal">null</span>);<br>         <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>            <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>         &#125;<br>         <span class="hljs-keyword">try</span> &#123;<br>            singletonObject = singletonFactory.getObject();<br>            newSingleton = <span class="hljs-literal">true</span>;<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (<br>             ... ...<br>         &#125;<br>         <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>               <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>            &#125;<br>            afterSingletonCreation(beanName);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>            addSingleton(beanName, singletonObject);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> singletonObject;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个getSingleton中，还会再去从一级缓存中获取一次，如果有则直接返回，没有则在<code>beforeSingletonCreation</code>将要创建的对象存入set 集合中。同理，还有<code>afterSingletonCreation</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Singleton &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; isn&#x27;t currently in creation&quot;</span>);<br>   &#125;<br>&#125;<br>-----&gt;<br><span class="hljs-comment">//当前正在创建的bean的名称</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =<br>      Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><blockquote><p>由此可知：创建的时候存在singletonsCurrentlyInCreation队列里，创建成功则被移除。</p></blockquote><p>最后回到在3.4第一哥代码块中执行下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> createBean(beanName, mbd, args)<br></code></pre></td></tr></table></figure><p>方法中进行Bean的创建，<strong>AbstractAutowireCapableBeanFactory</strong>中的createBean方法。</p><h2 id="abstractautowirecapablebeanfactory的createbean方法">3.5AbstractAutowireCapableBeanFactory的createBean方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>      <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>   ... ...<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//创建Bean的入口</span><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>         logger.debug(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> beanInstance;<br>   &#125;<br>   ... ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abstractautowirecapablebeanfactory的docreatebean">3.6AbstractAutowireCapableBeanFactory的doCreateBean</h2><p>主要是进行了一些判断处理，重要方法就是其中的doCreateBean，里面是执行创建对象的细节.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//真正创建Bean的方法</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>      <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>   <span class="hljs-comment">// Instantiate the bean.</span><br>   <span class="hljs-comment">//封装被创建的Bean对象</span><br>   <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>      instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>   &#125;<br>   <span class="hljs-comment">//createBeanInstance----&gt;//创建Bean的实例对象,返回BeanWrapper</span><br>   <span class="hljs-comment">//protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;&#125;</span><br>    <br>   <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>      instanceWrapper = createBeanInstance(beanName, mbd, args);<br>   &#125;<br>   <span class="hljs-comment">//得到bean</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>   ... ...<br>   <br>   <span class="hljs-comment">//判断是否有循环依赖，是否需要暴露对象的引用</span><br>   <span class="hljs-comment">/* Eagerly cache singletons to be able to resolve circular references</span><br><span class="hljs-comment">    *even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="hljs-comment">    * 向容器中缓存单例模式的Bean对象，以防循环引用</span><br><span class="hljs-comment">    * 单例 </span><br><span class="hljs-comment">    * 允许循环依赖</span><br><span class="hljs-comment">    * 当前Bean正在创建中,检测到了循环依赖</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>         isSingletonCurrentlyInCreation(beanName));<br>   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>     ... ...<br>      <span class="hljs-comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span><br>      <span class="hljs-comment">//getEarlyBeanReference方法作用：获取对指定bean的早期访问的引用，通常用于解析循环引用</span><br>      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>   &#125;<br><br>   <span class="hljs-comment">// Initialize the bean instance.</span><br>   <span class="hljs-comment">//Bean对象的初始化，依赖注入在此触发</span><br>   <span class="hljs-comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象</span><br>      populateBean(beanName, mbd, instanceWrapper);<br>      <span class="hljs-comment">//初始化Bean对象</span><br>      exposedObject = initializeBean(beanName, exposedObject, mbd);<br>   &#125;<br>   ... ...<br>   <br>   <span class="hljs-comment">// Register bean as disposable.</span><br>   <span class="hljs-comment">//注册完成依赖注入的Bean</span><br>   <span class="hljs-keyword">try</span> &#123;<br>      registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的addSingletonFactory方法：判断是否是循环引用，是的话执行下面方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">---&gt; addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>   Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br>          <span class="hljs-comment">//添加到三级缓存</span><br>         <span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br>         <span class="hljs-comment">//消除此Bean在二级缓存里的缓存信息</span><br>         <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>         <span class="hljs-comment">//这里为了记录注册单例的顺序</span><br>         <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>消除此Bean在二级缓存里的缓存信息，将其包装成singletonFactory实例往三级缓存里添加，判断是否是循环引用，是的话需要添加到三级缓存中。</p><p>这里有一个重点就是Spring解决循环依赖的真相就在这一段源码中：在这里beanFactory被put进了singletonFactories，此时的bean只是完成了初始化构造的bean，还没有进行set或者注解注入的bean，是bean的一个中间状态，但是已经能被识别出来了，所以Spring此时将这个对象提前曝光出来让大家认识、使用。</p></blockquote><p>在3.3 节中，getSingleton(String beanName, booleanallowEarlyReference) 方法中，如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) <br></code></pre></td></tr></table></figure><p>则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*将此bean放到提前缓存到earlySingletonObjects中</span><br><span class="hljs-comment">* 从singletonObject删除bean</span><br><span class="hljs-comment">*/</span><br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br></code></pre></td></tr></table></figure><h1 id="spring循环依赖解决">4.Spring循环依赖解决</h1><p><imgsrc="http://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/framework/spring/spring/image-20230302103233180.png" /></p><p>以上面为例子，<strong>A</strong>在<code>DefaultListableBeanFactory</code>的<code>preInstantiateSingletons</code>中，调用<code>AbstractBeanFactory</code>的getBean方法，然后调用doGetBean方法，进入方法的时候会调用getSingleton方法，会进行如下判断：</p><ul><li>先到singletonObjects中获取，如果有表示实例化已经完成；</li><li>到earlySingletonObjects获取，如果没有则找三级缓存，如果有表示已经有bean，且存在循环依赖，返回对象。</li><li>到singletonFactories获取，如果有则返回对象，且将对象存入二级缓存，三级缓存将此对象清除。</li></ul><p>此处<strong>A</strong>在这三个缓存中都获取不到，然后就创建对象，在创建的时候还会再去从一级缓存中获取一次，如果有则直接返回，没有则先在<code>beforeSingletonCreation</code>将要创建的对象存入set集合中，因此是不可重复的，然后执行<strong>AbstractAutowireCapableBeanFactory</strong>中的createBean方法中的doCreateBean方法，所有的对象都封装成BeanWrapper对象，通过BeanWrapper的.getWrappedInstance()得到具体的实例，然后再根据条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>      isSingletonCurrentlyInCreation(beanName));<br></code></pre></td></tr></table></figure><p>是否从二级缓存移除，存入三级缓存，此处<strong>A</strong>已经存入三级缓存。</p><p><strong>B</strong>的过程和 <strong>A</strong>的一样，也是创建了三级缓存，然后去创建<strong>C</strong>，同理，<strong>C</strong>也进入三级缓存，这时候三级缓存里面有它们三个的singletonFactory 。<strong>C</strong> 也调用到 doGetBean 方法去获取<strong>A</strong>.</p><blockquote><p>填充属性ServiceA的时候，这时候能够从三级缓存中拿到半成品的ObjectFactory，拿到ObjectFactory对象后，调用ObjectFactory.getObject()方法最终会调用getEarlyBeanReference()方法，getEarlyBeanReference这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是beanProxy对象，如果未被代理则返回的是原bean实例。</p></blockquote><p>不过这次<strong>C</strong>调用到 Object sharedInstance =getSingleton(beanName); 的时候, <strong>A</strong>已经存在了。这次调用虽然没有从一级缓存 （singletonObjects） 中获取到A，但是 <strong>A</strong>在<strong>创建中</strong>，所以进入判断在这里执行完之后，<strong>A</strong>从三级缓存升级到二级缓存。</p><blockquote><p>这里获取到的是 <strong>A</strong> 的引用，注意 <strong>A</strong>这时候还没创建完成，只是引用。所以这里赋值的是 <strong>A</strong>的引用。</p></blockquote><p>填充属性的时候，spring会提前将已经实例化的bean通过ObjectFactory半成品暴露出去，<strong>为什么称为半成品是因为这时候的bean对象实例化，但是未进行属性填充，是一个不完整的bean实例对象</strong>，这时我们会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存earlySingletonObjects中，而此时<strong>C</strong>注入的是一个半成品的实例<strong>A</strong>对象，不过随着<strong>C</strong>初始化完成后，A会继续进行后续的初始化操作，最终<strong>C</strong>会注入的是一个完整的<strong>A</strong>实例，因为在内存中它们是同一个对象。</p><p>到这里 <strong>C</strong> 就创建完了。如上所示，<strong>C</strong>创建完成之后，会执行addSingleton方法，然后会将 <strong>C</strong>添加到一级缓存和已注册列表中，同时从二级三级缓存中删除 C。继续执行<strong>B</strong> 和 <strong>A</strong>的属性赋值以及后续的初始化流程。最后 <strong>B</strong> 和<strong>A</strong> 都进入一级缓存。至此，循环依赖解决完毕。</p><blockquote><p>对于“prototype”作用域bean, Spring 容器无法完成依赖注入，因为Spring容器不进行缓存“prototype”作用域的bean ，因此无法提前暴露一个创建中的bean。</p></blockquote><h1 id="半成品bean">5.半成品"Bean"</h1><p>半成品的bean可能不太理解，我们可以看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String number;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(student);<br><br>        student.setNumber(<span class="hljs-string">&quot;01&quot;</span>);<br>        student.setAge(<span class="hljs-string">&quot;18&quot;</span>);<br>        student.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        System.out.println(student);<br>    &#125;<br><br>---&gt;<br>com.example.demo.aaa.Student@36baf30c<br>com.example.demo.aaa.Student@36baf30c<br></code></pre></td></tr></table></figure><p>如上，打印的地址是一样的，第一次打印的就是所谓的"<strong>半成品</strong>"。虽然它此时的属性没有赋值，但是它是可以使用（被别人引用）的半成品。在最终使用的时候，它经过一系列执行，注入的就是成熟的bean对象。</p><h1id="为什么要使用三级缓存仅仅使用二级缓存行吗">6.为什么要使用三级缓存，仅仅使用二级缓存行吗？</h1><p>使用 earlySingletonObjects 和 singletonObjects两级缓存，一个存放早期对象，一个存放初始化完成后的对象，也能实现同样的功能，singletonFactories好像显得有些多此一举。其实不是的，对于普通对象，确实只要返回刚创建完的早期对象就好了，二级缓存已经可以解决循环依赖。</p><p>但如果A 的原始对象进行了 AOP 产生了一个代理对象，此时就会出现，对于 A而言，如果仅有二级缓存，它的 Bean 对象其实应该是 AOP之后的代理对象，而此时的B 的 a 属性对应的并不是 AOP之后的代理对象，这就产生了冲突：<strong>B 依赖的 A 和最终的 A不是同一个对象</strong>，因此才出现三级缓存，singletonFactories（三级缓存） 根据 beanName 得到一个 ObjectFactory，然后执行 ObjectFactory ，也就是执行 getEarlyBeanReference方法，此时会得到一个 A 原始对象经过 AOP之后的代理对象，然后把该代理对象放入 earlySingletonObjects中。后续为B所用，此时得到的A都是代理对象。</p><p>链接：https://segmentfault.com/a/1190000023647227</p><p>总结：</p><blockquote><p>Spring 的设计原则是在 <strong>Bean初始化完成之后才为其创建代理，</strong>如果只有二级缓存，这样违背了Spring设计原则。Spring结合AOP跟Bean的生命周期，是在Bean创建完全之后----通过AnnotationAwareAspectJAutoProxyCreator这个---后置处理器来完成的，在这个后置处理的postProcessAfterInitialization方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。<strong>Spring需要三级缓存的目的是为了在没有循环依赖的情况下，延迟代理对象的创建，使Bean 的创建符合 Spring 的设计原则。</strong></p></blockquote><h1id="为什么spring无法解决构造器的循环依赖">7.为什么Spring无法解决构造器的循环依赖？</h1><p>在spring中，springIOC容器在运行时检测到构造函数注入循环依赖则直接抛出异常，因此要避免构造器的循环依赖而使用setter注入。spring也会自动解决基于setter注入的循环依赖。</p><blockquote><p>Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化，但还没初始化的状态。而构造器是完成实例化的，所以构造器的循环依赖Spring并没有解决，bean都是需要可以先被实例化才可以的，所以这也就是为什么构造器依赖可能会失败的原因。假如A构造器依赖B，因为实例化A需要先调用A的构造函数，发现依赖B，那么需要去初始化B，但是B也依赖A，不管B是通过构造器注入还是setter注入，此时由于A没有被实例化，没有放入三级缓存，所以B无法被初始化，所以spring会直接报错。反之，如果A通过setter注入的话，那么则可以通过构造函数先实例化，放入缓存，然后再填充属性，这样的话不管B是通过setter还是构造器注入A，都能在缓存中获取到，于是可以初始化。</p><p><strong>解决办法：</strong></p><p>​Spring构造器注入循环依赖的解决方案是@Lazy，其基本思路是：对于强依赖的对象，一开始并不注入对象本身，而是注入其代理对象，以便顺利完成实例的构造，形成一个完整的对象，这样与其它应用层对象就不会形成互相依赖的关系；当需要调用真实对象的方法时，通过TargetSource去拿到真实的对象[DefaultListableBeanFactory#doResolveDependency]，然后通过反射完成调用</p></blockquote><h1id="什么情况下循环依赖可以被处理">8.什么情况下循环依赖可以被处理？</h1><p>首先要明确一点，Spring解决循环依赖是有前置条件的</p><ol type="1"><li>出现循环依赖的Bean必须要是单例</li><li>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</li></ol><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceA</span><span class="hljs-params">(ServiceB b)</span>&#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceB</span> &#123;<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceB</span><span class="hljs-params">(ServiceA a)</span>&#123;<br>     <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：</p><blockquote><p>Caused by:org.springframework.beans.factory.BeanCurrentlyInCreationException:Error creating bean with name 'a': Requested bean is currently increation: Is there an unresolvable circular reference?</p></blockquote><p>如下四种情况的循环依赖测试</p><table><thead><tr class="header"><th style="text-align: left;">依赖情况</th><th style="text-align: left;">依赖注入方式</th><th style="text-align: left;">循环依赖是否被解决</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用setter方法注入</td><td style="text-align: left;">是</td></tr><tr class="even"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用属性自动注入</td><td style="text-align: left;">是</td></tr><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用构造器注入</td><td style="text-align: left;">否</td></tr><tr class="even"><td style="text-align: left;">AB相互依赖（循环依赖）</td><tdstyle="text-align: left;">A中注入B的方式为setter方法，B中注入A的方式为构造器</td><td style="text-align: left;">是</td></tr><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><tdstyle="text-align: left;">B中注入A的方式为setter方法，A中注入B的方式为构造器</td><td style="text-align: left;">否</td></tr></tbody></table><blockquote><p>不是只有在setter方法注入的情况下循环依赖才能被解决，即使存在构造器注入的场景下，循环依赖依然被可以被正常处理掉。</p><p>所以日常所说的只解决setter注入方式是错误的。spring解决循环依赖是不能全是构造器注入的方式。</p></blockquote><p><strong>为什么在下表中的第四种情况的循环依赖能被解决，而第五种情况不能被解决呢？</strong></p><p>是因为Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建，A会首先暴露出来。然后才回去注入B，B再注入A的时候，就可以通过三级缓存拿到A了。此时的A是一个实例化的一个中间状态的Bean.</p><p>反之：如果使用如果A先使用构造器，在注入的时候，他会去找B，B再注入A，可此时A并没有暴露(因为还没有实例化成功)，也就失败了。</p><h1 id="read-more">9.Read more</h1><p>:lollipop::https://developer.aliyun.com/article/766880</p><p>:lollipop::https://juejin.cn/post/6985337310472568839</p><p>:lollipop::https://segmentfault.com/a/1190000023647227</p><p>:lollipop::https://blog.csdn.net/weixin_48777366/article/details/123645686</p><p>:lollipop::https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html</p><p>:lollipop::https://www.zhihu.com/question/438247718/answer/1730527725</p><p>:lollipop::https://juejin.cn/post/6844903843596107790</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SM.MS、GitHub、OSS搭建图床</title>
    <link href="/2022/05/05/build_blog/2022-05-05_%E4%BD%BF%E7%94%A8SM.MS%E3%80%81GitHub%E3%80%81OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2022/05/05/build_blog/2022-05-05_%E4%BD%BF%E7%94%A8SM.MS%E3%80%81GitHub%E3%80%81OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Markdown写文章一定绕不开一个问题：图片，我们插入的Blog的图片都是指向的是本地的路径。如果改变了本地图片存储的位置，MarkDown所引用的图片就无法显示，因此我们需要一个图床来存放我们的图片。</p><p>常用的图床有<code>SM.MS</code>、<code>OSS云服务</code>、<code>七牛云</code>、<code>GitHub</code>等等。</p><h1 id="使用sm.mspicgo搭建免费图床">1.使用SM.MS、PicGo搭建免费图床</h1><p><code>SM.MS</code>个人有免费的5g容量。对于我们写Blog是够用的。</p><h2 id="注册sm.ms图床">1.注册SM.MS图床</h2><p>我们访问<ahref="https://sm.ms/">SM.MS</a>注册自己的账户，就可以使用图床了。整体页面如下：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.25.01.jpg" /></p><h2 id="配置图床">2.配置图床</h2><p>我们希望在写MarkDown的时候，插入图片到MarkDown的时候，就自动将图片上传到图床，不用我们自己手动将图片上传到图床后，再手动插入图片链接。因此我们可以使用<ahref="https://github.com/PicGo/Awesome-PicGo">PicGo</a>，一个用于快速上传图片并获取图片URL 链接的工具。</p><p><strong>配置API Token</strong></p><p>在<code>SM.MS</code>网址左侧，点击<code>API Token</code>，复制Token到下图位置。PicGo就可以将图片上传到我们的图床上。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.25.26.jpg" /></p><p><strong>MarkDown开启图片自动上传</strong></p><p>此时我们可以将图片拖拽到<code>PicGo</code>图标里获取到<code>SM.MS</code>返回的图片链接，然后再复制到我们的文件里，这是比较麻烦的。因此我们需要在MarkDown编辑工具里开启选项。我使用的<ahref="https://www.typora.net/">Typora</a>，因此在设置中找到<code>图像</code>，将规则设置为<code>上传图片</code>，由于我使用的是<code>PicGo</code>，因此上传服务选择的是<code>PicGo.app</code>。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.25.43.jpg" /></p><h1id="使用githubjsdelivrpicgo搭建免费图床">2.使用Github、jsdelivr、PicGo搭建免费图床</h1><h2 id="创建图床工程">1.创建图床工程</h2><p>新建一个project，自定义名称即可。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.09.29.jpg" /></p><h2 id="配置personal-access-tokens">2.配置Personal access tokens</h2><p>用户栏目下面的<code>Setting</code>。拉到页面最下方，点击<code>&lt;&gt; Developer settings</code> 然后再点击<code>Personal access tokes</code>，在<code>Select scopes</code>选项中勾选<strong>repo</strong>，生成accesstoken。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.09.54.jpg" /></p><blockquote><p>注意：这个token只显示一次，所以一定要自己保管好</p></blockquote><h2 id="picgo配置github">3.PicGo配置GitHub</h2><p>由于GitHub在国外，导致网速会比较慢，因此夹在图片这种大文件会比较慢。我们的<ahref="https://www.jsdelivr.com/">jsdelivr</a>便出现了，jsDelivr是一个免费开源的 CDN 解决方案。包含 JavaScript 库、jQuery 插件、CSS框架、字体等等 Web 上常用的静态资源。</p><p>重要的是jsDelivr在中国大陆也拥有超过数百个节点，因为jsDelivr拥有正规的ICP备案，解决了中国大陆的访问速度优化，实现真正的全球极速低延迟体验。</p><p>jsDelivr是免费的、不限制带宽的，可以加速NPM、Github内的文件。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.44.57.jpg" /></p><p>点击GitHub栏，复制第一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://cdn.jsdelivr.net/gh/user/repo@version/file<br></code></pre></td></tr></table></figure><p>在PicGo中如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">仓库名：username/project</span><br><span class="hljs-attr">分支名：默认main</span><br><span class="hljs-attr">Token：复制的Personal</span> <span class="hljs-string">access token</span><br><span class="hljs-attr">存储路径：指定文件夹，也可以不指定，就在工程当前目录下</span><br><span class="hljs-attr">自定义域名：https</span>:<span class="hljs-string">//cdn.jsdelivr.net/gh/user/repo@version</span><br><span class="hljs-attr">--user</span>:<span class="hljs-string">username</span><br><span class="hljs-attr">--repo</span>:<span class="hljs-string">your project</span><br><span class="hljs-attr">--version</span>:<span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>整体配置界面如下：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.10.31.jpg" /></p><h2 id="上传图片">4.上传图片</h2><p>开启Markdown自动上传图片功能后，只要往Markdown中复制图片进去，则PicGo会自动把我们的图片上传到GitHub上。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_17.11.09.jpg" /></p><blockquote><p>图片的链接地址为：</p><p>https://cdn.jsdelivr.net/gh/username/project@version/路径(可选)/your_photo</p></blockquote><h1 id="使用aliyun-osspicgo搭建图床">3.使用AliyunOSS、PicGo搭建图床</h1><p>由于Github仓库有限制(不能大于1G且单个文件不能大于100M)，如果我们的文件图片过大，则加载图片还是会很慢，如果觉得GitHub速度还是不够快，我们则可以使用服务商的OSS服务。OSS服务商有多个，本文使用的是AliyunOSS。</p><h2 id="购买oss服务">1.购买OSS服务</h2><ul><li><p>开通<ahref="https://www.aliyun.com/product/oss/">阿里云OSS服务</a></p></li><li><p>在<ahref="https://common-buy.aliyun.com/?spm=5176.8465980.0.0.4e701450E6303q&amp;commodityCode=ossbag&amp;request=%7B%22region%22%3A%22china-common%22%7D#/buy">阿里云OSS</a>选择购买相应的存储OSS服务。</p></li></ul><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_18.09.51.jpg" /></p><h2 id="创建bucket">2.创建Bucket</h2><p>开通OSS且购买OSS服务之后，我们会有一个OSS的控制台界面，点击<strong>创建Bucket</strong>，出现如下界面：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_21.57.33.jpg" /></p><p>关于流量费用的介绍，可以访问官方的帮助页面。通常选择「<strong>按量计费</strong>」。</p><p><strong>流量费用的多少取决于你使用阿里云图床的程度</strong>。一般来说，10元钱能管几个月。</p><p>为了便于理解「存储空间费用」和「流量费用」，可以简单<strong>将它们比作手机套餐的<code>月租</code>和<code>流量</code></strong>。如果你天天刷剧把4G流量用完了，仅仅交月租还不够，超标的流量也要掏钱的。</p><h2 id="添加accesskey">3. 添加AccessKey</h2><p>鼠标悬停头像，出现如下页面。选择<code>AccessKey管理</code>，点击创建，即可创建AccessKey。我选择的是直接使用。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_22.02.06.jpg" /></p><blockquote><p>如果选择的是添加子账户，则新建一个子账户后再获取AccessKet，注意到是需要给子账户添加OSS服务权限</p></blockquote><h2 id="配置picgo">4.配置PicGo</h2><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_22.08.42.jpg" /></p><p>其中：</p><ul><li><code>设定KeyId</code>和<code>设定KeySecret</code>处填写前面记录的<strong>AccessKeyID</strong>和<strong>AccessKey Secret</strong>。</li><li><code>设定存储空间名</code>处填写创建的Bucket的名字。</li><li><code>确定存储区域</code>也是在创建Bucket时设定的。如果忘记了，可在阿里云后台的Bucket概览界面查看，比如我的是<strong>oss-cn-beijing</strong>。见下图。</li></ul><table><thead><tr class="header"><th style="text-align: left;">Endpoint（地域节点）</th><th style="text-align: left;">Bucket 域名</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">oss-cn-beijing.aliyuncs.com</td><td style="text-align: left;">~.oss-cn-beijing.aliyuncs.com</td></tr></tbody></table><ul><li><code>指定存储路径</code>可填写为<strong>img/</strong>。</li></ul><h2 id="上传图片-1">5.上传图片</h2><p>同样，通过typora设置自动上传后，我们就可以直接在Markdown中插入图片。PicGo会自动将图片上传到OSS上，速度极快，所以花钱才是硬道理啊，:joy::joy::joy:。</p><figure><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-05_22.34.52.jpg"alt="iShot_2022-05-05_22.34.52" /><figcaption aria-hidden="true">iShot_2022-05-05_22.34.52</figcaption></figure><p>阿里云官网: <em>https://www.aliyun.com</em></p><blockquote><p>由于Gitee现在在慢慢增加防盗链的功能，建立在Gitee上的图床以后就不能再使用了。如果Gitee上的图片还能再外链，需要移动Markdown文件图片到阿里云OSS图床，可以在PicGo中增加插件pic-migrater。如果Gitee上的图片已经不能再外链，则现在没有具体的办法。迁移Gitee图床到OSS的具体操作。网上有很多的文章，此处不再详述，有需要的小伙伴可以去尝试一下。</p></blockquote><h1 id="free-image-resource">4. Free Image Resource</h1><p>:lollipop:: <a href="https://barnimages.com/">Beautiful Free Photosfor Everyone | Barnimages</a></p><p>:lollipop:: <a href="https://unsplash.com/">Beautiful Free Images&amp; Pictures | Unsplash</a></p><p>:lollipop:: <a href="https://pikwizard.com/">Free Commercial StockPhotos &amp; Royalty Free Images | PikWizard</a></p><p>:lollipop:: <a href="https://www.rawpixel.com/">Free Stock Photos,PNGs, Templates &amp; Mockups | rawpixel</a></p><p>:lollipop:: <ahref="https://www.splitshire.com/best-new-free-stock-photos/">Best newfree stock photos - SplitShire</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac使用Hexo、GitHub Pages搭建博客</title>
    <link href="/2022/05/03/build_blog/2022-05-03_Mac%E4%BD%BF%E7%94%A8Hexo%E3%80%81GitHub-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/05/03/build_blog/2022-05-03_Mac%E4%BD%BF%E7%94%A8Hexo%E3%80%81GitHub-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>该篇文章默认用户已经掌握Git、GitHub、Markdown相关知识，故不赘述。</p><p>了解Markdown的使用，可访问<a href="https://markdown.com.cn/">Markdown官方教程</a>。</p><h1 id="安装前提">1.安装前提</h1><p>在安装前，需要以下应用程序作为支持。如果没有安装以下应用程序则需要安装。</p><ul><li><a href="https://nodejs.org/en/">Node.js</a></li><li><a href="https://git-scm.com/">Git</a></li></ul><p>查看应用程序是否安装成功，显示出版本信息即为安装成功。</p><p>查看Node.js的版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br></code></pre></td></tr></table></figure><p>查看Git的版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git version<br></code></pre></td></tr></table></figure><h1 id="配置github-pages">2.配置GitHub Pages</h1><p>使用GitHub Pages前，应注意以下两点：</p><ul><li>GitHubPages使用HTTP协议，而不是HTTPS，请不要使用它传输敏感信息，比如密码或者银行账号。</li><li>即使你的仓库是私有的，GitHubPages也是公开在互联网中的，所以，如果您的仓库中具有敏感数据，请在发布前移除之。</li></ul><h2 id="基本页面的生成">1. 基本页面的生成</h2><p>创建一个新的 Repository，进入页面后，在 Repository name的位置填写域名，格式是<code>username.github.io</code>。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.19.01.jpg" /></p><h2 id="配置pages">2. 配置Pages</h2><p>创建成功之后，点击右上角的 Settings，找到 GitHub Pages 选项，选择一个GitHub 官方提供的主题，随意选择一个主题Cayman，来看看他的效果是什么样的。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.20.40.jpg" /></p><p>选择完毕之后 GitHub Pages就会自动生成好网站，在浏览器里输入你的项目名称，比如输入一个本文搭建的<ahref="https://nanchengjiumeng123.github.io/">nanchengjiumeng123.gitHub.io</a>，就可以看到刚刚选择的主题的个人网站的页面了。因此利用GitHubPages搭建的网站就可以访问了。</p><h1 id="配置hexo">3. 配置Hexo</h1><p><strong>hexo</strong>是一个快速，简洁且高效的博客框架精美的博客。常见的主题有<ahref="https://jekyllrb.com/">Jekyll</a>、<ahref="https://hexo.io/zh-cn/">Hexo</a>等等。本文使用Hexo为GitHubPages配置主题。</p><h2 id="安装hexo">1.安装Hexo</h2><p>安装好Node.js之后，我们便可以使用<code>npm</code>命令。npm是node.js的包管理工具，用它来安装hexo。也可以使用brew来安装。</p><p>检查<ahref="https://link.segmentfault.com/?enc=ipg%2FvdF0TXBCuGZYSFrRYA%3D%3D.lxfJsSC4Lt8VxYtzC%2Bb1RfrvTELGXTWyrhKkqKSVUIM%3D">npm</a>是否安装成功:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">npm -v<br></code></pre></td></tr></table></figure><p>输入命令安装Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h2 id="初始化blog">2.初始化Blog</h2><p>安装完成后，我们在一个指定位置在创建一个blog文件夹，在该文件夹下初始化我们的博客。文件路径取自定义的文件路径，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /Users/wangwang/Desktop/blog <br></code></pre></td></tr></table></figure><p>在该文件件目录下执行博客初始化操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 会下载一些node.js的依赖文件</span><br>hexo init<br></code></pre></td></tr></table></figure><p>初始化成功后，在blog目录下执行预览操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s <br></code></pre></td></tr></table></figure><p>当看到如下输出就可以预览我们创建的博客了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>预览效果：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.20.55.jpg" /></p><h2 id="常用hexo常用命令">3.常用hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;博客名称&quot;</span>  =&gt; hexo new <span class="hljs-string">&quot;博客名称&quot;</span>   <span class="hljs-comment">#这两个都是创建新文章，前者是简写模式</span><br>hexo p  =&gt; hexo publish<br>hexo g  =&gt; hexo generate  <span class="hljs-comment">#生成静态网页</span><br>hexo s  =&gt; hexo server  <span class="hljs-comment">#启动服务预览</span><br>hexo d  =&gt; hexo deploy  <span class="hljs-comment">#部署  </span><br><br>hexo server   <span class="hljs-comment">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br>hexo server -s   <span class="hljs-comment">#静态模式</span><br>hexo server -p 5000   <span class="hljs-comment">#更改端口</span><br>hexo server -i 192.168.1.1   <span class="hljs-comment">#自定义IP</span><br>hexo clean   <span class="hljs-comment">#清除缓存，网页正常情况下可以忽略此条命令</span><br></code></pre></td></tr></table></figure><h2 id="相关主题资源">4.相关主题资源</h2><ul><li><p><a href="http://jekyllthemes.org/">jekyllthemes</a></p></li><li><p><ahref="https://jekyll-themes.com/free/">jekyll-themes</a></p></li><li><p><a href="https://hexo.io/themes/">hexo.io-themes</a></p></li></ul><h1 id="配置ssh-key">4.配置SSH Key</h1><p>在命令行输入配置用户名和账号的命令，其中 <code>username</code>是你的用户名，<code>email@gmail.com</code>是你github的登录邮箱。自行替换相应字段，比如邮箱等等。如果已经配置过，该步骤可以忽略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email@gmail.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后通过终端命令生成SSH Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;@gmail.com&quot;</span><br></code></pre></td></tr></table></figure><p>如果已经创建过会出现 <code>Overwrite (y/n)? n</code>提示可以输入<code>n</code>，如果没有创建过会要求我们输入密码，然后一路回车下去就行，执行完成后会在<code>~/.ssh/id_rsa.pub</code>目录下生成需要使用的 key。</p><p>可以使用命令行输出key并复制，或者找到这个文件并打开它，复制里面的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>登录github账号 找到<code>Setting</code>，<strong>注意不是项目的<code>Setting</code>，是用户栏目下面的<code>Setting</code></strong>。先点击<code>SSH and GPG keys</code> 然后再点击<code>New SSH key</code>进入到配置 SSH Key的页面，然后输入复制好的key的内容。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.21.31.jpg" /></p><p>测试是否修改成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果出现<code>Hi xxxx! You've successfully authenticated...</code>则表示配置成功。</p><h1 id="发布">5. 发布</h1><p>到此处我们已经配置好了Hexo与GitHubpages，由于hexo安装好还未配置主题。因此我们可以使用Hexo定义主题，本文选用的是<code>Fliud</code>主题，如果想使用其他主题则需要自己去获取相关主题资源。</p><p>如何安装该主题已经在<ahref="https://hexo.fluid-dev.com/docs/start/">Hexo Fliud用户手册</a>里讲的十分透彻。需要注意以下几点，这是我走的弯路。</p><ul><li><p>复制的<code>_config.fluid.yml</code>文件是文件夹<code>node_module</code>下<code>hexo-theme-fluid</code>的<code>_config.yml</code>文件。不是FluidGitHub上工程的<code>_config.fluid.yml</code></p></li><li><p>如果没有<code>node_module</code>则先跟着文档安装Fuild主题后，依次执行，则会出现该文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hexo clean<br>Hexo g<br></code></pre></td></tr></table></figure></li></ul><h2 id="生成文件及本地调试">1.生成文件及本地调试</h2><p>初始化后执行 <code>hexo generate</code> 或 <code>hexo g</code>可生成静态文件（<code>public</code>文件夹）与缓存文件（<code>data.json</code>）。</p><p>然后我们执行 <code>hexo server</code> 或 <code>hexo s</code>就可以启动本地服务器，访问网址 <code>http://localhost:4000/</code>就可以查看文章效果了。</p><h2 id="发布文件">2.发布文件</h2><p>Hexo发布文件到GitHub需要安装<code>deployer</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改配置文件 <code>_config.yml</code>，修改<code>deploy</code>部分为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>然后就可以把博客push到对应的<code>username</code>的GitHub上，在命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#清空静态文件与缓存文件</span><br>hexo clean<br><span class="hljs-comment">#生成我们想要的博客文件</span><br>hexo g<br><span class="hljs-comment">#将本地的博客文件push到github</span><br>hexo d<br></code></pre></td></tr></table></figure><p><code>hexo d</code>执行成功后，就可以查看我们的Blog了，可以发现我们的Blog主题已经改变为<code>Fluid</code>主题样式，可以根据文档自定义自己的主题样式。</p><p><strong>导航</strong> ：</p><p>:lollipop:: <a href="https://hexo.fluid-dev.com/docs/start/">FluidStart</a> :lollipop:: <ahref="https://hexo.fluid-dev.com">Fluid主题界面</a></p><h1 id="自定义域名">6. 自定义域名</h1><p>此时，我们已经完成一个Blog的基本功能，每次写了新的文件即可通过hexo相关命令发布到GitHubPages上。过几分后即可查看我们新发布的文章。但是Blog的网址为<code>username.github.io</code>难免不太好看，我们因此可以使用自定义域名。</p><h2 id="获取域名">1.获取域名</h2><p>使用<ahref="https://wanwang.aliyun.com/domain">阿里云域名</a>注册一个域名，现在购买域名需要实名认证，因此需要先实名认证后再购买域名。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.26.02.jpg" /></p><h2 id="配置dns">2.配置DNS</h2><p>首先获得自己的Github Page的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping username.github.io<br></code></pre></td></tr></table></figure><p>也可以直接使用下面的IP地址</p><ul><li>185.199.108.153</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul><p>然后添加记录，有多少个IP地址就添加多少条记录。可以以下图所示作为参考设置：</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.21.56.jpg" /></p><h2 id="github-pages绑定域名">3.GitHub Pages绑定域名</h2><p>在GitHubPages如图配置里，在<code>Custon domain</code>写上自定义域名。出现<code>Your site is published at ...</code>在表明配置成功。在浏览器中填入自定义域名即可访问自己的Blog。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.19.01.jpg" /></p><p><strong>注：</strong></p><p>如果在发布之后，GitHubPages上自定义的域名<code>Custom domain</code>被还原。可以在Blog的<code>source</code>目录新建一个名为<code>CNAME</code>的文件，将自己的购买的域名填入进去即可。</p><h1 id="cdn加速">7. CDN加速</h1><p>由于GitHubPages的服务器在国外，国内访问会比较慢。因此可以配置CDN加速。常见的CDN加速有很多，我们选择<ahref="https://www.cloudflare.com/">Cloudflare</a>作为CDN加速，它有免费的加速版本，但是足够我们写Blog的需求了。俗话说：<code>可以不要，但不可以没有</code>，白嫖的它不香吗。</p><h2 id="添加站点">1. 添加站点</h2><p>首先访问选择<ahref="https://www.cloudflare.com/">Cloudflare</a>注册一个你自己的账户，然后添加自己的站点，我们将自己购买的域名作为自己的站点。提交之后会自动扫描域名对应的解析记录</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.22.20.jpg" /></p><h2 id="修改运营商dns">2.修改运营商DNS</h2><p>复制Cloudflare的DNS，通过域名的运营商修改对应的 DNS记录，由于我是在阿里云购买的域名，因此修改阿里云默认的DNS为</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.24.25.jpg" /></p><p>登陆自己的Blog，如果如下则表示配置成功。<code>cloudflare</code>不一定一直会提供免费版的，如果以后不再支持免费版，只需要把DNS 的解析记录再还原回去就行了。</p><p><imgsrc="https://nanchengjiumeng123.oss-cn-beijing.aliyuncs.com/categories/build_blog/iShot_2022-05-04_18.24.45.jpg" /></p><h1 id="hexo拓展">8.Hexo拓展</h1><p>Hexo默认是采用<code>hexo-renderer-marked</code>渲染器将markdown渲染成HTML，这个渲染器不支持插件扩展，因此不能支持表情；还有一个支持插件扩展的是<code>hexo-renderer-markdown-it</code>，所以我们可以使用这个渲染引擎来支持emoji表情。</p><h2 id="更换渲染器">1.更换渲染器</h2><p>进入blog跟目录，执行如下命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm un hexo-renderer-marked --save<br>npm i hexo-renderer-markdown-it --save<br></code></pre></td></tr></table></figure></p><h2 id="安装emoji插件">2.安装emoji插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install markdown-it-emoji --save<br></code></pre></td></tr></table></figure><h2 id="编辑站点配置文件">3.编辑站点配置文件</h2><p>就是编辑根目录的_config.yml文件，添加如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Markdown-it config</span><br><span class="hljs-comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">render:</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment"># 是否对HTML标签进行解析，false时HTML将按照原样输出</span><br>    <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment"># 是否需要满足严格的XHTML格式，换行为&lt;br /&gt;</span><br>    <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">quotes:</span> <span class="hljs-string">&#x27;“”‘’&#x27;</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span>  <span class="hljs-comment"># add emoji</span><br>  <span class="hljs-attr">anchors:</span><br>    <span class="hljs-comment"># Minimum level for ID creation. (Ex. h2 to h6)</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-number">2</span><br>    <span class="hljs-comment"># A suffix that is prepended to the number given if the ID is repeated.</span><br>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">&#x27;v&#x27;</span><br>    <span class="hljs-comment"># If `true`, creates an anchor tag with a permalink besides the heading.</span><br>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># Class used for the permalink anchor tag.</span><br>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">header-anchor</span><br>    <span class="hljs-comment"># The symbol used to make the permalink</span><br>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">¶</span><br></code></pre></td></tr></table></figure><h1 id="总结">9.总结</h1><p>到此，我们的一个完整的Blog就搭建成功了。以上过程都是自己全部一步一步做过来的。因此记录下来。供有想自己搭建独立博客的人做一个参考。当然，此时的博客在百度和谷歌都是搜索不到的。需要配置站点地图。我只配置的GooGle搜索。这些都相对简单因此不必再赘述，有想法的人可以搜索相关知识即可。</p><p>:lollipop:: <ahref="https://search.google.com/search-console">谷歌收录Google SearchConsole</a></p><hr /><p><strong>博客说明</strong></p><blockquote><p>文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，不用于任何的商业用途。如有侵权，请联系本人删除。谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
